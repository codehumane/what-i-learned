# Monolith to Microservices

1, 2장 읽었는데 생각보다 재밌음. 기록도 같이 하기로.

# CH3. Splitting the Monolith

- 앞서 MSA가 좋을지 안 좋을지 고민했음.
- 만약, 좋은 경우라면 어떻게 시작해야 할까?

## To Change the Monolith, or Not?

- 가장 먼저 생각해 볼 것 중 하나가 현재 모놀리스를 바꿀지 말지.
- 현재 모놀리스 수정이 가능하다면 유연하게 계획 세울 수 있음.
- 하지만 그렇지 않을 수도 있으며 다양한 예시를 소개.
- 그리고 이 때의 대응법들을 하나씩 설명.

### Cut, Copy, or Reimplement?

- 초기에는 모놀리스로부터 코드를 복제하는 게 좋음.
- 즉, 모놀리스에는 코드를 남겨놓는 게 좋음.
- 일정 기간 우리에게 더 많은 선택지를 제공하기 때문.
- 롤백을 할 수도 있고, 2개 기능을 병렬로 실행할 수도 있음.
- 마이그레이션이 성공이면 그 때 모놀리스에서 코드를 제거.

### Refactoring the Monolith

- 기존의 모놀리스는 보통 기술 레이어로 구조화되어 있음.
- 도메인에 맞춰 구조화되어 있지 않으며, 이는 MSA화의 일반적 어려움.
- Working Effectively with Legacy Code 책에 나왔던 것처럼,
- 접합부<sup>seam</sup>를 찾고 새로운 구현체를 만들고 교체하기를 권장.
- 이는 바운디드 컨텍스트와도 매우 잘 맞음.

#### A modular monolith?

- 모놀리스의 접합부들을 새로운 모듈로 나눠갈 수 있음.
- 여전히 한 단위로 배포하지만, 여러 모듈이 정적으로 연결된 구성.
- 시스템 분리에 비해 모듈 분리는 좀 더 가역적 결정.

#### Incremental rewrites

- 저자는 일단 기존 코드베이스를 구조화하는 것을 먼저 시도.
- 때로는 이 작업을 통해 마이크로서비스가 필요 없음을 깨닫기도.
- 하지만 보통은 새로운 시스템을 바로 분리하는 경우를 더 많이 만남.
- 만약, 며칠에서 몇 주의 작업이라면 기존 코드 구조화를 먼저 시도.
- 몇 달이 걸리는 일이라면 저자의 접근법을 재검토.

## Migration Patterns

> 각 패턴의 장단점을 이해할 것. 이들이 모든 상황에 적절한 건 아님.

- 마이그레이션을 위한 여러 패턴들을 이제 살펴볼 것.
- 특별한 건 없을 듯 해서 간단히만 기록.
