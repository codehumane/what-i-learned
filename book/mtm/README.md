# Monolith to Microservices

1, 2장 읽었는데 생각보다 재밌음. 기록도 같이 하기로.

# CH3. Splitting the Monolith

- 앞서 MSA가 좋을지 안 좋을지 고민했음.
- 만약, 좋은 경우라면 어떻게 시작해야 할까?

## To Change the Monolith, or Not?

- 가장 먼저 생각해 볼 것 중 하나가 현재 모놀리스를 바꿀지 말지.
- 현재 모놀리스 수정이 가능하다면 유연하게 계획 세울 수 있음.
- 하지만 그렇지 않을 수도 있으며 다양한 예시를 소개.
- 그리고 이 때의 대응법들을 하나씩 설명.

### Cut, Copy, or Reimplement?

- 초기에는 모놀리스로부터 코드를 복제하는 게 좋음.
- 즉, 모놀리스에는 코드를 남겨놓는 게 좋음.
- 일정 기간 우리에게 더 많은 선택지를 제공하기 때문.
- 롤백을 할 수도 있고, 2개 기능을 병렬로 실행할 수도 있음.
- 마이그레이션이 성공이면 그 때 모놀리스에서 코드를 제거.

### Refactoring the Monolith

- 기존의 모놀리스는 보통 기술 레이어로 구조화되어 있음.
- 도메인에 맞춰 구조화되어 있지 않으며, 이는 MSA화의 일반적 어려움.
- Working Effectively with Legacy Code 책에 나왔던 것처럼,
- 접합부<sup>seam</sup>를 찾고 새로운 구현체를 만들고 교체하기를 권장.
- 이는 바운디드 컨텍스트와도 매우 잘 맞음.

#### A modular monolith?

- 모놀리스의 접합부들을 새로운 모듈로 나눠갈 수 있음.
- 여전히 한 단위로 배포하지만, 여러 모듈이 정적으로 연결된 구성.
- 시스템 분리에 비해 모듈 분리는 좀 더 가역적 결정.

#### Incremental rewrites

- 저자는 일단 기존 코드베이스를 구조화하는 것을 먼저 시도.
- 때로는 이 작업을 통해 마이크로서비스가 필요 없음을 깨닫기도.
- 하지만 보통은 새로운 시스템을 바로 분리하는 경우를 더 많이 만남.
- 만약, 며칠에서 몇 주의 작업이라면 기존 코드 구조화를 먼저 시도.
- 몇 달이 걸리는 일이라면 저자의 접근법을 재검토.

## Migration Patterns

> 각 패턴의 장단점을 이해할 것. 이들이 모든 상황에 적절한 건 아님.

- 마이그레이션을 위한 여러 패턴들을 이제 살펴볼 것.
- 특별한 건 없을 듯 해서 간단히만 기록.

## Pattern: Strangler Fig Application

- [Strangler Fig Application](https://martinfowler.com/bliki/StranglerFigApplication.html).
- 필요시 변경을 빠르고 쉽게 돌릴 수 있는 게 장점.
- 기존 시스템을 건드리지 않으므로, 모놀리스의 경합으로부터 자유로운 것도 장점.
- 프록시 도입 시 여러 팀이 공유하고 같이 수정해야 한다면 이 또한 경합이므로 주의.
- 공유 미들웨어 계층의 기능 수는 가급적 줄여야 함.
- 큐를 수신하는 경우엔, 기존 대기열을 먼저 수신하는 컨텐츠 기반 라우터를 먼저 추가하고, 여기서 컨텐트에 따라 모놀리스와 신규 서비스의 대기열로 분류해서 메시지를 전달하기도.

## Changing Behavior While Migrating Functionality

- 계속 점진적 마이그레이션을 얘기하는 이유 중 하나는,
- 마이그레이션과 피처 개발을 적절히 섞을 수 있기 때문.
- 그러나, 마이그레이션 중인 기능의 변경은 어려움.
- 예컨대, 신규 서비스로 추출한 기능에 대해 몇 가지 버그 픽스나 기능 변경을 추가.
- 이 경우 과거 모놀리스로 호출을 돌리면 이 변경들이 사라짐.
- 마이그레이션 중인 기능의 변경은 어려움을 받아들여야 함.
- 마이그레이션 단위를 매우 작게 쪼개면,
- 마이그레이션 동안의 기능 변경은 허용하지 않기 쉬워지고,
- 따라서 이 어려움을 최소화할 순 있음.
