# Monolith to Microservices

1, 2장 읽었는데 생각보다 재밌음. 기록도 같이 하기로.

# CH3. Splitting the Monolith

- 앞서 MSA가 좋을지 안 좋을지 고민했음.
- 만약, 좋은 경우라면 어떻게 시작해야 할까?

## To Change the Monolith, or Not?

- 가장 먼저 생각해 볼 것 중 하나가 현재 모놀리스를 바꿀지 말지.
- 현재 모놀리스 수정이 가능하다면 유연하게 계획 세울 수 있음.
- 하지만 그렇지 않을 수도 있으며 다양한 예시를 소개.
- 그리고 이 때의 대응법들을 하나씩 설명.

### Cut, Copy, or Reimplement?

- 초기에는 모놀리스로부터 코드를 복제하는 게 좋음.
- 즉, 모놀리스에는 코드를 남겨놓는 게 좋음.
- 일정 기간 우리에게 더 많은 선택지를 제공하기 때문.
- 롤백을 할 수도 있고, 2개 기능을 병렬로 실행할 수도 있음.
- 마이그레이션이 성공이면 그 때 모놀리스에서 코드를 제거.

### Refactoring the Monolith

- 기존의 모놀리스는 보통 기술 레이어로 구조화되어 있음.
- 도메인에 맞춰 구조화되어 있지 않으며, 이는 MSA화의 일반적 어려움.
- Working Effectively with Legacy Code 책에 나왔던 것처럼,
- 접합부<sup>seam</sup>를 찾고 새로운 구현체를 만들고 교체하기를 권장.
- 이는 바운디드 컨텍스트와도 매우 잘 맞음.

#### A modular monolith?

- 모놀리스의 접합부들을 새로운 모듈로 나눠갈 수 있음.
- 여전히 한 단위로 배포하지만, 여러 모듈이 정적으로 연결된 구성.
- 시스템 분리에 비해 모듈 분리는 좀 더 가역적 결정.

#### Incremental rewrites

- 저자는 일단 기존 코드베이스를 구조화하는 것을 먼저 시도.
- 때로는 이 작업을 통해 마이크로서비스가 필요 없음을 깨닫기도.
- 하지만 보통은 새로운 시스템을 바로 분리하는 경우를 더 많이 만남.
- 만약, 며칠에서 몇 주의 작업이라면 기존 코드 구조화를 먼저 시도.
- 몇 달이 걸리는 일이라면 저자의 접근법을 재검토.

## Migration Patterns

> 각 패턴의 장단점을 이해할 것. 이들이 모든 상황에 적절한 건 아님.

- 마이그레이션을 위한 여러 패턴들을 이제 살펴볼 것.
- 특별한 건 없을 듯 해서 간단히만 기록.

## Pattern: Strangler Fig Application

- [Strangler Fig Application](https://martinfowler.com/bliki/StranglerFigApplication.html).
- 필요시 변경을 빠르고 쉽게 돌릴 수 있는 게 장점.
- 기존 시스템을 건드리지 않으므로, 모놀리스의 경합으로부터 자유로운 것도 장점.
- 프록시 도입 시 여러 팀이 공유하고 같이 수정해야 한다면 이 또한 경합이므로 주의.
- 공유 미들웨어 계층의 기능 수는 가급적 줄여야 함.
- 큐를 수신하는 경우엔, 기존 대기열을 먼저 수신하는 컨텐츠 기반 라우터를 먼저 추가하고, 여기서 컨텐트에 따라 모놀리스와 신규 서비스의 대기열로 분류해서 메시지를 전달하기도.

## Changing Behavior While Migrating Functionality

- 계속 점진적 마이그레이션을 얘기하는 이유 중 하나는,
- 마이그레이션과 피처 개발을 적절히 섞을 수 있기 때문.
- 그러나, 마이그레이션 중인 기능의 변경은 어려움.
- 예컨대, 신규 서비스로 추출한 기능에 대해 몇 가지 버그 픽스나 기능 변경을 추가.
- 이 경우 과거 모놀리스로 호출을 돌리면 이 변경들이 사라짐.
- 마이그레이션 중인 기능의 변경은 어려움을 받아들여야 함.
- 마이그레이션 단위를 매우 작게 쪼개면,
- 마이그레이션 동안의 기능 변경은 허용하지 않기 쉬워지고,
- 따라서 이 어려움을 최소화할 순 있음.

## Pattern: UI Composition

- UI에서의 마이그레이션.
- 가디언지의 온라인 CMS를 개편할 일이 있었음.
- 점진적 마이그레이션을 선호했기에 수직 분할로 교체.
- 여행, 뉴스, 문화, ... 식으로.
- 그리고 그 안에서도 더 나눌 건 없을지 계속 탐색.
- 2가지 구성 기법이 유용했음.
- 페이지 컴포지션과 위젯 컴포지션.
- 내용은 특별한 게 없어 생략.
- 모바일 UI 얘기도 나옴.
- 앱은 웹과 달리 릴리즈를 위해 제출과 심사가 필요.
- 그래서 앱 배포 없이, 서버 쪽에서 변경을 배포하면, 앱에서 동적으로 신규 기능을 쓸 수 있게끔.

## Pattern: Branch by Abstraction

- strangler fig를 위해선 시스템 경계부 호출을 가로채야 함.
- 하지만, 기존 시스템의 깊은 부분을 추출하려면 기존 코드를 수정해야 함.
- 별도 브랜치(그리고 브랜치 수명은 보통 길기 마련)에서 이 변경을 수행하면 병합 시 고통.
- 점진적으로 코드베이스를 변경하면서도, 코드를 공유하는 다른 개발자에게 덜 영향을 미쳐야 함.
- branch by abstraction.

### How It Works

- 흔히 보는 방식이라 기록은 간단히만.
- 1단계: 추상화 생성
- 2단계: 추상화 사용
- 3단계: 새로운 구현 추가
- 4단계: 구현 전환
- 5단계: 기존 구현과 추상화 제거

### As a Fallback Mechanism

- 4단계 후 만약 신규 구현 호출이 실패하면,
- 기존 구현을 폴백으로 호출하는 것.

## Pattern: Parallel Run

- 과거와 신규 구현 모두를 호출하고, 결과를 비교하는 것.
- 기능적인 검증뿐만 아니라, 실패율이나 지연 시간 등 비기능적 요구사항 검증까지.
- 가장 먼저 소개하는 사례는 가격 책정 시스템.
- 과거 서비스를 호출하면 과거 디비에 데이터가 쌓이고,
- 동시에 신규 서비스 호출하면 신규 디비에 데이터가 쌓이며,
- 적절한 주기로 두 디비 데이터를 비교해 검증.
- 스파이 사용도 얘기.
- 알림 서비스를 예로 설명.
  - 신규 서비스 추출 후 병행 실행.
  - 이 때, 메일 발송이 두 번 일어나면 안 됨.
  - 따라서, 신규 서비스에서는 스파이를 적용.
  - 발송 호출 받으면 메일 발송 대신 기록만 남기고 끝나는 것.
  - 이 기록은 나중에 확인이나 검증을 위해 활용.
  - 문제 없으면 스파이를 실제 구현으로 대체.
- 카나리 릴리즈와 다크 런칭 얘기도.
- 병행 실행은 카나리가 아니라 다크 런칭의 한 구체화라는.

## Pattern: Decorating Collaborator

- 잘 사용되지는 않아 보임.
- 기존 구현을 고치지 못하는 경우 데코레이터 패턴 활용.
- 여기서는 프록시를 추가하고, 프록시에서 과거 버전과 신규 버전으로의 호출을 적절히 제어하는 것.
- 저자가 경계하는 미들웨어가 똑똑해지는(비대해지는) 문제가 있음.
- 더불어, 프록시에서는 내부 데이터를 잘 알지 못하기에, 신규 서비스 호출을 위한 추가 데이터를 과거 시스템에 질의해야 할 수도(이는 신규 기능 개발이 필요할 수도).

## Pattern: Change Data Capture

- 이 역시 경계해야 할 방법.
- 디비 트리거나, 디비 트랜잭션 로그를 활용.
- 변경을 감지하고 적절한 신규 서비스로 이를 알려주기.
- 데이터를 주기적으로 질의해서 알려줄 수도 있음(batch delta copier).
- 하지만 디비 스키마 등의 제약에 의해 중요한 변경이 유실될 수도.

# CH4. Decomposing the Database

- 마이크로서비스는 정보 은닉 위에 잘 동작함.
- 결국 데이터 저장소와 검색 메커니즘의 캡슐화 필요.
- 데이터도 함께 분리해야 함.
- 하지만 어려움.
- 데이터 전환 중 동기화, 트랜잭션 무결성, 논리적/물리적 스키마 분해, 조인, 지연, ...

## Pattern: The Shared Database

- 커플링을 3개로 나눠 생각할 수 있음.
- 도메인 커플링, 일시적 커플링, 구현 커플링.
- 데이터베이스를 다룰 땐 보통 구현 커플링.
- 서비스들이 동일 데이터베이스를 공유하기 때문.
- 변경 영향이 큼. 즉, 느리고 위험.

### Coping Patterns

- 일단, 각 서비스가 각자의 데이터를 소유하는 게 제일 좋음.
- 불가하다면, 뒤에서 다룰 뷰 패턴을 고려(물론 좋지 않음).
- 또는, 데이터베이스 래핑 서비스 패턴 사용(권장 X).

### Where to Use It

- 저자 생각에는 2가지 경우에 적절.
- 하나는 읽기 전용 정적 참조 데이터인 경우.
- 예컨대 각 나라의 환율 코드 정보, 우편 번호.
- 잘 바뀌지 않으며 어드민 작업으로 변경 관리.
- 나머지 하나는, 데이터베이스를 의도적으로 엔드포인트로 노출한 경우.
- 서비스 인터페이스로서의 데이터베이스 패턴에서 다룰 예정.

## But It Can't Be Done!

- 모놀리스 분리 초기엔 스키마를 독립적으로 구성하긴 어려울 수도.
- 시간도 오래 걸리고, 시스템의 민감한 부분을 변경해야 할 수도.
- 이 때는 일단 더 나빠지는 것은 막고 점진적으로 나아가기.
- 참고로, 데이터베이스와 스키마 용어 혼동 주의.
- 책에서는 데이터베이스를 논리적으로 격리된 스키마로 사용.

## Pattern: Database View

- 뷰를 이용하면 서비스 별로 스키마를 제한적으로 제공.
- 정보 은닉을 위함.
- 예컨대, 고객ID/주소/암호/멤버십카드번호 컬럼으로 이뤄진 모놀리스 테이블이 있음.
- 여기서 고객ID/멤버십카드번호 컬럼만으로 뷰를 구성하고 멤버십 서비스에겐 이 매핑 정보만 제공.
- 하지만, NoSQL에서는 뷰 기능을 지원하지 않는 게 대다수.
- 그리고 materialized view는 성능은 빠르나 캐시이므로 stale 데이터 문제 가짐.
- 무엇보다 뷰는 읽기 전용.
- 소유권도 문제인데, 공개된 뷰는 서비스 인터페이스와 유사하니, 원천 스키마를 다루는 곳에서 데이터 관리를 권장.
- 스키마 분해가 실용적이지 않을 때 뷰를 첫 단계로 시작하기엔 괜찮음.

## Pattern: Database Wrapping Service

- A, B, C 서비스가 공통 데이터베이스 스키마를 직접 참조하는 상황.
- 데이터베이스를 접근하는 D 서비스를 만들고, A~C가 데이터 접근/조작이 필요할 땐 D를 거치는 것.
- 이 역시 더 나빠지는 것을 돕는 수단 중 하나.
- 또한 스키마가 나의 소유가 아님을 명시화하는 효과도.
- 뷰에 비해 제약이 적은 것도 장점.

## Pattern: Database-as-a-Service Interface

- 때로는 클라이언트가 직접 데이터베이스에 질의하고 싶을 수 있음.
- 대량의 데이터를 조회해야 한다거나, Tableau 같은 SQL 엔드포인트를 필요로 하는 도구를 사용한다거나.
- 하지만, 서비스 경계 내에서 우리가 사용할 데이터베이스와 외부에 노출시킬 것은 구분해야 함.
- 한 가지 방법은 읽기 전용의 공개를 염두하고 설계한 전용 데이터베이스를 만들기.
- 이벤트 스트림이나 동기식 API를 제공하는 것과 어떤 측면에서는 비슷.
- 마틴 파울러의 [Reporting Database](https://martinfowler.com/bliki/ReportingDatabase.html)도 하나의 사례.
- 내부 데이터베이스 변경이 공개된 데이터베이스에 반영되는 시점은 다양.
- 아예 변경을 반영 안 할 수도.
- 따라서 클라이언트들은 데이터가 일관성을 보장하지 않음을 전제해야.
- 공개 데이터에비으소 변경 반영을 위해서는, [CDC](https://en.wikipedia.org/wiki/Change_data_capture)나 배치 프로세스 또는 이벤트 처리를 활용.
- 참고로 저자는 배치 프로세스가 잘 안 돌거나 오래 걸려서 문제가 된 경우가 많았다고.
- 뷰에 비해서는 유연하고 정교하지만, 추가 개발과 데이터베이스 관리 비용이 발생.

## Transferring Ownership

- 지금까지는 근본적 문제 해결이 아니라 임시 방편들 얘기.
- 애그리거트 관련 로직을 캡슐화하는 게 마이크로서비스라면,
- 결국 애그리거트의 상태나 관련 데이터도 서비스 소유 스키마로 이동해야 함.
- 그리고 다른 서비스가 이 데이터를 필요로 한다면 잘 정의된 인터페이스로 제공해야 함.

### Pattern: Aggregate Exposing Monolith

- 특별한 내용은 아님.
- 송장 서비스에서 승인을 위해 직원 정보 필요.
- 이 데이터는 모놀리스에 있음.
- 그럼 모놀리스에 서비스 엔드포인트(API, 이벤트 스트림 등) 추가.
- 송장 서비스가 필요로 하는 것을 명시화 하는 것.
- 이 때도 모놀리스가 단순한 데이터베이스 래퍼가 되면 안 됨.
- 여전히 모놀리스가 무엇을 노출하고 말지를 잘 관리해야 함.
- 이런 일련의 과정에서 다음으로 추출할 후보가 보이기도 함.
- 여기서는 직원 서비스.
- 데이터베이스 뷰를 제공하는 것에 비해 작업량은 더 들지만 장기적으로 이득.
- 뷰 제공은 모놀리스를 건드릴 수 없는 경우의 접근법으로 제한.
- 물론 이 때는 CDC, 데이터베이스 래핑 서비스 패턴도 함께 고려.

### Pattern: Change Data Ownership

- 이건 위와 반대로, 송장 서비스로 송장 관련 데이터들을 함께 추출하는 것.
- 이건 상대적으로 더 어려움.
- 외부 키 제약, 트랜잭션 경계 달라짐 등 때문.
- 이 어려움들은 뒤에서 다시 다룰 예정.

## Data Synchronization

- strangler fig 패턴의 장점은, 신규 서비스 사용 중 문제가 생기면 과거 서비스로 전환할 수 있다는 점.
- 하지만 이를 위해서는 서비스 간 데이터 동기화 문제를 함께 고려해야 함.
- 일단 얼마나 일관성 있어야 하는지를 먼저 결정.
- 만약 완전히 일관성 있어야 한다면 데이터를 한 곳에서 관리해야 함.
- 예컨대 모놀리스 데이터베이스 하나를 사용하고 신규 서비스에는 뷰를 통해 데이터 읽기.
- 그리고 이관이 성공적이라 판단되면 그 때 데이터도 이관.
- 하지만 공유 디비의 위험성은 매우 크니 일시적으로만 사용.
- 한편 코드와 데이터를 한 번에 이관해야 한다면(가능한 피해야겠지만),
- 신규 서비스로 스위칭하기에 앞서 데이터를 일괄로 복제해 갈 수 있음.
- 그러나 과거 서비스로 롤백할 경우 그 동안 생긴 변경은 과거 서비스엔 없음.
- 마지막으로 양 서비스 간 데이터 동기화 방법도 있으나 이는 매우 고려할 게 많음.

## Pattern: Synchronize Data in Application

- MySQL 데이터베이스에 있던 것을 Riak으로 옮겨야 했음.
- 데이터베이스가 오프라인일 수 있는 시간은 한정적.
- 당연히 데이터 유실은 없어야 함.
- 빠른 롤백도 가능해야 했음.
- 처음엔 MySQL이 SSOT였고,
- Riak에 계속 동기화 됐으며,
- 일정 시간 이후엔 Riak이 SSOT가 되고,
- MySQL은 차차 제거.
- 이 과정을 이제 세부적으로 설명.
