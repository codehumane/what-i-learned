# Monolith to Microservices

1, 2장 읽었는데 생각보다 재밌음. 기록도 같이 하기로.

# CH3. Splitting the Monolith

- 앞서 MSA가 좋을지 안 좋을지 고민했음.
- 만약, 좋은 경우라면 어떻게 시작해야 할까?

## To Change the Monolith, or Not?

- 가장 먼저 생각해 볼 것 중 하나가 현재 모놀리스를 바꿀지 말지.
- 현재 모놀리스 수정이 가능하다면 유연하게 계획 세울 수 있음.
- 하지만 그렇지 않을 수도 있으며 다양한 예시를 소개.
- 그리고 이 때의 대응법들을 하나씩 설명.

### Cut, Copy, or Reimplement?

- 초기에는 모놀리스로부터 코드를 복제하는 게 좋음.
- 즉, 모놀리스에는 코드를 남겨놓는 게 좋음.
- 일정 기간 우리에게 더 많은 선택지를 제공하기 때문.
- 롤백을 할 수도 있고, 2개 기능을 병렬로 실행할 수도 있음.
- 마이그레이션이 성공이면 그 때 모놀리스에서 코드를 제거.

### Refactoring the Monolith

- 기존의 모놀리스는 보통 기술 레이어로 구조화되어 있음.
- 도메인에 맞춰 구조화되어 있지 않으며, 이는 MSA화의 일반적 어려움.
- Working Effectively with Legacy Code 책에 나왔던 것처럼,
- 접합부<sup>seam</sup>를 찾고 새로운 구현체를 만들고 교체하기를 권장.
- 이는 바운디드 컨텍스트와도 매우 잘 맞음.

#### A modular monolith?

- 모놀리스의 접합부들을 새로운 모듈로 나눠갈 수 있음.
- 여전히 한 단위로 배포하지만, 여러 모듈이 정적으로 연결된 구성.
- 시스템 분리에 비해 모듈 분리는 좀 더 가역적 결정.

#### Incremental rewrites

- 저자는 일단 기존 코드베이스를 구조화하는 것을 먼저 시도.
- 때로는 이 작업을 통해 마이크로서비스가 필요 없음을 깨닫기도.
- 하지만 보통은 새로운 시스템을 바로 분리하는 경우를 더 많이 만남.
- 만약, 며칠에서 몇 주의 작업이라면 기존 코드 구조화를 먼저 시도.
- 몇 달이 걸리는 일이라면 저자의 접근법을 재검토.

## Migration Patterns

> 각 패턴의 장단점을 이해할 것. 이들이 모든 상황에 적절한 건 아님.

- 마이그레이션을 위한 여러 패턴들을 이제 살펴볼 것.
- 특별한 건 없을 듯 해서 간단히만 기록.

## Pattern: Strangler Fig Application

- [Strangler Fig Application](https://martinfowler.com/bliki/StranglerFigApplication.html).
- 필요시 변경을 빠르고 쉽게 돌릴 수 있는 게 장점.
- 기존 시스템을 건드리지 않으므로, 모놀리스의 경합으로부터 자유로운 것도 장점.
- 프록시 도입 시 여러 팀이 공유하고 같이 수정해야 한다면 이 또한 경합이므로 주의.
- 공유 미들웨어 계층의 기능 수는 가급적 줄여야 함.
- 큐를 수신하는 경우엔, 기존 대기열을 먼저 수신하는 컨텐츠 기반 라우터를 먼저 추가하고, 여기서 컨텐트에 따라 모놀리스와 신규 서비스의 대기열로 분류해서 메시지를 전달하기도.

## Changing Behavior While Migrating Functionality

- 계속 점진적 마이그레이션을 얘기하는 이유 중 하나는,
- 마이그레이션과 피처 개발을 적절히 섞을 수 있기 때문.
- 그러나, 마이그레이션 중인 기능의 변경은 어려움.
- 예컨대, 신규 서비스로 추출한 기능에 대해 몇 가지 버그 픽스나 기능 변경을 추가.
- 이 경우 과거 모놀리스로 호출을 돌리면 이 변경들이 사라짐.
- 마이그레이션 중인 기능의 변경은 어려움을 받아들여야 함.
- 마이그레이션 단위를 매우 작게 쪼개면,
- 마이그레이션 동안의 기능 변경은 허용하지 않기 쉬워지고,
- 따라서 이 어려움을 최소화할 순 있음.

## Pattern: UI Composition

- UI에서의 마이그레이션.
- 가디언지의 온라인 CMS를 개편할 일이 있었음.
- 점진적 마이그레이션을 선호했기에 수직 분할로 교체.
- 여행, 뉴스, 문화, ... 식으로.
- 그리고 그 안에서도 더 나눌 건 없을지 계속 탐색.
- 2가지 구성 기법이 유용했음.
- 페이지 컴포지션과 위젯 컴포지션.
- 내용은 특별한 게 없어 생략.
- 모바일 UI 얘기도 나옴.
- 앱은 웹과 달리 릴리즈를 위해 제출과 심사가 필요.
- 그래서 앱 배포 없이, 서버 쪽에서 변경을 배포하면, 앱에서 동적으로 신규 기능을 쓸 수 있게끔.

## Pattern: Branch by Abstraction

- strangler fig를 위해선 시스템 경계부 호출을 가로채야 함.
- 하지만, 기존 시스템의 깊은 부분을 추출하려면 기존 코드를 수정해야 함.
- 별도 브랜치(그리고 브랜치 수명은 보통 길기 마련)에서 이 변경을 수행하면 병합 시 고통.
- 점진적으로 코드베이스를 변경하면서도, 코드를 공유하는 다른 개발자에게 덜 영향을 미쳐야 함.
- branch by abstraction.

### How It Works

- 흔히 보는 방식이라 기록은 간단히만.
- 1단계: 추상화 생성
- 2단계: 추상화 사용
- 3단계: 새로운 구현 추가
- 4단계: 구현 전환
- 5단계: 기존 구현과 추상화 제거

### As a Fallback Mechanism

- 4단계 후 만약 신규 구현 호출이 실패하면,
- 기존 구현을 폴백으로 호출하는 것.

## Pattern: Parallel Run

- 과거와 신규 구현 모두를 호출하고, 결과를 비교하는 것.
- 기능적인 검증뿐만 아니라, 실패율이나 지연 시간 등 비기능적 요구사항 검증까지.
- 가장 먼저 소개하는 사례는 가격 책정 시스템.
- 과거 서비스를 호출하면 과거 디비에 데이터가 쌓이고,
- 동시에 신규 서비스 호출하면 신규 디비에 데이터가 쌓이며,
- 적절한 주기로 두 디비 데이터를 비교해 검증.
- 스파이 사용도 얘기.
- 알림 서비스를 예로 설명.
  - 신규 서비스 추출 후 병행 실행.
  - 이 때, 메일 발송이 두 번 일어나면 안 됨.
  - 따라서, 신규 서비스에서는 스파이를 적용.
  - 발송 호출 받으면 메일 발송 대신 기록만 남기고 끝나는 것.
  - 이 기록은 나중에 확인이나 검증을 위해 활용.
  - 문제 없으면 스파이를 실제 구현으로 대체.
- 카나리 릴리즈와 다크 런칭 얘기도.
- 병행 실행은 카나리가 아니라 다크 런칭의 한 구체화라는.

## Pattern: Decorating Collaborator

- 잘 사용되지는 않아 보임.
- 기존 구현을 고치지 못하는 경우 데코레이터 패턴 활용.
- 여기서는 프록시를 추가하고, 프록시에서 과거 버전과 신규 버전으로의 호출을 적절히 제어하는 것.
- 저자가 경계하는 미들웨어가 똑똑해지는(비대해지는) 문제가 있음.
- 더불어, 프록시에서는 내부 데이터를 잘 알지 못하기에, 신규 서비스 호출을 위한 추가 데이터를 과거 시스템에 질의해야 할 수도(이는 신규 기능 개발이 필요할 수도).

## Pattern: Change Data Capture

- 이 역시 경계해야 할 방법.
- 디비 트리거나, 디비 트랜잭션 로그를 활용.
- 변경을 감지하고 적절한 신규 서비스로 이를 알려주기.
- 데이터를 주기적으로 질의해서 알려줄 수도 있음(batch delta copier).
- 하지만 디비 스키마 등의 제약에 의해 중요한 변경이 유실될 수도.

# CH4. Decomposing the Database

- 마이크로서비스는 정보 은닉 위에 잘 동작함.
- 결국 데이터 저장소와 검색 메커니즘의 캡슐화 필요.
- 데이터도 함께 분리해야 함.
- 하지만 어려움.
- 데이터 전환 중 동기화, 트랜잭션 무결성, 논리적/물리적 스키마 분해, 조인, 지연, ...

## Pattern: The Shared Database

- 커플링을 3개로 나눠 생각할 수 있음.
- 도메인 커플링, 일시적 커플링, 구현 커플링.
- 데이터베이스를 다룰 땐 보통 구현 커플링.
- 서비스들이 동일 데이터베이스를 공유하기 때문.
- 변경 영향이 큼. 즉, 느리고 위험.

### Coping Patterns

- 일단, 각 서비스가 각자의 데이터를 소유하는 게 제일 좋음.
- 불가하다면, 뒤에서 다룰 뷰 패턴을 고려(물론 좋지 않음).
- 또는, 데이터베이스 래핑 서비스 패턴 사용(권장 X).

### Where to Use It

- 저자 생각에는 2가지 경우에 적절.
- 하나는 읽기 전용 정적 참조 데이터인 경우.
- 예컨대 각 나라의 환율 코드 정보, 우편 번호.
- 잘 바뀌지 않으며 어드민 작업으로 변경 관리.
- 나머지 하나는, 데이터베이스를 의도적으로 엔드포인트로 노출한 경우.
- 서비스 인터페이스로서의 데이터베이스 패턴에서 다룰 예정.
