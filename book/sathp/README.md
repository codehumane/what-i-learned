# Software Architecture: The Hard Parts

[Fundamentals of Software Architecture](../fosa/README.md) 책의 심화편이라 함.

## CH3. 아키텍처 모듈성

- 지어낸 이야기 소개로 시작.
- 애플리케이션에 이슈와 장애가 잦고, 이것 저것 땜빵을 하지만, 결국 사업부 폐지 위기.
- 개발자들은 갖은 땜빵질을 해도 문제가 게속되니 결국 시스템을 잘게 쪼개야 한다고 생각.
- 하지만 어떻게 경영진을 설득해야 하나 고민하다 역량있는 선배를 찾아가 조언을 구함.
- 조언자는 애플리케이션 분해가 어떻게 문제 해결로 이어지냐 질문.
- 개발자들은 대답 못함.

> 진로 수정이 필요할 때마다 과감하고 신속하게 결단을 내려 효과적으로 밀어붙이는 능력이야말로 승자와 패자를 가르는 요인 중 하나입니다.

- 요즘 세상에서 기업은 기민해야 함.
- 어느 정도 이상의 아키텍처 민첩성은 필수.
- 유지보수성, 시험성, 배포성, 확장성, 가용성/내고장성이 필요.
- 모듈화가 이를 도움.

### 3.1 모듈화 동인

- 명확한 비즈니스 동인 없이 시스템을 더 잘게 나누면 X.
- 시장 출시 속도와 시장에서의 경쟁 우위 확보여야 함.
- 이를 위한 5가지 핵심 아키텍처 특성은,
- 가용성(내고장성), 확장성, 배포성, 시험성, 유지 보수성.
- 여기서의 모듈화는 분산 아키텍처만을 의미하는 것은 아님.
- modular monolith나 microkernel architecture 같은 모놀리식도 방법.

#### 3.1.1 유지 보수성

- 기능의 추가/변경/삭제에 더해,
- 패치, 프레임워크 업그레이드, 서드파티 업데이트 등의 내부적 변경까지를,
- 얼마나 쉽게 할 수 있는지 나타내는 특성.
- 애플리케이션의 상대적 유지 보수성을 측정하는 5가지 메트릭 언급.
  - 컴포넌트 결합도.
  - 컴포넌트 응집도.
  - 순환 복잡도: 컴포넌트 내부의 전체적인 간접 참조 및 중첩 정도.
  - 컴포넌트 사이즈: 컴포넌트 내부에 구현된 코드의 전체 문장 수.
  - 기술 분할 대 도메인 분할: 컴포넌트를 나누는 기준이 기술적 용도인가 도메인 목적인가.
- 과거의 레이어 아키텍처인 DB > 퍼시스턴스 > 비즈니스 > 프리젠테이션 레이어에서는,
- 고객 위시리스트 항목에 만료일자를 추가하면 변경된 코드가 모든 레이어에 전파.
- 사소한 변경일지라도 여러 팀의 조율(UI 화면 추가, 백엔드 개발, DB 스키마)이 필요할 수도 있음.
- 하지만 모듈화된 아키텍처에서는 그 범위가 도메인 관련부로 국소화(여기서는 UI도 몇 개로 나눠짐).

#### 3.1.2 시험성

- 아키텍처 민첩성을 위한 필수 성분.
- 테스트의 완전성과 용이함을 의미.
- 규모 큰 모놀리식에서 완벽한 회귀 테스트는 상대적으로 어려움.
- 완전히 한다고 하더라도, 사소한 변경으로 수백 수천 개의 단위 테스트는 얼마나 번거로운가?
- 더 작은 배포 단위에서는 변경에 의한 전체 테스트 범위가 줄어들며 완전한 테스팅도 좀 더 수월.
- 목적에 특화된 테스트 스위트 작성도 가능.

#### 3.1.3 배포성

- 배포의 용이함과 빈도, 전체 리스크까지 포괄하는 개념.
- 모놀리식에서는 배포에 여러가지가 섞여,
- 문제를 내포할 가능성도 크고 찾기도 더 어려움.
- 또한 배포 주기가 길어짐.
- 한편, 잘게 분해되더라도 여전히 문제가 사라지지 않을 수 있음.

> 마이크로서비스를 특정 순서를 지켜 완전한 하나의 세트로 배포해야 한다면 다시 모놀리스로 집어 넣고 여러분 자신을 고통의 늪에서 구원하십시오.

#### 3.1.4 확장성

- 유저 부하가 점점 증가해도 시스템이 응답성을 유지하는 능력.
- 부하가 급증하거나 불규칙적으로 요동치는 중에도 응답성을 유지하는 탄력성과도 연관.
- 탄력성에는 MTTS<sup>Mean Time To Startup</sup>(평균적인 기동 시간)가 중요.
- 이런 탄력성을 위해서라면 서비스를 잘게 나누는 것이 유리.
- 배포성과 마찬가지로,
- 단일 비즈니스 트랜잭션에 많은 서비스가 참여해 통신할수록,
- 확장성과 탄력성은 떨어지기 마련.
- 서비스간 동기 통신을 가능한 적게 유지하는 것이 중요.

#### 3.1.5 가용성/내고장성

- 시스템의 특정 부분 장애에도, 나머지는 응답성과 가용성을 유지하는 능력.
- 예를 들어, 결제 처리부의 OOM에도 상품 검색과 주문은 가능해야.
- 일반적으로는 시스템 분리가 도움이 됨.
- 그러나 장애가 난 서비스에 크게 의존하는 서비스는 여전히 내고장성 달성 어려움.
- 그래서 서비스 간 비동기 통신 등을 고려해야 함.

### 3.2 한빛가이버 사가: 비즈니스 케이스 만들기

- 3장 처음에 나온 가상 이야기의 결론편.
- 앞서 나온 개념들을 풀어 쓴 것일 뿐임.
- 악마는 디테일에 있음. 참고만 하자.

## CH4. 아키텍처 분해

- 아키텍처 모듈화는 모놀리식을 나눠야 하는 이유고,
- 아키텍처 분해는 이를 실천하는 방법.
- 이 방법으로 컴포넌트 기반 분해와 전술적 분기 소개.
- 컴포넌트 기반 분해는 컴포넌트를 정제/추출 후 발전시키는 것.
- 전술적 분기는 애플리케이션 그대로 복제한 뒤 필요 없는 부분을 잘라 나가는 것.
- 코드가 진흙탕처럼 뭉쳐 있다면 전술적 분기 사용.
- 아래는 분해 의사결정 트리.

```
모듈화 명분 있는가?
     [예]     [아니오] → 모놀리식 유지     
      ↓                  ↑
코드베이스 분해할 수 있는가? [아니오]
     [예]
      ↓
컴포넌트를 정의할 수 있는가? [아니오] → 컴포넌트 기반 분해
     [예]
      ↓
   전술적 분기
```

### 4.1 분해 가능한 코드베이스인가?

분해 가능한지 판단을 위한 몇 가지 메트릭 소개. [Fundamentals of Software Architecture](../fosa/README.md)에서 다룬 내용이라 나열만 하고 넘어감.

- 구심<sup>afferent</sup>/원심<sup>efferent</sup> 커플링
- 추상도와<sup>abstractness</sup> 불안정도<sup>instability</sup>
- 메인 시퀀스로부터의 거리<sup>distance from the main sequence</sup>

### 4.2 컴포넌트 기반 분해

뒤이은 챕터들에서 자세히 다루므로 간단한 소개는 기록 생략.

### 4.3 전술적 분기

- 진흙잡탕 아키텍처를 구조 조정하는 실용적(?) 방법.
- 소개는 앞서 다뤘으므로 생략.
- 트레이드 오프만 기록.
- 일단 장점.
  - 큰 분석 없이 작업 시작 가능.
  - 개발자 부담이 적음. 필요 없는 코드 삭제에 컴파일/빌드 도움도 받을 수.
- 다음으로 단점.
  - 모놀리스 코드가 여전히 서비스에 상당 부분 남을 수도.
  - 별 노력이 없다면 덩치만 조금 작아지는 수준에 그침.

## CH5. 컴포넌트 기반 분해 패턴

- 컴포넌트 기반 분해는 코드베이스 체계가 어느 정도 잡혀 있고,
- 네임스페이스 별로 그룹핑돼 있는 모놀리스 분해에 유리.
- 여기서는 순서대로 적용하면 좋을 패턴들 소개.

### 5.1 컴포넌트 식별 및 사이징 패턴

- 마이그레이션의 첫 단계.
- Identify and Size Components pattern.
- 컴포넌트를 식별/분류하고 적절하게 사이징하는 것이 목적.
- 일반적으로 덩치가 큰 컴포넌트는 다른 컴포넌트와의 결합도가 높아 분해가 어려움.
- 컴포넌트의 크기 메트릭으로는 컴포넌트 총 문장 수(총 라인 수가 아님) 권장.
- 그리고 컴포넌트의 사이즈 표준 편차로 1-2 범위를 권장.
- 아래와 같은 식.

| 컴포넌트명 | 네임스페이스 | 비중(%) | 문장 수 | 파일 수 |
| -------- | -------- | ------ | ----- | ------ |
| 과금 결제 | ss.billing.payment | 5 | 4,312 | 23 |
| 과금 이력 | ss.billing.history | 4 | 3,209 | 17 |
| 고객 알림 | ss.customer.notification | 2 | 1,433 | 7 |

- 리사이징에는 기능 분해 또는 DDD를 이용해 컴포넌트 안에 서브도메인을 찾기.
- 예를 들어, 책에서의 사례인 고장 티켓 컴포넌트는,
- 전체 코드베이스의 22%를 차지.
- 여기서는 티켓 생성, 티켓 배정, 티켓 전달, 티켓 완료로 나누어,
- 컴포넌트별 코드 비중을 줄이고 더 모듈화 된 애플리케이션을 만들어 볼 수도.

### 5.2 공통 도메인 컴포넌트 수집 패턴

- Gather Common Domain Components pattern
- 공통 도메인 로직을 발굴하고 수집해서 단일 컴포넌트로 중앙화하는 패턴.
- 먼저, 공통 도메인과 공통 인프라 기능을 구별하고 있음.
- 공통 도메인은 비즈니스 처리 로직의 일부로 몇몇 프로세스에서만 공통 사용.
- 한편, 공통 인프라는 로깅, 메트릭 수집, 보안 등 모든 프로세스에 공통 사용.
- 공통 도메인을 식별해서 분리하면, 중복 코드나 서비스를 줄일 수 있음.
- 예를 들어, 티켓 감사, 과금 감사, 설문 감사 네임스페이스가 있다면,
- 감사 기능을 ss.shared나 ss.audit 등으로 공통화해서 추출할 수도.
- 이렇게 추출된 코드들은 별도의 공통 서비스나 공통 라이브러리로 관리.

### 5.3 컴포넌트 눌러 펴기 패턴

- Flatten Components pattern.
- 컴포넌트가 네임스페이스에서 리프 노드에만 있게 하는 것을 가리킴.
- 예컨대, `ss.survey`와 `ss.survey.templates` 네임스페이스 안에 각가 5개와 7개의 파일이 있다면,
- `ss.shared`, `ss.create`, `ss.process`, `ss.templates` 리프 노드에 골고루 이동시킬 수도.
- 참고로 저자는 `ss.survey`에 있는 클래스들을 고아 클래스라 부름.
- 이렇게 하면 구조적으로 완성도가 높다는데, 잘 와닿지는 않음.
- 그래도 앞으로 개발 시 의식적으로 고민해 보자.

### 5.4 컴포넌트 디펜던시 결정 패턴

- 컴포넌트 간 유입/유출 의존성(커플링)을 분석해서,
- 모놀리스를 분해한 후 서비스 의존성 그래프를 미리 확인하는 것.
- 저자는 이 작업의 중요성을 아래와 같이 강조.

> 우리 경험상, 컴포넌트 커플링은 모놀리식 마이그레이션 프로젝트 전체의 성공(그리고 실현 가능성)을 좌우하는 가장 중요한 팩터 중 하나입니다.

- 분해 실현 가능성과 비용 등을 예상하는 데 도움.
- 혹은 미리 디펜던시 리팩토링이 선행되어야 하는지 판단에도 도움.
- 기존 모놀리스가 어떻게 생겼는지 분석도 없이,
- 마이그레이션에 뛰어 드는 경우를 많이 봤다고 함.

### 5.5 컴포넌트 도메인 생성 패턴

> 모놀리식 애플리케이션을 마이크로서비스로 마이그레이션할 경우, 먼저 그 중간 단계인 섭스 기반 아키텍처로 전화해보는 방안을 고려해보세요.

- 연관된 컴포넌트를 논리적으로 그룹핑하는 것.
- 참고로 저자는 네임스페이스를 아래와 같이 구성.
  - `ss.customer.billing.payment.MonthlyBilling`
  - `ss`: 애플리케이션
  - `customer`: 도메인
  - `billing`: 서브도메인
  - `payment`: 컴포넌트
  - `MonthlyBilling`: 결제 컴포넌트에 있는 클래스
- 관련 있는 것들을 모으고, 같은 도메인 네이밍을 갖게 하라는 것.
