# Software Architecture: The Hard Parts

[Fundamentals of Software Architecture](../fosa/README.md) 책의 심화편이라 함.

## CH3. 아키텍처 모듈성

- 지어낸 이야기 소개로 시작.
- 애플리케이션에 이슈와 장애가 잦고, 이것 저것 땜빵을 하지만, 결국 사업부 폐지 위기.
- 개발자들은 갖은 땜빵질을 해도 문제가 게속되니 결국 시스템을 잘게 쪼개야 한다고 생각.
- 하지만 어떻게 경영진을 설득해야 하나 고민하다 역량있는 선배를 찾아가 조언을 구함.
- 조언자는 애플리케이션 분해가 어떻게 문제 해결로 이어지냐 질문.
- 개발자들은 대답 못함.

> 진로 수정이 필요할 때마다 과감하고 신속하게 결단을 내려 효과적으로 밀어붙이는 능력이야말로 승자와 패자를 가르는 요인 중 하나입니다.

- 요즘 세상에서 기업은 기민해야 함.
- 어느 정도 이상의 아키텍처 민첩성은 필수.
- 유지보수성, 시험성, 배포성, 확장성, 가용성/내고장성이 필요.
- 모듈화가 이를 도움.

### 3.1 모듈화 동인

- 명확한 비즈니스 동인 없이 시스템을 더 잘게 나누면 X.
- 시장 출시 속도와 시장에서의 경쟁 우위 확보여야 함.
- 이를 위한 5가지 핵심 아키텍처 특성은,
- 가용성(내고장성), 확장성, 배포성, 시험성, 유지 보수성.
- 여기서의 모듈화는 분산 아키텍처만을 의미하는 것은 아님.
- modular monolith나 microkernel architecture 같은 모놀리식도 방법.

#### 3.1.1 유지 보수성

- 기능의 추가/변경/삭제에 더해,
- 패치, 프레임워크 업그레이드, 서드파티 업데이트 등의 내부적 변경까지를,
- 얼마나 쉽게 할 수 있는지 나타내는 특성.
- 애플리케이션의 상대적 유지 보수성을 측정하는 5가지 메트릭 언급.
  - 컴포넌트 결합도.
  - 컴포넌트 응집도.
  - 순환 복잡도: 컴포넌트 내부의 전체적인 간접 참조 및 중첩 정도.
  - 컴포넌트 사이즈: 컴포넌트 내부에 구현된 코드의 전체 문장 수.
  - 기술 분할 대 도메인 분할: 컴포넌트를 나누는 기준이 기술적 용도인가 도메인 목적인가.
- 과거의 레이어 아키텍처인 DB > 퍼시스턴스 > 비즈니스 > 프리젠테이션 레이어에서는,
- 고객 위시리스트 항목에 만료일자를 추가하면 변경된 코드가 모든 레이어에 전파.
- 사소한 변경일지라도 여러 팀의 조율(UI 화면 추가, 백엔드 개발, DB 스키마)이 필요할 수도 있음.
- 하지만 모듈화된 아키텍처에서는 그 범위가 도메인 관련부로 국소화(여기서는 UI도 몇 개로 나눠짐).

#### 3.1.2 시험성

- 아키텍처 민첩성을 위한 필수 성분.
- 테스트의 완전성과 용이함을 의미.
- 규모 큰 모놀리식에서 완벽한 회귀 테스트는 상대적으로 어려움.
- 완전히 한다고 하더라도, 사소한 변경으로 수백 수천 개의 단위 테스트는 얼마나 번거로운가?
- 더 작은 배포 단위에서는 변경에 의한 전체 테스트 범위가 줄어들며 완전한 테스팅도 좀 더 수월.
- 목적에 특화된 테스트 스위트 작성도 가능.

#### 3.1.3 배포성

- 배포의 용이함과 빈도, 전체 리스크까지 포괄하는 개념.
- 모놀리식에서는 배포에 여러가지가 섞여,
- 문제를 내포할 가능성도 크고 찾기도 더 어려움.
- 또한 배포 주기가 길어짐.
- 한편, 잘게 분해되더라도 여전히 문제가 사라지지 않을 수 있음.

> 마이크로서비스를 특정 순서를 지켜 완전한 하나의 세트로 배포해야 한다면 다시 모놀리스로 집어 넣고 여러분 자신을 고통의 늪에서 구원하십시오.

#### 3.1.4 확장성

- 유저 부하가 점점 증가해도 시스템이 응답성을 유지하는 능력.
- 부하가 급증하거나 불규칙적으로 요동치는 중에도 응답성을 유지하는 탄력성과도 연관.
- 탄력성에는 MTTS<sup>Mean Time To Startup</sup>(평균적인 기동 시간)가 중요.
- 이런 탄력성을 위해서라면 서비스를 잘게 나누는 것이 유리.
- 배포성과 마찬가지로,
- 단일 비즈니스 트랜잭션에 많은 서비스가 참여해 통신할수록,
- 확장성과 탄력성은 떨어지기 마련.
- 서비스간 동기 통신을 가능한 적게 유지하는 것이 중요.

#### 3.1.5 가용성/내고장성

- 시스템의 특정 부분 장애에도, 나머지는 응답성과 가용성을 유지하는 능력.
- 예를 들어, 결제 처리부의 OOM에도 상품 검색과 주문은 가능해야.
- 일반적으로는 시스템 분리가 도움이 됨.
- 그러나 장애가 난 서비스에 크게 의존하는 서비스는 여전히 내고장성 달성 어려움.
- 그래서 서비스 간 비동기 통신 등을 고려해야 함.

### 3.2 한빛가이버 사가: 비즈니스 케이스 만들기

- 3장 처음에 나온 가상 이야기의 결론편.
- 앞서 나온 개념들을 풀어 쓴 것일 뿐임.
- 악마는 디테일에 있음. 참고만 하자.

## CH4. 아키텍처 분해

- 아키텍처 모듈화는 모놀리식을 나눠야 하는 이유고,
- 아키텍처 분해는 이를 실천하는 방법.
- 이 방법으로 컴포넌트 기반 분해와 전술적 분기 소개.
- 컴포넌트 기반 분해는 컴포넌트를 정제/추출 후 발전시키는 것.
- 전술적 분기는 애플리케이션 그대로 복제한 뒤 필요 없는 부분을 잘라 나가는 것.
- 코드가 진흙탕처럼 뭉쳐 있다면 전술적 분기 사용.
- 아래는 분해 의사결정 트리.

```
모듈화 명분 있는가?
     [예]     [아니오] → 모놀리식 유지     
      ↓                  ↑
코드베이스 분해할 수 있는가? [아니오]
     [예]
      ↓
컴포넌트를 정의할 수 있는가? [아니오] → 컴포넌트 기반 분해
     [예]
      ↓
   전술적 분기
```

### 4.1 분해 가능한 코드베이스인가?

분해 가능한지 판단을 위한 몇 가지 메트릭 소개. [Fundamentals of Software Architecture](../fosa/README.md)에서 다룬 내용이라 나열만 하고 넘어감.

- 구심<sup>afferent</sup>/원심<sup>efferent</sup> 커플링
- 추상도와<sup>abstractness</sup> 불안정도<sup>instability</sup>
- 메인 시퀀스로부터의 거리<sup>distance from the main sequence</sup>

### 4.2 컴포넌트 기반 분해

뒤이은 챕터들에서 자세히 다루므로 간단한 소개는 기록 생략.

### 4.3 전술적 분기

- 진흙잡탕 아키텍처를 구조 조정하는 실용적(?) 방법.
- 소개는 앞서 다뤘으므로 생략.
- 트레이드 오프만 기록.
- 일단 장점.
  - 큰 분석 없이 작업 시작 가능.
  - 개발자 부담이 적음. 필요 없는 코드 삭제에 컴파일/빌드 도움도 받을 수.
- 다음으로 단점.
  - 모놀리스 코드가 여전히 서비스에 상당 부분 남을 수도.
  - 별 노력이 없다면 덩치만 조금 작아지는 수준에 그침.

## CH5. 컴포넌트 기반 분해 패턴

- 컴포넌트 기반 분해는 코드베이스 체계가 어느 정도 잡혀 있고,
- 네임스페이스 별로 그룹핑돼 있는 모놀리스 분해에 유리.
- 여기서는 순서대로 적용하면 좋을 패턴들 소개.

### 5.1 컴포넌트 식별 및 사이징 패턴

- 마이그레이션의 첫 단계.
- Identify and Size Components pattern.
- 컴포넌트를 식별/분류하고 적절하게 사이징하는 것이 목적.
- 일반적으로 덩치가 큰 컴포넌트는 다른 컴포넌트와의 결합도가 높아 분해가 어려움.
- 컴포넌트의 크기 메트릭으로는 컴포넌트 총 문장 수(총 라인 수가 아님) 권장.
- 그리고 컴포넌트의 사이즈 표준 편차로 1-2 범위를 권장.
- 아래와 같은 식.

| 컴포넌트명 | 네임스페이스 | 비중(%) | 문장 수 | 파일 수 |
| -------- | -------- | ------ | ----- | ------ |
| 과금 결제 | ss.billing.payment | 5 | 4,312 | 23 |
| 과금 이력 | ss.billing.history | 4 | 3,209 | 17 |
| 고객 알림 | ss.customer.notification | 2 | 1,433 | 7 |

- 리사이징에는 기능 분해 또는 DDD를 이용해 컴포넌트 안에 서브도메인을 찾기.
- 예를 들어, 책에서의 사례인 고장 티켓 컴포넌트는,
- 전체 코드베이스의 22%를 차지.
- 여기서는 티켓 생성, 티켓 배정, 티켓 전달, 티켓 완료로 나누어,
- 컴포넌트별 코드 비중을 줄이고 더 모듈화 된 애플리케이션을 만들어 볼 수도.

### 5.2 공통 도메인 컴포넌트 수집 패턴

- Gather Common Domain Components pattern
- 공통 도메인 로직을 발굴하고 수집해서 단일 컴포넌트로 중앙화하는 패턴.
- 먼저, 공통 도메인과 공통 인프라 기능을 구별하고 있음.
- 공통 도메인은 비즈니스 처리 로직의 일부로 몇몇 프로세스에서만 공통 사용.
- 한편, 공통 인프라는 로깅, 메트릭 수집, 보안 등 모든 프로세스에 공통 사용.
- 공통 도메인을 식별해서 분리하면, 중복 코드나 서비스를 줄일 수 있음.
- 예를 들어, 티켓 감사, 과금 감사, 설문 감사 네임스페이스가 있다면,
- 감사 기능을 ss.shared나 ss.audit 등으로 공통화해서 추출할 수도.
- 이렇게 추출된 코드들은 별도의 공통 서비스나 공통 라이브러리로 관리.

### 5.3 컴포넌트 눌러 펴기 패턴

- Flatten Components pattern.
- 컴포넌트가 네임스페이스에서 리프 노드에만 있게 하는 것을 가리킴.
- 예컨대, `ss.survey`와 `ss.survey.templates` 네임스페이스 안에 각가 5개와 7개의 파일이 있다면,
- `ss.shared`, `ss.create`, `ss.process`, `ss.templates` 리프 노드에 골고루 이동시킬 수도.
- 참고로 저자는 `ss.survey`에 있는 클래스들을 고아 클래스라 부름.
- 이렇게 하면 구조적으로 완성도가 높다는데, 잘 와닿지는 않음.
- 그래도 앞으로 개발 시 의식적으로 고민해 보자.

### 5.4 컴포넌트 디펜던시 결정 패턴

- 컴포넌트 간 유입/유출 의존성(커플링)을 분석해서,
- 모놀리스를 분해한 후 서비스 의존성 그래프를 미리 확인하는 것.
- 저자는 이 작업의 중요성을 아래와 같이 강조.

> 우리 경험상, 컴포넌트 커플링은 모놀리식 마이그레이션 프로젝트 전체의 성공(그리고 실현 가능성)을 좌우하는 가장 중요한 팩터 중 하나입니다.

- 분해 실현 가능성과 비용 등을 예상하는 데 도움.
- 혹은 미리 디펜던시 리팩토링이 선행되어야 하는지 판단에도 도움.
- 기존 모놀리스가 어떻게 생겼는지 분석도 없이,
- 마이그레이션에 뛰어 드는 경우를 많이 봤다고 함.

### 5.5 컴포넌트 도메인 생성 패턴

> 모놀리식 애플리케이션을 마이크로서비스로 마이그레이션할 경우, 먼저 그 중간 단계인 섭스 기반 아키텍처로 전화해보는 방안을 고려해보세요.

- 연관된 컴포넌트를 논리적으로 그룹핑하는 것.
- 참고로 저자는 네임스페이스를 아래와 같이 구성.
  - `ss.customer.billing.payment.MonthlyBilling`
  - `ss`: 애플리케이션
  - `customer`: 도메인
  - `billing`: 서브도메인
  - `payment`: 컴포넌트
  - `MonthlyBilling`: 결제 컴포넌트에 있는 클래스
- 관련 있는 것들을 모으고, 같은 도메인 네이밍을 갖게 하라는 것.

### 5.6 도메인 서비스 생성 패턴

- 앞서 만든 도메인을 서비스로 옮기는 것.
- 별로 필요하지 않은 경우에도 너무 잘게 나누면,
- 분산 트랜잭션, 데이터 분해, 운영 자동화, 컨테이너화 등의 비용이 장점을 상쇄하기도.
- 그리고 너무 서둘러 진행하면 나누고 나서 뒤이어 진행해야 하는 일들이 너무 많아짐.
- 그래서 모든 컴포넌트 도메인을 식별하고 리팩토링을 마친 뒤에 진행하라고.

## CH6. 운영 데이터 분리

- 데이터베이스 분리가 애플리케이션에 비해 더 어려움을 강조.
- 따라서, 데이터 분해의 이유가 더 중요할 수도 있음.
- 뒤이어 분해의 이점, 그리고 방법들을 다룸.

### 6.1 데이터 분해인

- 데이터 분해인<sup>data disintegrator</sup>은 데이터를 분해하게 만드는 동인을 가리킴.
- 한편, 데이터를 함께 보관하게 만드는 동인은 데이터 통합인<sup>data integrator</sup>.
- 이 둘 간의 균형을 맞추고 트레이드 오프 분석 필요.

#### 6.1.1 데이터 분해인

데이터 분해인을 6가지로 정리.

- 변경 관리
- 커넥션 관리
- 확장성
- 내고장성
- 아키텍처 퀀텀
- 데이터베이스 유형 최적화

##### 변경 관리

- 테이블 스키마의 변경은 영향이 커서 breaking change라 부르기도.
- 만약, 400개가 넘는 서비스가 같은 데이터베이스를 바라본다면?
- 400개가 넘는 서비스에서 영향은 없는지 확인해야 하고,
- 영향이 있다면 스케쥴 조율, 코드 변경, 테스트, 배포 등이 모두 필요.
- 하지만 한 데이터베이스는 한 서비스만 의존하다면,
- 데이터베이스의 세부 사항이 서비스로 추상화 되는 것이고,
- 한 서비스만 변경해도 되는 일이 늘어남.

##### 커넥션 관리

- DB를 공유하는 서비스가 늘어날수록,
- DB 입장에서 사용 가능한 커넥션 수 소진.
- 분해 등을 고려하지 않으면 커넥션 대기, 타임아웃 등 발생.
- 참고로, 저자는 서비스들의 DB 커넥션을 처음에는 균등 분배로 시작하라고.
- 그리고 서비스마다 동시 커넥션 사용량 측정하는 피트니스 함수 작성 권장.
- 이를 바탕으로 적절한 균형을 맞춰가는 것.

##### 확장성

- 커넥션 관리와 비슷한 이야기.
- 서비스들의 확장성을 위해서,
- DB가 분해 되어 있는 것이 유리하다.

##### 내고장성

- DB가 분해 되어 있다면,
- 특정 DB 장애의 국소화 가능성이 높아짐.

##### 아키텍처 퀀텀

- 2장에서 다뤘던 아키텍처 퀀텀의 DB 관점 이야기.
- 그런데 이게 분해 동인인지에 대해서는 의문.

##### 데이터베이스 타입 최적화

- 데이터 종류에 따라 처리 방식이 다름.
- 최상의 결과를 위해서는 최적화 된 DB 사용이 필요할 수도.
- 이 역시 데이터 분해 동인 중 하나.

#### 6.1.2 데이터 통합인

통합인으로 제시하는 것은 2개.

- 데이터 관계
- 데이터베이스 트랜잭션

##### 데이터 관계

- 외래 키, 트리거, 뷰, 저장 프로시저 등은,
- 데이터 일관성과 무결성 지원을 위한 물리적 아티팩트.
- 데이터 분해를 하게 되면 외래 키 등의 사용은 어려움.
- 어느 쪽이 더 가치있는지 따져야 함.

##### 데이터베이스 트랜잭션

- DB가 다르면 DB에서 지원하는 트랜잭션 사용 불가.
- 일시적이든 장기적이든 일관성, 무결성 이슈가 발생할 수 밖에.
- 이 역시 고려해야 하는 트레이드 오프.

### 6.2 모놀리식 데이터 분해

데이터를 분해하는 5단계 프로세스 소개.

1. DB 분석 및 데이터 도메인 생성
2. 데이터 도메인에 테이블 할당, 이동
3. 데이터 도메인마다 별도의 DB 커넥션 생성
4. 개별 DB 서버로 스키마 이전
5. 독립된 DB 서버로 전환

**1단계 - DB 분석 및 데이터 도메인 생성**

- DB 내에서 도메인 그룹을 식별하기.
- 테이블 별로 후보 도메인을 적다 보면 그룹핑이 됨.

**2단계 - 데이터 도메인에 테이블 할당, 이동**

- 분류된 도메인 별로 테이블을 스키마로 할당.
- 테이블 간 커플링이 크다면 이 도메인들은 통합.

**3단계 - 데이터 도메인마다 별도의 DB 커넥션 생성**

- 애플리케이션은 이제 분리된 스키마로 커넥션을 분리.
- 여기가 어렵다고 함(당연).
- 이렇게 되면 도메인 별로 독립적 스키마 변경 가능.
- 적절한 DB 기술이나 구조 사용도 가능.
- 하지만 대량 데이터 처리 시 성능 이슈 발생할 수도.
- 데이터 참조 무결성 낮아질 수도.
- 프로시저 등의 DB 코드는 애플리케이션 코드로 변환해야.

**4단계 - 개별 DB 서버로 스키마 이전**

- 이제 스키마를 개별 DB로 이전.
- 확장성, 내고장성, 성능적 이점을 위함.
- 이게 3단계와의 의미적 차이.

**5단계 - 독립된 DB 서버로 전환**

- 애플리케이션에서 DB 서버 자체도 구분해서 접근.
- 3단계에서는 스키마만 다르게 커넥션 맺었음에 유의.

### 6.3 데이터베이스 타입 선택

각 DB의 장단점 소개. 목록만 나열하고 정리는 끝.

- 관계형 데이터베이스
- 키-값 데이터베이스
- 문서형 데이터베이스
- 컬럼형 데이터베이스
- 그래프 데이터베이스
- NewSQL 데이터베이스
- 클라우드 네이티브 데이터베이스
- 시계열 데이터베이스

## CH7. 서비스 세분도

- 모듈화, 세분도의 정의 소개로 시작.
- 모듈화: 사용상의 유연성과 다양성을 위해 표준화된 단위 또는 치수로 만듦.
- 세분도: 더 큰 단위를 형성하는 많은 입자 중 하나로 구성하거나, 그렇게 보임.
- 모듈화는 시스템을 별도의 파트로 분해하는 것과 관련.
- 세분도는 그렇게 나눠진 개별 파트의 사이즈에 관한 것.
- 세분도 측정을 위한 메트릭으로 문장 수, 퍼블릭 인터페이스나 기능 수를 제시.
- 적절한 세분도를 위해서는 세분도 분해인과 통합인 사이에서 균형점을 찾는 것.

### 7.1 세분도 분해인

- 어느 경우에 서비스를 좀 더 잘게 나눠야 하는가.
- 여기서는 총 6가지 분해인 소개.
- 한 가지 이유로 분해는 잘 안 함.
- 보통은 복합적 이유로 분해.

#### 7.1.1 서비스의 범위와 기능

- 분해의 최초, 그리고 일반적인 동인.
- 먼저, 응집도. 기능이 서로 얼마나 어떻게 연관 되었는가.
- 다음으로, 컴포넌트의 크기 고려. 총문장 수나 서비스 진입점 수 등을 이용.
- 단일 책임 원칙도 활용해 볼 수 있음.
- 그러나, 이 동인만으로 분해를 고려하지 말라고 함.
- 자주 저지르는 실수라고.
- 예컨대, 알림 서비스가 있고, 이 내부에 SMS/이메일/우편 서비스가 있다고 가정.
- 언뜻 서로 다른 책임을 갖고 있어 보이지만 책임이란 것은 주관적.
- 반드시 다른 동인들도 함께 고려할 것을 권장.
- 그런데 저자가 책임을 잘못 이해하고 있어 보임.
- 뒤이어 다루는 코드 변동성과 신장성을,
- 별도의 동인으로 구분하는 것으로 보아 그러함.

#### 7.1.2 코드 변동성

- 앞서 소개한 알림 사례를 다시 보자.
- 알림 서비스 내 세부 서비스들이 아래 표와 같이 변경 빈도가 다르다고 가정.
- 우편물 서비스는 우편 번호가 자주 바뀌어서 그럴 수 있다 하는데 설득력 떨어짐.
- 우편 번호를 동적으로 바꿀 수 있게 하면 될 것으로 보이기에.
- 아무튼, 하나의 변경으로 전체 배포가 일어나면 비용.
- 빌드 시간, 배포 시점의 부하, 롤백 영향 등.
- 요컨대, 자주 변경되는 곳은 분해의 적절 후보.

| 서비스 | 변동 주기 |
| ---- | ------- |
| SMS  | 6개월에 1번 |
| 이메일 | 6개월에 1번 |
| 우편  | 매주 1번 |

#### 7.1.3 확장성/처리량

- 알림 서비스 처리량이 아래 표와 같다고 해보자.
- 분해 시 서비스 별로 다양한 처리량 목표 달성 가능.
- 그러나 예시가 적절치는 않아 보이고,
- 좀 더 적합한 사례를 제시하는 게 좋아 보임.
- 단순히 처리량 다르다고 분해는 우려스럽기 때문.
- 어쨋든 하나의 고려 요소.

| 서비스 | ops |
| ---- | ------- |
| SMS  | 220,000 |
| 이메일 | 500 |
| 우편  | 1 |

#### 7.1.4 내고장성

- 장애 발생의 국소화를 위해,
- 덜 안정적인 서비스 분해가 도움이 됨.
- 여기서 인상 깊었던 한 가지는 네이밍의 어려움을 서비스 분해로 연결시킨 것.
- 이메일 서비스가 자주 실패하니 따로 서비스로 분해하고,
- 이제 나머지 안정적인 SMS와 우편 서비스를 하나로 두려는데,
- 이 나머지 서비스 이름을 정하는 것이 다소 난해.
- SMS-우편 서비스도, 기타 알림 서비스라는 이름도 이상.
- 그래서 이를 또 나눠 보는 것을 제안함.
- 하지만 개인적으로 네이밍이 분해 동인 수준은 아닌 듯.
- 분해 고민의 신호 정도로 받아들이는 것은 나쁘지 않음.

#### 7.1.5 보안

- 별다른 내용 없음.
- 기록 생략.

#### 7.1.6 신장성

- 신장성이 뭔가 했더니 extensibility.
- 이는 코드 변동성과 맥락을 같이함.
- 다만 변경 중에서도 기능의 확장 측면을 강조한 것.

### 7.2 세분도 통합인

- 어떤 경우에 다시 합쳐야 하는지 이야기.
- 총 4가지 분해인 소개.

#### 7.2.1 데이터베이스 트랜잭션

- 잘게 나누면 DB에서 지원하는 ACID 트랜잭션 사용 불가.
- 이로 인해 무결성이 깨지거나, 재처리나 복원 등의 복잡한 절차를 마련해야 함.
- 책에서는 예시로, 보안 이슈로 분리했던 비밀번호 서비스를 다시 프로필 서비스로 합치는 것 소개.

#### 7.2.2 워크플로와 코레오그래피

- 워크플로, 코레오그래피 발생은 통합인 중 하나.
- 서비스 잘게 나누면 점점 서비스 간 통신이 늘어나게 됨.
- 내고장성을 이유로 분해했더니, 오히려 위 이유로 내고장성이 줄어듦.
- 물론 결과적 일관성 등으로 이를 줄여볼 수는 있으나, 복잡성은 오히려 늘어나기만.
- 서비스 간 통신 응답 지연은 덤.
- 그래서 서비스 간 요청 수, 그리고 그 요청의 중요성 고려하라고 함.
- 예컨대 요청의 30%만 워크플로가 필요하고 나머지 70%는 원자적 처리가 가능하다면 분해.
- 하지만 이 30%의 요청이 매우 빠른 응답이 필요한 중요 요청이라면 합치는 것을 고려.
- 트랜잭션 얘기도 다시 언급. 분산 트랜잭션이 깨지면, 롤백이나 재시작을 위해, 어디서 중단 됐는지 상태 표시 필요.
- 저자는 이게 정말 지저분한 상황이라고 표현.

#### 7.2.3 공유 코드

- 모든 공유 코드가 서비스 통합인은 아님.
- 여기서는 공유 코드가 통합인이 되는 3가지 가이드라인 제시.
- 첫 번째로, 공유 도메인 기능이 공통 코드가 되는 경우.
- 예컨대, 프로필 등의 고객 관련 기능 코드가 전체의 40% 이상이라면 통합인.
- 그리고 이 공통 도메인 기능이 자주 변경된다면 더더욱.
- 두 번째로, 공유 코드의 잦은 변경도 통합인.
- 물론, 버저닝을 통해 공유 코드 변경 영향 줄일 수 있음.
- 그러나 결국 최신 버전을 적용해야 함.
- 세 번째로, 결함은 버저닝이 안 되는 것도 고려해야 함.

#### 7.2.4 데이터 관계

- 길게 설명하고 있긴 한데,
- 결국 테이블 관계의 구조 조정이 현실적으로 어려운 경우를 가리킴.

### 7.3 적정 균형점 찾기

- 일단 아래 표로 분해인과 통합인을 다시 정리.

| 분해인 | 적용 이유 |
| ---- | ------- |
| 서비스 범위 | 응집도가 강한 단일 목적의 서비스 |
| 코드 변동성 | 민첩성(테스트 범위와 배포 리스크 줄어듦) |
| 확장성 | 비용 절감, 빠른 응답성 |
| 내고장성 | 전체 가동 시간 개선 |
| 보안 액세스 | 어떤 기능의 보안 액세스 강화 |
| 신장성 | 민첩성(새로운 기능을 추가하기 쉽다) |

| 통합인 | 적용 이유 |
| ---- | ------- |
| DB 트랜잭션 | 데이터 무결성 및 일관성 |
| 워크플로 | 내고장성, 성능, 신뢰성 |
| 공유 코드 | 유지 보수성 |
| 데이터 관계 | 데이터 무결성 및 정확성 |

- 이를 기반으로 이해 관계자들에게 선택지를 제공하고,
- 우선순위에 따라 분해와 통합 여부,
- 그리고 그 시기 등을 결정하는 예시 3가지 들고 있음.

## CH8. 재사용 패턴

- 분산 아키텍처에서는 DRY 대신,
- WET(Write Each Time) 또는 Write every time or Write everything twice를 주장하기도.
- 분산 아키텍처에서 코드 재사용을 줄여야 하지만,
- 코드 재사용은 엄연한 현실.
- 코드 재사용을 위한 몇 가지 기법 소개.

### 8.1 코드 복제

- MSA 초창기에는 코드 복제를 옹호하는 사람이 많았다고 함.
- 하지만, 코드에서 버그가 발견되거나 중요한 변경 필요 등에 한해 조심스럽게 사용하라고.
- 복제 코드가 담긴 전체 서비스를 업데이트하는 것은 매우 어렵고 시간이 오래 걸리기 때문.
- 물론, 별다른 기능을 하지 않고 정적이라면 코드 중복은 괜찮음.
- 애너테이션, 애트리뷰트, 단순 공통 유틸리티 등.
- 코드 복제 기법의 트레이드오프는 아래와 같이 정리.

| 장점 | 단점 |
| --- | --- |
| 경계 컨텍스트가 지켜짐 | 변경한 코드를 반영하기 어려움 |
| 코드 공유가 안 됨 | 서비스 간 코드 불일치 |
|  | 서비스 간 버저닝이 지원되지 않음 |

### 8.2 공유 라이브러리

- 코드 공유의 가장 일반적인 방법 중 하나.
- 단순하고 직관적이나 나름 복잡.
- 관건은 세분도와 버저닝.

#### 8.2.1 디펜던시 관리와 변경 관리

- 단위가 너무 크면 변경에 의한 테스트 범위가 큼.
- 반면, 너무 잘게 나뉘면 의존성 관리가 어려움.
- 책에서는 가능한 작은 단위, 즉 기능별로 분리된 라이브러리를 만들어, 의존성 관리보다 변경 관리에 좀 더 신경쓰라 함.

#### 8.2.2 버저닝 전략

- 무조건 버저닝해야 한다고.
- 하위호환성 보장되고, 높은 수준의 민첩성으로 신속한 변경 대응 가능.
- 하지만 변경을 통지하는 일은 어렵다고 함. 어떻게 알릴 수 있으며, 조율은 어떻게 할지 등.
- 과거 버전을 더 이상 지원하지 않는 일도 복잡.
- 참고로 버전을 LATEST으로 지정해서 사용하지 말라는 조언도.
- 아래는 트레이드 오프.

| 장점 | 단점 |
| --- | --- |
| 버전 변경이 가능 | 의존성 관리가 어려울 수도 |
| 공유 코드가 컴파일 기반이므로 런타임 에러 적음 | 잡다한 코드베이스가 뒤엉켜 코드가 중복 |
| 공유 코드 변경에 민첩하게 대응 | 버전 구식화가 어려울 수도 |
| | 버전 통지가 어려울 수도 |

#### 8.2.3 어떤 경우에 사용하는가?

- 공유 코드 변경 빈도가 낮은, 안정된 환경에 적합.
- 버저닝은 공유 코드 변경 시 높은 수준의 민첩성 제공.
- 보통 컴파일 타임에 서비스 바인딩 되므로,
- 성능, 확장성, 내고장성 등의 운영 특성에 영향이 적음.
- 버저닝 덕분에 공통 코드 변경이 다른 서비스에 바로 영향을 주지 않아 안정적.

### 8.3 공유 서비스

- 공유 라이브러리의 일반적인 대안.
- 공유 기능 변경이 필요하면, 별도 배포된 서비스만 수정해서 배포하면 되는 것이 이점.
- 하지만 변경 리스크, 성능, 확장성, 내고장성 등의 트레이드오프 따름.

#### 8.3.1 변경 리스크

- 공유 라이브러리의 컴파일 타임 변경에 비해,
- 런타임 변경이므로 위험이 더 큼.
- 여기에 의존하는 모든 서비스에 다 영향을 줄 수도.
- 그래서 버저닝 중요.
- 하지만 버저닝은 복잡성을 나음.
- URL이나 헤더 등이 달라져야 버저닝이 가능한데,
- 새로운 버전이 나왔을 때 의존 서비스들 변경 불가피.
- REST API 이외에 gRPC 등 프로토콜이 많을 수록 더 복잡.

#### 8.3.2 성능

- 공유 서비스는 네트워크 레이턴시 발생.
- 따라서 성능이 상대적으로 단점.
- gRPC는 이를 완화하는 데 약간의 도움.
- 혹은 correlation id를 이용한 메시징 기법을 활용할 수도.

#### 8.3.3 확장성

- 공유 서비스를 필요에 맞게 사이징해야 함.
- 공유 라이브러리에서는 고려 안 해도 되던 문제.

#### 8.3.4 내고장성

- 공유 서비스가 다운되면 의존 서비스들에 영향.
- 이 역시 공유 라이브러리에서는 고려 안 해도 되는 문제.

#### 8.3.5 어떤 경우에 사용하는가?

- 여러 언어와 플랫폼이 공존할 때 고려해 볼 만.
- 아래 트레이드오프 함께 참고.

| 장점 | 단점 |
| --- | --- |
| 코드 변동성이 높을 때 유리 | 버저닝에 의한 복잡성 증가 |
| 코드 중복 적음 | 레이턴시로 인한 성능 저하 |
| 경계 컨텍스트가 지켜짐 | 내고장성, 가용성 이슈 생김 |
| 정적 코드 공유 없음 | 확장성, 처리량 이슈 생김 |
| | 런타임 변경에 의한 리스크 증가 |

### 8.4 사이드카와 서비스 메시

- 기능을 중복시키는 게 좋을까, 아니면 결합시킬까?
- MSA에서는 보통 중복을 포용.
- 하지만 결합이 유리할 때도.
- 예를 들면, 모니터링, 로깅, 인증/인가, 회로 차단기.
- 이런 의존성들도 알아서 하는 것은 무질서 방치.
- 이런 문제를 해결하는 해법 중 하나가 사이드카.
- 헥사고날 아키텍처 패턴에 기반한 것이라 해서 의외.
- 사이드카에 대한 자세한 설명은 생략.
- 이는 orthogonal reuse patteren이라 함.
- 도메인 동작과 독립적이며, 이렇게 서로 다른 2가지 목적이 서로 교차해야 좋은.
- 사이드카는 이를 돕는, 그리고 횡단 관심사를 일관 되게 격리시켜 주는 도구.

#### 8.4.1 어떤 경우에 사용하는가?

- 분산 아키텍처에서 횡단 관심사를 고루 퍼뜨리는 깔끔한 방법.
- 데코레이터 패턴과 유사.
- 아래는 장단점.

| 장점 | 단점 |
| --- | --- |
| 커플링을 일관된 방법으로 분리/격리 | 플랫폼 당 하나의 사이드카 구현해야 함 |
| 일관된 인프라 조정이 가능 | 사이드카 컴포넌트가 커지면 복잡해질 수 있음 |
| 팀별 오너십, 중앙 집중식, 혹은 적절한 조합 가능 | |

### 8.6 코드 재사용: 어떤 경우에 가치 있는가?

- 재사용은 가장 남용되는 추상화 중 하나.
- 많은 사람들이 트레이드오프를 충분히 고려하지 못하고 재사용을 권장해 버림.
- 가상인지 진짜인지 모를 대형 보험 회사 이야기.
  - 각 부서마다 관심 있는 고객 정보가 다른데,
  - 이 고객 정보가 공통적이라 판단하고,
  - 전사 고객 정보를 한 서비스로 통합.
  - 언뜻 보면 합리적이나 2가지 이유로 실패라고.
  - 하나는, 고객과 같이 핵심 엔티티의 모든 정보를 한 곳에 두면,
  - 모든 도메인과 시나리오를 처리하게 되고 그만큼 복잡해짐.
  - 둘째로, 아키텍처가 취약해짐. SPOF.
- 하지만, 운영체제나 오픈소스 프레임워크 또는 라이브러리처럼 성공적인 재사용도 있음.
- 어떤 차이일까?
- 저자는 '낮은 변경 빈도'가 답이라고 함.

> 재사용은 추상화를 통해 발생하지만, 변경 빈도가 낮을 때 가치가 있습니다.

## CH9. 데이터 오너십과 분산 트랜잭션

- 어떤 서비스가 무슨 데이터를 소유하는지,
- 분산 트랜잭션은 어떻게 관리할지,
- 서비스가 필요로 하는 데이터는 어떻게 가져올지 등,
- 분산 데이터 통합을 위한 오너십과 트랜잭션 고민이 필요.

### 9.1 데이터 오너십 할당

- 서비스에 데이터 오너십 할당은 쉽지 않다고 함. 또 다른 SATHP.
- 일반적으로, 테이블에 데이터를 쓰는 서비스가 테이블 소유.
- 그러나, 단독 오너십 말고 공동 오너십일 때 문제 복잡.
- 아래 예시로 세 가지 오너십을 뒤 이어 소개.

| 서비스 | 의존 테이블 |
| ---- | --------- |
| 위시리스트 | Audit, Whishlist |
| 카탈로그 | Audit, Product |
| 재고 | Audit, Product |

### 9.2 단독 오너십

- single ownership
- 오직 한 서비스만 테이블에 데이터를 쓰는 것.
- 다른 오너십에 비해 간단하고 직관적.
- 예시에서는 위시리스트 서비스가 Whishlist를 갖는 것.
- Whishlist 테이블이 위시리스트 서비스 경계 내에 위치.
- 어찌 보면 당연.
- 가장 단순하므로, 복잡한 오너십 다루기에 앞서 먼저 정의하는 것을 권장.

### 9.3 공통 오너십

- common ownership.
- 대부분의 서비스가 동일 테이블에 데이터를 쓰는 것.
- Audit 테이블에는 위 3개의 서비스가 모두 데이터를 씀.
- 이런 서비스 많아지면 변경 관리, 커넥션 고갈, 확장성, 내고장성 등의 문제.
- 보통 이를 해결하고자 Audit을 위한 전용 서비스를 둠.
- 비동기 fire-and-forget 메시징으로 통신할 수도.

### 9.4 공동 오너십

- joint ownership.
- 이 역시 여러 서비스가 동일 테이블에 데이터를 쓰는 것.
- 공통 오너십은 모든/대부분의 서비스가 테이블에 쓰는 반면,
- 공동 오너십은 동일 도메인에 속한 1-3개 서비스만 동일 테이블에 쓰기.
- Product를 카탈로그와 재고만 접근하는 것.
- 이를 다루는 3가지 기법 뒤이어 소개.

#### 9.4.1 테이블 분할 기법

- 한 테이블을 여러 테이블로 나누고 각 서비스가 자신이 담당하는 데이터 파트를 소유하는 방식.
- Product의 경우 재고 부분을 Inventory라는 새로운 테이블에 나눠 담을 수 있음.
- Inventory에는 제품 ID와 재고 수 정보가 담김.
- 이렇게 쪼개면 단독 오너십이 됨.
- 다만 이렇게 나뉘면 데이터 일관성 문제가 생김.
- 이 일관성 문제의 중요도에 따라 비동기 또는 동기 등의 여러 선택지 고려해야 함.

#### 9.4.2 데이터 도메인 기법

- shared data domain을 생성하는 것도 방법.
- 공유되는 테이블들을 같은 스키마/데이터베이스에 모아두는 것.
- 일반적으로는 권장되지 않는 방식.
- 하지만 성능, 가용성, 데이터 일관성 이슈를 해결한다고.
- 서비스간 의존성이 없기 때문.
- 그러나 이런 공유 테이블 변경 비용이 상당.
- 그리고 특정 데이터 쓰기에 주의가 필요한 경우도 이를 관리하기 어려움.

#### 9.4.3 대리자 기법

- 어느 한 서비스에 테이블 독점권을 주어 대리자로 만드는 것.
- 다른 서비스들은 이 대리자를 통해 데이터 쓰기를 요청.
- 여기서는 카탈로그 서비스가 상품 데이터에 대리자가 될 수 있음.
- 아래는 트레이드 오프.

| 장점 | 단점 |
| --- | --- |
| 단독 오너십 형태 | 서비스 결합도 높음 |
| 데이터 스키마 변경 쉬움 | 소유자가 아닌 서비스는 데이터 쓰기 성능 저하 |
| 데이터 구조를 다른 서비스로부터 추상화 | 소유자가 아닌 서비스는 원자적 트랜잭션 불가 |
| | 소유자 아닌 서비스의 내고장성이 약해짐 |

### 9.5 서비스 통합 기법

- 데이터를 공동으로 소유하는 서비스를 통합하기.
- 의존성이나 성능 등의 공동 오너십이 가진 문제를 해결.
- 그러나 서비스 단위가 크기에,
- 테스트 범위와 배포 리스크 등이 커지고,
- 특정 기능의 문제가 주는 영향도 큼(내고장성 낮음).
- 확장성에도 문제. 늘리거나 줄이는 단위가 크기 때문.

### 9.6 데이터 오너십 요약

- Whishlist 테이블은 위시리스트 서비스에 오너십 할당.
- Audit 테이블은 공동 오너십 적용해, 감사 서비스를 만들고 다른 서비스들은 감사 서비스에 비동기로 큐 요청.
- Product 테이블은 카탈로그 서비스를 대리자로 삼고, 재고 서비스가 카탈로그에 쓰기 요청을 보내는 것으로.
- 이렇게 오너십을 정했다면, 이제는 비즈니스 워크플로우와 트랜잭션 요건을 따져봐야 함.

### 9.7 분산 트랜잭션

- ACID 이해 없이는 분산 트랜잭션 언제 사용할지 트레이드 오프는 어떨지 판단 어렵.
- 그래서 ACID 기본 설명 소개.
- 하지만 분산 트랜잭션은 ACID 지원 X.
- 개별 서비스가 각자 커밋하므로 원자성 없음.
- 일관성 역시 지키기 어려움.
- 격리 역시 마찬가지.
- 내구성은 각 서비스 단위로만 지켜짐. 사용자의 요청 단위가 아님.
- 대신 BASE를 지원.
- 먼저 BA는 Basic Availability.
- 시스템이 CAP에서 말하는 가용성을 보장하는 것.
- 데이터를 여러 시스템에 나누어 복제해서 저장하는 식으로 이를 달성.
- S는 Soft state.
- ACID에서의 일관성을 포기하는 것.
- 비즈니스 요청은 아직 처리 중이고, 일부만 반영된 상태를 가리킴.
- 마지막으로 E는 Eventual consistency.
- 책 내용이 별로라 [Abandoning ACID in Favor of BASE in Database Engineering](https://www.lifewire.com/abandoning-acid-in-favor-of-base-1019674#:~:text=In%20BASE%2C%20basic%20availability%20may,for%20part%20of%20your%20effort.)을 참고함.

### 9.8 최종 일관성 패턴

- 최종 일관성을 위한 3가지 패턴 소개.
- 이를 위해 일단 아래와 같이 서비스와 테이블이 있다고 가정.
- 그리고 사용자가 서비스 가입 해지를 요청해 와서,
- 고객 프로필 데이터를 삭제하고 이후로 비용은 더 이상 과금되지 않을 거라고 응답.
- 그럼 이제 Contract, Billing에도 해지를 반영해야 하는 상황.

| 서비스 | 소유 테이블 |
| ----- | -------- |
| 고객 프로필 | Profile |
| 지원 계약 | Contract |
| 과금 결제 | Billing |

#### 9.8.1 백그라운드 동기화 패턴

- 외부 서비스나 프로세스가,
- 데이터 소스를 주기적으로 체크해서,
- 데이터 소스를 서로 동기화.
- 한밤 중에 동기화를 수행할 수도,
- 혹은 매시간 일관성 체크할 수도.
- 어찌되든 데이터 소스 일관성을 맞추는 데 가장 오랜 시간이 걸림.
- 물론 데이터 소스는 즉시 동기화가 필요 없는 경우가 많음.
- 이 방식의 가장 어려운 점은, 어떤 데이터 변경이 있었는지 백그라운드 프로세스가 알아야 한다는 것.
- 아래는 트레이드오프 정리.

| 장점 | 단점 |
| --- | --- |
| 서비스 디커플링 | 데이터 소스 결합 |
| 응답성 좋음 | 구현 복잡 |
| | 경계 컨텍스트 무너짐 |
| | 비즈니스 로직 중복 가능성 |
| | 최종 일관성을 위한 시간이 다소 걸림 |

#### 9.8.2 오케스트레이티드 요청 기반 패턴

- 분산 트랜잭션의 가장 흔한 방법 중 하나는,
- 모든 처리가 끝날 때까지 엔드 유저가 기다리는 것.
- 이를 오케스트레이션 방식으로 처리하는 게 이 방식.
- 여기서는 프로필 서비스가 오케스트레이터 역할을 담당.
- 하지만 이렇게 되면 프로필 서비스에게 부하가 될 수도.
- 그래서 가입 해지 오케스트레이터를 별도로 두는 것을 권장.
- 응답성 보다 일관성을 더 중요시 하는 방식.
- 그러나 보상 처리를 고민해야 하고,
- 보상 처리조차 실패하는 경우도 고민해야 하는 등,
- 복잡하다는 것이 단점.
- 이후에 사가 패터 소개한다고.

| 장점 | 단점 |
| --- | --- |
| 서비스 디커플링 | 느린 응답 |
| 데이터 적시에 동기화 | 복잡한 에러 처리 |
| 원자적 비즈니스 요청 | 보상 트랜잭션 필요 |
