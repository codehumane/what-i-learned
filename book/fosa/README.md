# Fundamentals of Software Architecture

- 시작부터 아키텍트 정의가 나와 거부감이 들었으나,
- 중간중간 생각해 볼만한 내용들이 나와 기록하면서 읽어보기로.

# CH1. 서론

## 비즈니스 도메인 지식을 보유한다

- 도메인 지식이 없으면 문제점, 목표, 요구사항 이해가 어려움.
- 따라서 요구사항을 수용하는 효율적 아키텍처 설계도 X.
- 금융 기관에서 일하는데 평균 방향성 지수, 사행 계약, 무순위 채무 같은 평범한 금융 용어를 모른다면.
- 도메인 지식이 있어야 여러 이해관계자와 효과적으로 소통.

## 대인 관계 기술이 뛰어나다

> 그들이 당신에게 뭐라고 말하든 항상 사람이 문제입니다

- 팀워크, 조정, 리더십 등의 대인관계 기술 역시 중요.
- 여러 이유가 있지만 적어도 아키텍처 결정 배경을 효과적으로 설명하고 전달할 수 있어야 하기에.

## 정치를 이해하고 처세를 잘한다

- 회사 내부의 정치적 분위기를 이해하고 적절히 처신할 줄 알아야.
- 예컨대, 어떤 아키텍처 결정을 내리면 사람들의 반발을 사기 마련이며,
- 이 때 사람들이 변화를 잘 수용할 수 있도록 협상 기술을 잘 발휘해야(혹은 반대에 부딪히며 나아가야).

# CH2. 아키텍처 사고

아키텍트에게 필요한 사고들에 대해 이야기.

## 아키텍처 대 설계

- 사실은 개발팀과 어떻게 협력해야 하는지에 대한 이야기.
- 여기서 아키텍처는 아키텍트가 다루는 것이고 설계는 개발자가 다루는 것을 구분짓는 용도로 사용됨.
- 아키텍트는 전통적 방식이, 아니라 개발자와 아키텍트를 가르는 가상의 물리적 장벽을 허물고, 서로 끊임 없이 소통하는 관계를 정립해야 함.
- 상황이 계속 변하고 이에 대응하고자 이터레이션 방식으로 개발도 하기 때문.

## 기술 폭

- 개발자는 A를 늘려가며 기술의 깊이를 쌓아야 하고,
- 아키텍트는 B를 넓혀 기술 폭을 늘려야 함.
- 한 가지 해결 방식을 자세히 알고 있기 보다,
- 문제 해결에 필요한 5가지 솔루션을 알고,
- 주어진 제약과 목적에 따라 올바른 선택을 할 수 있어야 함.

```
       /\
      /  \
     / A  \
    /------\
   /   B    \
  /----------\
 /     C      \
/______________\

A: 내가 알고 있는 것
B: 내가 모른다는 사실을 아는 것
C: 내가 모른다는 사실조차 모르는 것
```

## 트레이드오프 분석

> 아키텍처는 구글링해도 안 되는 것이다

- 배포 환경, 비즈니스 동인, 회사 문화, 예산, 기간, 개발자 스킬 세트 등 각자에게 주어진 상황은 다 다름.
- 이런 개별 환경, 상황, 문제에 따라 트레이드오프가 다르며 따라서 해결책도 다름.
- 구글링을 통해 정답을 알 수 없는 이유임.
- 그리고 어떤 해결책에서 단점을 발견하지 못한다면 좀 더 분석이 필요한 한 가지 지표.
- 예컨대 아래 그림에서 언뜻 보기에 topic 활용한 방식이 좋아 보임.

```
# 토픽을 이용한 서비스 간 통신
bid producer ------> 매물 topic -----> bid capture
                           | ∟-----> bid tracking
                           ㄴ-------> bid analytics

# 큐를 이용한 서비스 간 통신
bid producer -----> 매물 queue -----> bid capture
       | ㄴ-------> 매물 queue ------> bid tracking
       ㄴ---------> 매물 queue ------> bid analytics
```

- 일단 토픽 방식은 확장성에 유리.
- 새로운 이력 서비스가 필요하더라도 bid producer에 변경은 필요 없음.
- bid history 서비스가 토픽을 새로 구독하기만 하면 됨.
- 이는 bid producer가 구독 서비스가 뭐가 있는지 몰라도 되는 디커플링이기도.

> 프로그래머는 장점을 잘 알지만 트레이드오프는 하나도 모른다.

- 하지만 토픽 방식에서는 누구나 입찰 데이터에 액세스 할 수 있어 보안 측면에 문제가 될 수 있음.
- 또한 토픽에서는 한 가지 데이터 계약만 지원하므로 어느 한 서비스에서 추가 데이터가 필요하면 나머지 모든 서비스도 함께 영향 받음.
- 더불어 토픽의 메시지 개수 모니터링과 오토 스케일링 제약도 존재.
- 그 외에도 주어진 상황에 따라 여러 장단점 도출 될 수 있음.

## 비즈니스 동인의 이해

- 비즈니스 동인을 이해하고,
- 요구사항을 아키텍처 특성으로 해석하고 번역함.
- 따라서 도메인 지식이 있어야 하며,
- 비즈니스 이해 관계자들과 원만하고 협력적 관계를 유지해야 함.

# CH3. 모듈성

> 물리학에 비유하자면, 소프트웨어 시스템은 엔트로피가 증가하는 방향으로 움직이는 복잡한 시스템을 모델링합니다. 질서를 유지하려면 물리적 시스템에 에너지를 투입해야 하는데, 소프트웨어 시스템도 마찬가지입니다. 아키텍트는 끊임없이 에너지를 소비해서 시스템을 구조적으로 탄탄하게 유지해야 합니다.

## 정의

- 클래스, 함수처럼 코드를 모아 둔 덩어리.
- 이는 물리적이 아닌 논리적 구분.
- 프로그래밍 언어에서 패키징 메커니즘은 다양.
- 함수/메서드, 클래스, 패키지/네임스페이스, 메타 오프젝트 프로토콜, ...

## 모듈성 측정

3가지 핵심 개념인 응집, 커플링, 커네이선스 이야기.

### 응집

- 한 모듈의 구성 요소가 동일한 모듈 내에 얼마나 포함되어 있는지를 나타냄.
- 기능적 > 순차적 > 소통적 > 절차적 > 일시적 > 논리적 > 동시적 응집.
- 아래와 같은 모듈 기능이 있다고 가정.

```
# 고객 관리

1. 고객 추가
2. 고객 수정
3. 고객 조회
4. 고객 알림
5. 고객 주문 조회
6. 고객 주문 취소
```

- 1-6을 한 모듈로 두는 게 좋을까 아니면 1-4와 5-6을 나누는 게 좋을까?
- 이는 경우에 따라 다름. 결국 트레이드 오프.
- LCOM(메서드의 응집 결여도)는 모듈의 구조적 응집도를 나타냄.
- 정의는 '공유 필드를 통해 공유되지 않는 메서드의 총 개수'.
- 식으로 나타내면 `LCOM96b = \frac{1}{a} \sum_{j=1}^a \frac{m - u(Aj)}{m}\`.
- 아래 그림에서 첫 번째가 응집도가 가장 높고, 두 번째는 메서드를 각자 클래스로 분리해도 상관 없을 정도로 낮은 응집도.

![LCOM](LCOM.jpg)

### 커플링

- 커플링 측정 도구는 많다고 함.
- 메서드의 호출과 반환이 호출 그래프를 형성하므로 수학적 접근이 용이하기에.
- 구심 커플링, 원심 커플링이 한 예.

### 추상도, 불안정도

`추상도 A = \frac{\sum m^a}{\sum m^c}`

- 추상도는 추상 아티팩트와 구상 아티팩트의 비율, 즉 구현 대비 추상화 정도 나타냄.
- 위 식에서 m^a는 추상 요소, m^c는 구상 요소.
- 한 예로 main() 메서드 안에 모든 코드가 담긴다면 추상도는 0에 가까움.

`불안정도 I = \frac{C^e}{C^e + C^a}`

- 불안정도는 코드베이스의 변동성을 의미함.
- C^a는 안으로 들어오는 커플링, C^e는 바깥으로 나가는 커플링.
- 구심 커플링과 원심 커플링의 합에 비해 원심 커플링이 얼마나 되는가.

### 메인 시퀀스로부터의 거리

`D = |A + I - 1|`

- A는 추상도, I는 불안정도를 나타냄.
- 두 값 모두 비율이므로 거리 역시 0과 1사이의 값.
- 이는 추상도와 불안정도 사이의 이상적 관계를 나타내는 식.
- 그래프 위의 선이 메인시퀀스이고,
- 여기서 아래쪽으로 멀어질수록 구현 코드만 잔뜩 있고 추상화가 없어 고통스러우며,
- 위로 멀어질수록 복잡하지도 않은 곳에 잔뜩 추상화만 적용되어 있어 쓸모 없는 영역.

![메인 시퀀스로부터의 거리](%EB%A9%94%EC%9D%B8%EC%8B%9C%ED%80%80%EC%8A%A4%EB%A1%9C%EB%B6%80%ED%84%B0%EC%9D%98%EA%B1%B0%EB%A6%AC.jpg)

### 커네이선스

> 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다.

- 밀러 페이지-존스가 구심/원심 커플링 메트릭을 좀 더 발전시켜 커네이선스<sup>connascence</sup> 개념을 만듦.
- 그리고 이 커네이선스를 정적인 것과 동적인 것으로 분류.

#### 정적 커네이선스

- 실행 시간이 아닌 소스 코드 레벨의 커플링.
- 명칭 커네이선스(CoN): 여러 컴포넌트의 엔티티명 일치.
- 타입 커네이선스(CoT): 여러 컴포넌트의 엔티티 타입 일치.
- 의미 커네이선스(CoM): 또는 관례 커네이선스(CoC): 여러 컴포넌트에 걸쳐 값의 의미 일치. 예컨대 `int TRUE = 1;`.
- 위치 커네이선스(CoP): 여러 컴포넌트의 값 순서 일치. 예컨대 메서드 매개변수 순서.
- 알고리즘 커네이선스(CoA): 여러 컴포넌트에서 특정 알고리즘의 일치. 서버/클라이언트의 사용자 인증을 위한 보안 해시 알고리즘이 그 예.

#### 동적 커네이선스

- 런타임 호출에서의 분석.
- 실행 커네이선스(CoE): 여러 컴포넌트의 실행 순서 제약.

```
email = new Email();
email.setRecipient("foo@bar.com");
email.send();
email.setSubject("whoops");
```

- 시점 커네이선스(CoT): 여러 컴포넌트의 실행 시점. 두 스레드의 경합 조건이 한 예.
- 값 커네이선스(CoV): 서로 연관된 다수 값들의 동시 변경 제약. 꼭지점 4개 값으로 사각형을 정의할 때 하나만 바꿀 때의 위험을 생각해 보면 됨.
- 식별 커네이선스(CoI): 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생. 두 컴포넌트가 분산 큐로 자료 구조를 공유해서 업데이트 하는 경우.

#### 커네이선스 속성

- 강도<sup>strength</sup>: 커네이선스를 얼마나 리팩토링하기 어려운지. 예컨대 동적에 비해 정적 커네이선스가 개선하기 쉬움.
- 지역성<sup>locality</sup>: 모듈들이 서로 얼마나 가까이 있는가. 보통 근접한 코드가 더 높은 커네이선스를 가짐. 커플링 문제가 되는 것들을 한 곳에 두는 식으로 문제 해결할 수도.
- 정도<sup>degree</sup>: 커네이선스가 미치는 영향 범위. 예컨대 1개 클래스냐 여러 클래스냐. 모듈이 몇 개 안 된다면 커네이선스 높아도 그리 해가 되지 않음. 물론, 일반적으로 코드베이스는 점점 커지기 마련.
- 짐 웨이리치는 아래와 같이 조언.

> 정도의 규칙: 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라.<br/>
> 지역성의 규칙: 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라.

# CH4. 아키텍처 특성 정의

아키텍처 특성은, 소프트웨어에서 도메인 기능과 직접적 관련이 없는 것들을 가리키며, 아래 3가지 기준을 충족. (크게 중요한 내용은 아니라서 상세 내용 기록은 X)

1. 비도메인 설계 고려 사항을 명시한다
2. 설계의 구조적 측면에 영향을 미친다
3. 애플리케이션 성공에 (절대적으로) 중요하다

## 아키텍처 특성 (일부) 목록

### 운영 아키텍처 특성

| 특성 | 설명 |
| --- | --- |
| 가용성<sup>availability</sup> | 얼마나 오랫동안 사용 가능한지. 24/7 등. |
| 연속성<sup>continuity</sup> | 재해 복구 능력이라고 함. |
| 성능<sup>performance</sup> | 스트레스 테스트, 피크 분석, 기능 사용 빈도 분석, 필요 용량, 응답 시간 등. 수 개월간 소요된다고. |
| 복구성<sup>recoverability</sup> | 장애 발생 시 얼마나 신속히 시스템 재가동 시켜야 하는지에 관함. 백업, 하드웨어 다중화 요건 등이 관련. |
| 신뢰성/안전<sup>reliability/safety</sup> | 페일 세이프. 실패 시 거액의 손실이 발생하는지 등. |
| 견고성<sup>robustness</sup> | 인터넷 접속 끊김, 정전, 하드웨터 실패 등의 에러나 경계 조건을 감당하는 능력. |
| 확장성<sup>scalability</sup> | 유저 수, 요청 수가 늘어나도 감당할 수 있는지. |

### 구조 아키텍처 특성

| 특성 | 설명 |
| --- | --- |
| 설정성<sup>configurability</sup> | 엔드 유저가 설정을 쉽게 바꿀 수 있는지 |
| 신장성<sup>extensbility</sup> | 새로운 기능을 얼마나 쉽게 추가할 수 있는지 |
| 설치성<sup>instability</sup> | 시스템을 필요한 환경에 얼마나 쉽게 설치할 수 있는지 |
| 활용성/재사용<sup>leverageability/reuse</sup> | 공통 컴포넌트를 여러 제품에서 활용할 수 있는지 |
| 지역성<sup>locality</sup> | 다국어 지원 |
| 유지보수성<sup>maintainability</sup> | 시스템을 얼마나 쉽게 변경/개선할 수 있는지 |
| 이식성<sup>portability</sup> | 여러 플랫폼에서 시스템 실행할 수 있는지 |
| 지원성<sup>supportability</sup> | 어느 정도의 기술 지원을 필요로 하는지 |
| 업그레이드성<sup>upgradeability</sup> | 새 버전으로 얼마나 쉽고 빠르게 업그레이드할 수 있는지 |

### 아키텍처 공통 특성

| 특성 | 설명 |
| --- | --- |
| 접근성<sup>accessibility</sup> | 장애인 등 모든 유저의 접근이 편한지 |
| 보관성<sup>archivability</sup> | 데이터 아카이빙 필요성이나 얼마의 시간 지난 뒤 삭제해야 하는지 |
| 인증<sup>authentication</sup> | 유저가 본인이 맞음을 증명하기 위한 보안 요구사항 |
| 인가<sup>authorization</sup> | 유저가 정해진 기능만 사용할 수 있도록 강제 |
| 합법성<sup>legal</sup> | 법적 제약조건 |
| 프라이버시<sup>privacy</sup> | 회사 내부 트랜잭션을 외부에 드러내지 않기 |
| 보안<sup>security</sup> | 데이터베이스 데이터 암호화, 네트워크 통신 암호화 등 |
| 사용성/성취성<sup>usability/achievability</sup> | 사용자가 애플리케이션을 사용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준 |

## 트레이드오프 및 나쁜 것 중에서 제일 나은 아키텍처

- 모든 아키텍처 특성을 만족시키기 어려움.
- 예컨대 보안 관련 노력을 기울이다 보면 성능 특성이 약해지기도.
- 최고의 아키텍처 말고, 나쁜 것 중에서 제일 나은 아키텍처 선정하라는 이야기.

# CH6. 아키텍처 특성의 측정 및 거버넌스

## 아키텍처 특성 측정

아키텍처 특성들의 특징 먼저 언급.

- 대부분 의미가 모호. 민첩성, 배포성, ...
- 정의가 다양. 예를 들어, 성능의 의미가 다양해서, 통일 없이는 원활한 의사소통 어려움.
- 복합적. 대부분 더 작은 여러 특성으로 나누는 것이 도움이 됨. 예컨대, 민첩성은 모듈성, 배포성, 시험성 등으로 세분화.

책에서는 이런 특성들의 운영적 측정, 구조적 측정, 프로세스 측정을 소개.

- 운영적 측정은 성능이나 확장성 측정.
- 성능은 해석이 중요. 평균으로 잡아 내기 어려운 특이점들 모니터링이 필요할 수도.
- 또한 달성하기 어려운 성능 수치보다는 통계 분석 결과에 기반해서 평소와 다른 이상 징후를 발견하기도.
- 구조적 측정은 코드 복잡도(순환 복잡도) 등 코드 품질 측정.
- 프로세스 측정은 시험성과 배포성 측정.
- 얼마나 테스트가 잘 되고 있는지, 배포 성공/롤백률이나 배포 시 발생한 이슈 버그 등의 통계 등을 측정하는 것.

## 거버넌스와 피트니스 함수

### 아키텍처 특성 관리

- 거버넌스<sup>governance</sup>는 kubernan(이끌다)이라는 그리스어에서 유래.
- 아키텍트 거버넌스는 소프트웨어의 모든 개발 프로세스를 포괄.
- 조직 내부의 소프트웨어 품질 보장 업무는 아키텍처 범주에 포함되므로 아키텍처 거버넌스 항목.
- 이런 거버넌스 활동의 자동화를 위해 피트니스 함수 기법이 있음.

### 피트니스 함수

- 아키텍처 피트니스 함수: 어떤 아키텍처 특성의 객관적인 무결성을 평가하는 모든 메커니즘.
- 순환 의존성: 아래 예시와 같이 피트니스 함수로 순환 참조 여부 확인.

```java
var jdepend = new JDepend();
jdepend.addDirectory("/path");
jdepend.analyze();
assertFalse(jdepend.containsCycles());
```

- 메인 시퀀스로부터의 거리 피트니스 함수

```java
var ideal = 0.0;
var tolerance = 0.5;
var packages = jdepend.analyze();
var iter = packages.iterator();
while (iter.hasNext()) {
  p = (JavaPackage) iter.next();
  assertEquals(ideal, p.distance(), tolerance);
}
```

- 아크 유닛 얘기도 언급.
- 그 외 카오스 몽키, 시미안 아미 등도 피트니스 함수 응용 사례.

# CH7. 아키텍처 특성 범위

## 커플링과 커네이선스

- 구심/원심 커플링 같은 코드 레벨의 커플링 메트릭은,
- 아키텍처 분석용으로는 너무 세분도가 높다고 함.
- 그래서 커네이선스라는 새로운 커플링 메트릭 등장.

> 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 세스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다.

- 예를 들어, 두 MS가 동일한 클래스를 공유한다면 정적 커네이선스.
- 동적 커네이선스에는 동기와 비동기가 있음.
- 분산 시스템들이 이벤트 기반으로 통신하면 비동기.

## 아키텍처 퀀텀과 세분도

- 소프트웨어는 컴포넌트 레벨의 커플링뿐만아니라,
- 여러 시스템 부분들이 비즈니스 개념으로 서로 한데 엮여 응집함.
- 성공적 소프트웨어를 위해서는 문제가 될 만한 커플링들을 모두 살펴봐야 함.
- 일단, 아키텍처 퀀텀이라는 용어를 아래와 같이 정의.

> 높은 기능 응집도와 동기적 커네이선스를 가진, 독립적으로 배포 가능한 아티팩트.

- 퀀텀은 말 그대로 물리 입자 가운데 가장 작은 양인 양자를 가리키는 것.
- 이를 아키텍처에 적용한 것.
- 잘 정의된 MS를 아키텍처 퀀텀으로 보면 될 것으로 보임.

# CH8. 컴포넌트 기반 사고

- 컴포넌트를 연관된 코드의 묶음으로 바라볼 수도 있지만,
- 아키텍트는 모듈을 물리적으로 구현한 컴포넌트로 생각.
- 자바 jar, 닷넷 dll, 루비 gem 파일 등.

## 컴포넌트 범위

- 가장 단순한 컴포넌트는, 클래스를 한 단계 높은 수준의 모듈로 래핑한 것. 보통 라이브러리로 부름.
- 한편, 서브시스템이나 레이어 형태로도 나타남.
- MS의 서비스도 역시 컴포넌트.

## 아키텍처 역할

- 레이어드 아키텍처와 모듈러 모놀리스 소개.
- 각 트레이드오프는 2부에서 다룰 예정이고(만사가 트레이드오프),
- 여기선 아키텍처 분할을 설명하기 위한 소개.
- 레이어드는 기술에 의한 분할이고,
- 모듈러 모놀리스는 도메인에 의한 분할.
- 아래와 같이 간단히 비교는 하고 있으나 기록은 생략.

그 외 특별한 내용 없음.

# CH9. 기초

여러가지 아키텍처 스타일을 다루기에 앞서, 몇 가지 근본적인 패턴들을 소개.

## 9.1 기초 패턴

### 진흙잡탕

- 내부 구조라고 할 만한 것은 없고,
- 데이터베이스를 직접 호출하는 이벤트 핸들러들의 스크립팅 애플리케이션.
- 강한 커플링이 얽히고 얽힘.
- 아직도 존재하는 유형.

### 유니터리 아키텍처

- 분산형(클라이언트 서버 같은) 시스템 이전의, 단일되고 통일된 시스템.
- 임베디드 시스템과 같은 일부 환경에만 제한적 사용.

### 클라이언트/서버

- 프론트엔드와 백엔드로 분리(또는 클라이언트 서버라고 명명).
- 요즘은 데이터베이스, 애플리케이션, 프론트 이렇게 3티어 사용.

## 9.2 모놀리식 대 분산 아키텍처

- 모놀리식은 전체 코드를 단일 단위로 배포.
- 분산형은 여러 단위로 배포.
- 뒤에서 다룰 레이어드, 파이프라인, 마이크로커널 아키텍처가 모놀리식.
- 서비스 기반, 이벤트 기반, 공간 기반, 서비스 지향, 마이크로서비스 아키텍처가 분산형.
- 분산형은 성능, 확장성, 가용성 측면에서 유리.
- 하지만 큰 트레이드오프 존재.

### 분산 컴퓨팅의 오류<sup>the fallacies of distributed computing</sup>

1. 네트워크는 믿을 수 있다
2. 레이턴시는 0이다
3. 대역폭은 무한하다
4. 네트워크는 안전하다
5. 토폴로지는 절대 안 바뀐다
6. 관리자는 한 사람뿐이다
7. 운송비는 0이다
8. 네트워크는 균일하다

### 다른 분산 아키텍처 고려 사항

- 위의 8가지 문제 외에도 분산 아키텍처에서 해결해야 하는 과제들이 있음.
- 먼저, 분산 로깅. 로그 위치나 포맷이 제각각이라 문제 추적이 어려움.
- 다음으로, 분산 트랜잭션. 분산 아키텍처에서는 최종 일관성 개념을 이용.
- 확장성, 성능, 가용성을 얻는 대신 데이터 일관성과 무결성을 희생한는 것.
- 마지막으로, 계약 생성이나 유지보수, 버저닝 역시 만만치 않은 문제들.
