# From the Preface to the First Edition

> You work small miracles every day.

# What Makes a Pragmatic Programmer?

실용주의 프그래머라면, 아래 특성들 중 많은 것을 갖고 있을 것.

1. Ealry adopter/fast adapter
    - 기술과 기법에 대한 직감이 있고, 새로운 것을 시도하기 좋아함.
    - 새로운 것이 나타났을 때 빠르게 살펴보고 기존의 지식과 통합할 수 있음.
    - 자신감은 자신의 경험에서 흘러나옴.
2. Inquisitive (호기심 많다는 뜻)
    - 질문하길 좋아함.
    - 사소하고 작은 사실들의 수집가.
    - 이는 지금 이후의 결정에 영향을 미침.
    - 양자역학이 뭐지? 넌 그걸 어떻게 했니? 라이브러리에 문제가 있니? 심볼릭 링크는 어떻게 구현된 거지?
3. Critical thinker
    - 사실을 먼저 파악한 뒤에야 주어진 것을 받아들임.
    - 동료가 "원래 그렇게 해왔어"라고 말하거나,
    - 벤더가 모든 문제의 해결책을 약속하면,
    - 이의를 제기할 줄 앎.
4. Realistic
    - 직면한 문제의 본질을 이해하려 함.
    - 이는 문제가 얼마나 어렵고 해결하는 데 얼마나 걸릴지에 대한 좋은 감을 가져다 줌.
    - 깊이 있는 이해는 그것을 지속할 수 있는 체력이 됨.
5. Jack of all trades (만물박사라는 의미)
    - 다양한 기술과 환경에 익숙해지려 부단히 노력함.
    - 새로운 개발에 대한 최근 정황들을 꾸준히 알아둠.
    - 비록 현재 직업이 스페셜리스트가 되길 강요하는 상황이더라도,
    - 언제나 새로운 영역과 새로운 도전에 부딪히려 함.

가장 기본적인 특성을 가장 마지막에 언급.

```
Tip 1) Care About Your Craft
Tip 2) Think! About Your Work
```

- 실용주의 프로그래머가 되기 위해서, 일을 하고 있을 때 자신이 그것을 어떻게 하고 있는지를 의식적으로 생각해야 함.
- 일회성 감사가 아니라 모든 프로젝트, 매일, 당신이 내리는 모든 결정에 대한 지속적인 평가가 필요.
- 꾸준히 생각하고 자신의 일에 대해 실시간으로 비판하라.

# Individual Pragmatists, Large Teams

- 종종 "소프트웨어는 엔지니어링 규율"이라면서,
- "개별 멤버들이 그들을 위한 결정을 내리면 소프트웨어는 무너진다"고 함.
- 그러나, 소프트웨어 개발에는 개인과 그들의 장인정신을 배제할 수 없음.

# It's a Continuous Process

- 매일의 작은 보살핌이 오랫동안 지속될 때 훌륭한 결과가 나온다는 이야기.
- "Kaizen" = 많은 작은 개선들을 꾸준히 지속하는 것을 가리키는 일본 단어.
- 이는 일본 제조업에서의 극적인 생산성과 품질 향상을 가져온 주된 이유였다고.
- 1판에서도 있었던 이야기로 기억.

# 1. A Pragmatic Philosophy

- 이것은 당신의 경력이고 인생이다. (1. It's Your Life)
- 무엇이 실용주의 프로그래머를 구분시켜 주는가?
- 일단, 문제 그 자체보다 더 큰 그림과 맥락에서 문제를 바라봄.
- 또한, 자신들이 하는 모든 것에 책임감을 가짐. (2. The Cat Ate My Source Code)
- 프로젝트를 깨끗하게 유지하는 사람들. (3. Software Entropy)
- 대부분의 사람들은 변화를 어려워함. 때로는 좋은 이유 때문이기도 하고, 때로는 단순한 관성 때문.
- 변화를 착수하기 위한 전략들을 뒤에서 살펴 볼 예정. (4. Stone and Boiled Frogs)
- 일의 맥락을 이해하는 것은 소프트웨어가 얼마나 좋아야 하는지에 대한 지침이 됨. 완벽이 좋아보일지 모르나 트레이드 오프가 있기 마련. (5. Good-Enough Software)
- 물론, 다양한 지식과 경험을 가지고 있어야 함. 배움은 지속적인 과정. (6. Your Knowlege Portfolio)
- 우리는 진공 상태에서 일하는 게 아니고, 여러 사람과 상호 작용하며 일함. (7. Communicate!)
- 실용주의 프로그래밍은 실용주의 사고에서 자라나기 시작함.
- 1장은 이런 철학에 대한 이야기.

## Topic 1. It's Your Life

- 이건 당신의 인생임.
- 당신이 가진 것이고, 당신이 실행하는 것이며, 당신이 만드는 것.
- 더 적게 받는 것 같고, 더 적게 대우 받는 것 같다고 느끼는 사람들에게 아래와 같이 질문함.

> Why can't you change it?

```
Tip 3 You Have Agency
```

- 작업 환경이 열악하거나, 작업이 지루한가?
- 그렇다면 고쳐라. 하지만 영원히 시도하지는 마라.
- 마틴 파울러는 아래와 같이 이야기.

> You can change your organization or change your organization.

- 소프트웨어 개발은 개인에게 주어진 주도권이 큰 직업군에 속함.
- 주도적으로 행동하고 원하는 것을 취할 것.

## Topic 2. The Cat Ate My Source Code

- 실용주의 철학의 가장 초석이 되는 아이디어는 책임감.
- 경력 발전, 배움과 교육, 프로젝트, 매일의 작업 속에서 당신과 당신의 일에 대한 책임감.
- 책임감과 더불어, 무지나 에러 등을 받아들이는 것에 두려움이 없음.
- 기쁜 일은 아니겠지만 분명 일어나는 일임.
- 충분한 테스팅, 좋은 문서화, 견고한 자동화에도 불구.
- 배포는 늦어지고 예상치 못한 기술적 문제는 일어남.
- 이런 문제가 생기면, 자신에 대한 역량을 믿으면서도, 스스로의 부족한 점(무지나 실수)도 인정해야 함.

### Team Trust

- 신뢰는 창의성과 협력에 있어 필수.
- 신뢰의 환경에서는 소신 있게 말할 수 있으며 서로를 믿을 수 있음.
- 신뢰의 손상은 복구하기 어려움.

### Take Responsibility

- 자신이 맡은 일이 제대로 수행되도록 노력.
- 그러나 자신의 통제 밖에 있는 위험은 분명히 구분해야 함.
- 불가능한 상황에 대해서까지 책임감을 가지면 안 됨.
- 한편, 책임지기로 마음 먹었다고 하더라도, 실수나 판단의 오류가 있을 수 있음.
- 이럴 땐 솔직하게 문제를 받아들이고, 변명이 아닌 대안을 제시.
- 공급 업체가 오지 않았다면 이를 대비한 계획이 있었어야 함.
- 코드가 포함된 저장 장치가 망가졌다면 백업이 있었어야 함.
- 핑계나 변명을 찾지는 말자.

```
Tip 4) Provide Options, Don't Make Lame Execuses
```

## Topic 3. Software Entropy

- 소프트웨어 개발이 대부분의 물리 법칙으로부터 자유롭긴 하지만,
- 엔트로피의 급격한 증가는 우리를 힘들게 함.
- 엔트로피란 물리학 용어이며, 시스템의 무질서 양을 가리킴.
- 소프트웨어에서 무질서가 증가하면 우리는 이를 "소프트웨어 부패"라고 부름.
- 혹자는 좀 더 긍정적 용어인 "기술 부채"라 부름.
- 언젠가 갚을 수 있는 의미로 사용되는 것이긴 하나 실제로는 그렇지 않음.
- 용어가 어찌됐던 부채와 부패는 통제할 수 없는 수준으로 퍼져나감.
- 하지만 이것이 통제할 수 있는 심리적, 문화적 요인이 있음.
- 깨진 유리창 이야기.

```
Tip 5) Don't Live with Broken Windows
```

- 깨진 유리창을 그대로 내버려 두지 말 것.
- 나쁜 설계, 잘못된 결정, 부실한 코드 등.
- 발견되고 얼마 지나지 않아 고쳐져야 함.
- 적절히 고칠 시간이 없다면 땜빵 식으로라도 해결해 두어야 함.
- 소프트웨어 부패의 여러 요인이 있지만, 무엇보다 방치가 부패를 가장 가속화 시키는 요인.

### First, Do No Harm

- 깨진 유리창이 하나라도 없다면,
- 본인이 그 첫 번째 깨진 유리창의 주인공이 되지 않으려 부단히 노력.
- 스스로에게 "No broken windows"라고 말하라.

## Topic 4. Stone Soup and Boiled Frogs

- 군인이 전쟁을 마치고 마을로 돌아와서,
- 물 냄비에 돌 3개를 넣고 수프라며 만들기 시작하니,
- 자기 것을 지키느라 급급했던 마을 사람들이 하나 둘씩 재료를 들고 나와,
- 다 같이 모여 앉아 좋은 수프를 먹게 되었다는 이야기.
- 군인이 가진 것은 없었으나 촉매제<sup>catalyst</sup>처럼 행동함.
- 결과적으로 마을에 몇 달간 없었던 좋은 일로 이어짐.
- 아주 잘 알고 있는 일이라는 이유로 모든 것을 할 수 있는 권한을 요구하면,
- 멍한 시선, 지연, 위원회의 구성, 예산 승인 등 일이 복잡해짐.
- 이 대신 돌을 꺼내는 것을 권장.
- 합리적으로 요청할 수 있는 것을 찾아내고, 그것을 잘 개발한 뒤, 사람들에게 보여주고, 놀라게 하라.
- 그리고 "만약 이것을 추가하면 이렇게 이렇게 더 나아집니다"라고 말하라.
- 별로 중요하지 않은 것처럼 말하고, 뒤에 앉아서 사람들이 물어보기를 기다려라.
- 사람들은 더 쉽게 동참할 것.
- 미래를 보여주며 사람들을 모여들게 하라.

```
Tip 6) Be a Catalyst for Change
```

### The Villagers' Side

```
Tip 7) Remember the Big Picture
```

- 개구리를 끓는 물에 넣으면 바로 튀어 나오지만,
- 차가운 물에서 점차 온도를 높여나가면 개구리는 인지하지 못하고 죽음.
- [끓는 물 속의 개구리 신드롬](https://ko.wikipedia.org/wiki/%EB%81%93%EB%8A%94_%EB%AC%BC_%EC%86%8D%EC%9D%98_%EA%B0%9C%EA%B5%AC%EB%A6%AC)
- 이는 앞서 다뤘던 깨진 유리창과는 다른 문제.
- 깨진 유리창에서는, 돌보는 사람이 아무도 없다는 것을 인지했기에, 엔트로피에 대적할 의지를 잃어버림.
- 끓는 물 속 개구리는, 변화를 인지조차 못하는 것.
- 큰 그림을 보려고 노력하라. 주위에서 무엇이 일어나는지 꾸준히 확인.

## Topic 5. Good-Enough Software

- 실제 세상에서 품질에 대한 완벽한 통제권을 가질 수는 없음.
- 우리는 "충분히 좋은" 소프트웨어를 만들 수 있어야 함.
- 사용자, 유지보수자, 본인 스스로의 마음에 있어서 충분히 좋은.
- 우리의 생산성은 올라가고 사용자들은 만족할 것.
- `충분히 좋은 != 엉성하고 형편 없이 만들어진 코드`임에 유의.

### Involve Your Users in the Trade-Off

```
Tip 8) Make Quality a Requirements Issue
```

- 사용자에게 소프트웨어가 얼마나 좋기를 원하는지 물어본 적이 있는가?
- 물론, 심박 조율기나 오토파일럿, 광범위하게 사용되는 저수준 라이브러리 등을 만든다면, 타협의 여지가 없을 수 있음.
- 하지만, 신형 제품을 만드는 곳이라면, 마케팅 담당자는 지켜야 하는 약속이 있고, 고객은 배포일을 기반으로 계획을 세우며, 회사는 자금 유동의 제약을 받음.
- 불가능한 약속을 하라거나, 기일을 맞추기 위해 기본 엔지니어링 절차들을 무시하라는 것이 아님.
- 시스템의 범위와 품질은 시스템 요구사항으로써 논의되어야 함.
- 의외로 고객들은 약간의 결함이 있더라도 오늘을, 빛나지만 이런 저런 부가기능이 달린 나중보다 선호.
- 또한 고객들이 빨리 써 볼수록 피드백을 통해 궁극적으로 더 좋은 솔루션으로 나아갈 수 있음.
- 내일의 완벽함보다 오늘의 판타지.

### Know When to Stop

- 지나치게 꾸미고 다듬다 보면 완전히 좋은 프로그램도 망가짐.
- 계속 나아가면서, 코드가 잠시 동안이라도 자신의 일을 하게 두어라.
- 완벽할 필요도 없고, 완벽한 적도 없음.

## Topic 6. Your Knowledge Portfolio

- 지식과 경험은 가장 중요한 매일의 직업적 자산.
- 하지만, 이 자산은 시간이 지나면서 낡고 더 이상 쓸모 없어지기도.
- 그러므로 새로운 것을 배우는 능력이 가장 중요한 전략적 자산.

### Your Knowledge Portfolio

지식 포트폴리오는 재정적 포트폴리오와 매우 유사.

1. 정기적으로 투자 - 습관처럼
2. 다양성은 장기적 성공에 주요 요인
3. 보수적인 것과 고위험 고수익 투자 사이에서 균형
4. 저점일 때 사고 고점일 때 팔아서 수익 극대화
5. 포트폴리오는 주기적으로 리뷰하고 리밸런싱 해야 함

### Goals

1. 매년 한 가지 이상의 새로운 언어를 배워라.
    - 각 언어들은 같은 문제를 서로 다르게 접근함.
    - 서로 다른 언어를 배움으로써, 틀에서 벗어나고 사고를 넓힐 수 있음.
2. 매달 기술 서적을 읽어라.
    - 깊은 이해를 위해서는 장문의 책을 읽는 것이 도움이 됨.
    - 처음엔 현재 사용하는 기술과 관련된 것을 읽는 것으로 시작하고,
    - 충분히 익혔다면 프로젝트와 관련 없는 것으로 이를 넓혀라.
3. 비기술적 서적 역시 읽어라.
    - 우리는 결국 사람들과 일함.
    - 인간 측면의 문제는 완전히 다른 기술 세트를 요구함.
    - 흔히 소프트 스킬이라고 부름(아이러니하게 마스터하기 어려움hard).
4. 수업을 들어라.   
    - 오프라인이나 온라인 등 흥미로운 코스를 찾아보라.
5. 지역 사용자 그룹과 밋업에 참가하라.
    - 고립은 경력에 있어 치명적.
    - 회사 바깥의 사람들은 어떻게 일하는지 가서 보라.
6. 서로 다른 환경을 경험하라.
    - 윈도우 환경에서만 일했다면 리눅스 환경에서도 시간을 보내라.
7. 최신 정보를 꾸준히 찾아라.

### Critical Thinking

```
Tip 10) Critically Analyze What You Read and Hear
```

아래 질문들을 통해서 비판적으로 읽고 생각하라는 이야기.

1. Ask the "Five Whys"
2. Who does this benefit?
3. What's the context?
4. When or Where would this work?
5. Why is this a problem?

## Topic 7. Communicate!

- 가지고 있는 것도 중요하지만, 포장하는 것도 중요.
- 아무리 좋은 아이디어, 코드, 실용주의 사고라도 효과적 커뮤니케이션이 있어야 가치를 가짐.
- 우리는 단순히 기계와 언어로 소통하는 것 외에도 하루에 정말 많은 커뮤니케이션을 함.
- 영어를 단지 또 다른 프로그래밍 언어라고 생각하라.
- 코드 작성할 때와 마찬가지로 DRY, 자동화 등을 중요하게 고려.

```
Tip 11) English is Just Another Programming Language
```

### Know Your Audience

- 커뮤니케이션, 말하기, 괴롭히기를 구분해서 정의.
- 청중의 요구, 관심사, 역량을 이해해야 함.
- 그리고 피드백을 모아야 함.
- 질문을 기다리지 말고 물어보라.
- 바디 랭기지와 표정을 살펴보라.

> The meaning of your comunication is the response you get.

### Know What You Want to Say

- 말하기 전에 계획을 세우고 개요를 작성하라.
- "이렇게 하면 청중들에게 내가 말하고자 하는 바가 제대로 전달 되는 걸까?"를 물어라.
- "그렇다"고 대답할 수 있을 때까지 다듬어라.

### Choose Your Moment

- 청중들이 무엇을 듣기 원하는지 뿐만아니라,
- 그들의 우선순위가 무엇인지 이해해야 함.
- 소스 코드가 사라져 방금 상사 때문에 지친 매니저라면,
- 당신의 새로운 개발 방법론에 대한 이야기는 잘 들리지 않을 것.
- 반면, 소스 코드 리포지토리에 대한 아이디어에는 좀 더 수용적.
- "지금 말하기 좋은 타이밍인가?"를 생각하자.

### Choose a Style

- 어떤 이는 단지 사실만 포함된 요약을 좋아함.
- 어떤 이는 길고 넓게 얘기하길 좋아함.
- 어떤 이는 A라는 주제에 초보자일 수도 있고 전문가일 수도.
- 혹시 모르겠거나 애매하다면 물어보라.

### Make It Look Good

- 많은 개발자들이 문서를 작성할 때 오로지 내용에만 집중.
- 하지만, 당신의 아이디어는 중요함. 보기 좋은 모습으로 잘 전달 될 수 있어야 함.

### Involve Your Audience

- 문서 작성의 초기 단계부터 독자를 참여 시킬 것.
- 피드백을 얻고 아이디어를 수용하라.

### Be a Listener

- 사람들이 들어주길 원한다면 당신이 사용해야 하는 유일한 방법이 있음.
- 바로 다른 이들의 이야기를 들어주는 것.
- 자신이 모든 정보를 갖고 있다고 하더라도, 강연을 하는 공식적 자리라고 하더라도.
- 질문을 던지고, 자신들의 언어로 다시 말하게 하는 등의 노력으로 사람들을 참여시킬 것.

### Get Back to People

```
Tip 12) It's Both What You Say and the Way You Say It
```

- 당신이 질문했을 때 상대방이 응답이 없다면 공손치 못하다고 여길 것.
- 반대로는 어떠한가? 당신은 잘 응답하고 있는가?
- 아무리 단순한 답이라도 항상 답을 해주어라.
- 사람들에게 꾸준히 정보를 제공하다 보면,
- 때로는 실수에 있어 관대하게 만들어 주기도 하고,
- 당신이 그들을 잊지 않았다고 느끼게 해 줌.
- 이런 식으로 더 많이 커뮤니케이션할수록 더 많은 영향력을 가질 수 있음.

### Documentation

```
Tip 13) Build Documentation In, Don't Bolt It On
```

- 문서화 중요하다는 이야기.
- 중복하지 않고 코드 가까이 두면 도움이 됨.
- 예를 들어, 소스 코드에서 공개용 API에는 이것의 이유/목적을 코멘트로 작성하라.
- 어떻게 그 목적을 달성하는지는 코드에 나와 있으므로 중복을 피하는 것이고(코드와 코멘트 모두를 중복으로 수정 X), - DRY
- 소스 코드에 이유를 적으니 코드 가까이 둠으로써 수정할 기회를 더 많이 만드는 것.

# 2. A Pragmatic Approach

## Topic 8. The Essence of Good Design

```
Tip 14) Good Design Is Easier to Change Than Bad Design
```

- 잘 설계 된 것은 그것을 사용하는 사람에게 잘 맞음.
- 이를 코드에 적용시킨다면, 변경하기 쉬운 것을 가리킴.
- ETC = Easier to Change
- 모든 설계 원칙은 ETC의 특수화.
- 디커플링이 좋은 이유도, 관심사 분리로 변경을 쉽게 만들어 주기 때문.
- SRP는 한 번에 한 모듈만 변경할 수 있게 도와줌.
- 좋은 네이밍은 가독성을 높여 결국 변경을 도움.

### ETC Is a Value, Not a Rule

- 가치는 결정을 도와줌(내가 이것을 해야 하는가 말아야 하는가).
- 소프트웨어 개발에 있어서 ETC는 가이드이며,
- 여러 갈랫길 사이에서 결정할 수 있게 도와줌.
- 처음에는 연습이 필요.
- 파일 저장 시, 테스트 작성 시, 버그 수정 시, 의식적으로 스스로에게 물어야 함.
- "방금 내가 한 게 전체 시스템의 변경을 어렵게 만드나 쉽게 만드나?"
- ETC에는 암묵적 전제가 잇음.
- 여러 길 중에서 어느 것이 미래에 변경을 쉽게 만들어 주는지 알 수 있다는 것.
- 대부분의 경우 상식을 따르거나 경험에서 우러난 추측을 통해 가능.
- 때로는 단서가 없음. 그러나 이 경우에도 2가지를 할 수 있음.
- 먼저, 언제든 쉽게 대체될 수 있게 하는 것. 쉬운 변경을 위한 가장 궁극적인 대안.
- 둘째로, 감각을 익히는 방법으로 취급. 한 번 예상해보고, 시간이 지난 뒤 다시 와서 어떻게 바뀌었는지 살펴보라.

## Topic 9. DRY - The Evils of Duplication

프로그래머는 유지보수 모드를 끊임 없이 유지해야 함.

- 많은 사람들이 애플리케이션이 릴리즈 되고 나서야 유지보수가 시작된다고 생각.
- 여기서 유지보수란, 버그를 고치고 기능을 강화하는 것.
- 하지만 이는 잘못된 생각.
- 우리의 이해는 매일 매일 바뀜.
- 새로운 요구사항이 도착하고,
- 기존의 요구사항은 진화함.
- 환경도 계속 바뀜.
- 무엇이 됐든 유지보수는 별개의 활동이 아닌,
- 전체 개발 프로세스의 루틴 영역.

유지보수를 어렵게 만드는 것은 중복.

- 무언가를 바꾸려면 그 대상을 찾아야 함.
- 그런데 그 바꿔야 하는 지식은 명세, 프로세스, 프로그램 들에 중복되어 있음.

소프트웨어 개발을 신뢰성 있게, 그리고 효율적으로 유지보수 하려면 DRY가 필요.

> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

```
Tip 15) DRY-Don't Repeat Yourself
```

### DRY Is More Than Code

- 1판에서 설명이 부족했는지,
- 많은 사람들이 DRY를 코드에 한정해서 생각함.
- 하지만, DRY는 지식<sup>knowledge</sup>과 의도<sup>intent</sup>의 중복에 관한 것.

### Duplication in Code

아래는 코드 중복 예시.

```python
def print_balance(account)
    printf "Debits:  %10.2f\n", account.debits
    printf "Credits: %10.2f\n", account.credits
    if account.fees < 0
        printf "Fees:    %10.2f-\n", -account.fees
    else
        printf "Fees:    %10.2f\n", account.fees
    end
    printf "         ———-\n"
    if account.balance < 0
        printf "Balance: %10.2f-\n", -account.balance
    else
        printf "Balance: %10.2f\n", account.balance
    end
end
```

일단, 음수 처리를 DRY한 결과.

```python
def format_amount(value)
    result = sprintf("%10.2f", value.abs)
    if value < 0
        result + "-"
    else
        result + " "
    end
end
  
def print_balance(account)
    printf "Debits:  %10.2f\n", account.debits
    printf "Credits: %10.2f\n", account.credits
    printf "Fees:    %s\n",     format_amount(account.fees)
    printf "         ———-\n"
    printf "Balance: %s\n",     format_amount(account.balance)
end
```

이제, `10.2f`로 변환하는 부분을 DRY.

```python
def format_amount(value)
    result = sprintf("%10.2f", value.abs)
    if value < 0
        result + "-"
    else
        result + " "
    end
end
  
def print_balance(account)
    printf "Debits:  %s\n", format_amount(account.debits)
    printf "Credits: %s\n", format_amount(account.credits)
    printf "Fees:    %s\n", format_amount(account.fees)
    printf "         ———-\n"
    printf "Balance: %s\n", format_amount(account.balance)
end
```

만약, 고객이 레이블과 숫자 사이의 추가 공간을 요구한다면 어떻게 될까? 5개 라인을 일일이 고쳐야 함. 따라서 아래와 같이 DRY.

```python
def format_amount(value)
    result = sprintf("%10.2f", value.abs)
    if value < 0
        result + "-"
    else
        result + " "
    end
end
  
def print_line(label, value)
    printf "%-9s%s\n", label, value
end
  
def report_line(label, amount)
    print_line(label + ":", format_amount(amount))
end
  
def print_balance(account)
    report_line("Debits",  account.debits)
    report_line("Credits", account.credits)
    report_line("Fees",    account.fees)
    print_line("",         "———-")
    report_line("Balance", account.balance)
end
```

### Not All Code Duplication Is Knowledge Duplication

```python
def validate_age(value):
    validate_type(value, :integer)
    validate_min_integer(value, 0)

def validate_quantity(value):
    validate_type(value, :integer)
    validate_min_integer(value, 0)
```

- 위 코드는 DRY 위배가 아님.
- 코드는 같지만 이들이 표현하는 지식이 서로 다름.
- 하나는 주문에 앞서 나이를 검사하는 것.
- 다른 하나는 주문 수량을 검사하는 것.
- 이들이 같은 모습을 하고 있는 것은 중복이 아니라 우연.

### Duplication in Documentation

```python
# Calculate the fees for this account.
#
# * Each returned check costs $20
# * If the account is in overdraft for more than 3 days,
#   charge $10 for each day
# * If the average account balance is greater that $2,000
#   reduce the fees by 50%

def fees(a)
    f = 0
    if a.returned_check_count > 0
        f += 20 * a.returned_check_count
    end
    if a.overdraft_days > 3
        f += 10*a.overdraft_days
    end
    if a.average_balance > 2_000
        f /= 2
    end
    f
end
```

- 위 코드에서 주석은 중복.
- 요금이 바뀌면 코드와 주석 모두 바꿔줘야 함.
- 여기서 주석의 역할은 코드의 가독성이 떨어지는 것을 보완하는 정도.
- 차라리 아래와 같이 하는 것이 어떨지.

```python
def calculate_account_fees(account)
    fees  = 20 * account.returned_check_count
    fees += 10 * account.overdraft_days  if account.overdraft_days > 3
    fees /= 2                            if account.average_balance > 2_000
    fees
end
```

### DRY Violations in Data

- 데이터 구조 역시 지식의 표현.
- 여기에도 DRY 원칙이 적용됨.

```java
class Line {
    Point start;
    Point end;
    double length;
}
```

- `legnth`는 중복.
- `start`나 `end`가 바뀔 때 같이 바꿔줘야 함.
- 따라서 아래와 같이 중복을 제거.

```java
class Line {
    Point start;
    Point end;
    double length() {
        return start.distanceTo(end);
    }
}
```

- 하지만, 성능 상의 이유로 일부로 DRY를 위배할 수도.
- 만약 `length`를 매번 구하는 것이 비용이 크다면,
- 한 번 계산된 값을 변수로 가지고 있을 수 있음.
- 하지만 이로 인한 영향은 국소화해야 함.
- 이 위반이 바깥 세상으로 나가면 안 됨.

```java
class Line {
    private double length;
    private Point  start;
    private Point  end;
 
    public Line(Point start, Point end) {
        this.start = start;
        this.end   = end;
        calculateLength();
    }
 
    // public
    void setStart(Point p) { this.start = p; calculateLength(); }
    void setEnd(Point p)   { this.end   = p; calculateLength(); }

    Point getStart()       { return start; }
    Point getEnd()         { return end;   }

    double getLength()     { return length; }

    private void calculateLength() {
        this.length  = start.distanceTo(end);
    }
 };
```

### Representational Duplication

- 코드가 바깥 세상과 인터페이싱 될 때도 중복이 발생.
- 외부 API, 스키마, 에러 코드의 의미 등을 알아야 함.
- 그럼 우리의 코드와 외부 엔티티가 중복임.
- 하나가 바뀌면 한 쪽이 영향 받음.
- 이 중복을 피할 순 없지만, 불편을 줄일 수 있는 방법들이 있음.

#### Duplication Across Internal APIs

- 내부 API들에 대해선, 중립된 형식으로 API를 명시할 수 있는 도구를 활용.
- 이런 도구들을 일반적으로 문서를 생성하고 API를 목킹하며 기능 테스트와 API 클라이언트들을 만들어 줌.
- 이상적으로 이 도구는 모든 API들을 하나의 리포지토리에 저장하게 해 줌.
- 그리고 여러 팀들은 이를 공유해서 사용.

#### Duplication Across External APIs

- 공개 API들이 점점 더 많이 [OpenAPI](https://github.com/OAI/OpenAPI-Specification)를 사용하고 있음.
- 사용자들은 API 스펙을 임포트해서 좀 더 신뢰성 있게 서비스를 통합할 수 있음.
- 이런 명세를 찾을 수 없다면 하나 만들고 발행하는 것도 고려.
- 다른 사람에게도 도움 줄 뿐 아니라 유지보수 도움을 얻을 수도 있음.

#### Duplication with Data Sources

- 많은 데이터 소스들은 스키마를 검사할 수 있게 해 줌.
- 이 또한 데이터들과 코드의 중복을 줄여주는 일.
- 직접 데이터 구조와 대응시켜 코드를 작성하는 대신,
- 스키마를 통해 컨테이너를 자동으로 생성할 수 있음.
- 한편, 또 다른 선택지도 있음(저자가 선호).
- 고정된 구조로 외부 데이터를 표현하는 대신,
- 맵,해시, 딕셔너리 같이 그냥 키/값 데이터 구조체를 사용하는 것.
- 이런 방식의 한 가지 위험은 데이터 내부를 너무 많이 노출시킨다는 것.
- 2번째 계층을 추가하는 것으로 문제를 해결하기를 권장.
- 예를 들어, 간단한 테이블 기반의 유효성 검사 세트를 만들 수도.

### Interdeveloper Duplication

- 감지하기도 어렵고 다루기도 어려운 중복은 바로,
- 프로젝트 내의 여러 개발자들 사이의 중복.
- 이를 극복하려면 개발자들 간에 적극적이고 잦은 커뮤니케이션이 필요.
- 매일 스탠딩 미팅을 할 수도 있음.
- 포럼을 만들어 공통 문제를 논의할 수도.
- 소스 트리의 중앙 공간을 만들고 유틸리티 루틴이나 스크립트가 모이게 하는 것도 방법.
- 다른 사람의 코드와 문서를 읽도록 장려.

```
Tip 16) Make It Easy to Reuse
```

## Topic 10. Orthogonality

- 설계/빌드/테스트/확장이 쉬운 시스템을 만드는 데 있어,
- 직교성<sup>orthogonality</sup>은 매우 중요한 개념.

### What Is Orthogonality?

- "직교성"은 기하학에서 빌려온 용어.
- 만약 2개의 선이 직각을 이루며 만난다면 이를 직교한다고 표현.
- 벡터 용어에서는 이 2개의 선을 독립적이라고 부름.
- 컴퓨팅에서는 독립 또는 디커플링의 의미를 가짐.
- 한 쪽의 변경이 다른 쪽에 영향을 미치지 않는다면 이는 직교.
- 잘 설계된 시스템에서, 데이터베이스 코드는 사용자 인터페이스에 대해 직교적.

### Benefits of Orthogonality

```
Tip 17) Eliminate Effects Between Unrelated Things
```

직교성을 통해 생산성 향상과 리스크 줄이기를 얻을 수 있음.

#### Gain Productivity

- 변경이 국소화 되면, 개발 시간과 테스트 시간이 줄어듦.
- 또한 재사용이 장려됨. 컴포넌트가 구체적이고 잘 정의된 책임을 가진다면, 이곳 저곳에서 재사용될 가능성 높음.
- 만약 1개 컴포넌트가 M개의 서로 다른 일을 하고, 다른 1개가 N개의 잘 구분된 일을 한다면, 그리고 이 둘이 서로 직교적이라면, 이 둘의 조합으로 M x N개의 일을 할 수 있음.
- 하지만 서로 직교적이지 않다면, 겹치는 부분이 발생하고, 조합 결과는 더 줄어듦.
- 더 많은 조합을 만들 수 있다면, 더 적은 노력으로 더 많은 결과를 만들어 낼 수 있음.

#### Reduce Risk

- 코드의 병든 부분을 격리할 수 있음. 병든 부분에 의한 영향도 적어지며, 이를 제거하기도 쉬움.
- 시스템이 잘 깨지지 않음. 변경의 영향이 적기 때문.
- 테스트하기에도 좋음.
- 특정 벤더, 제품, 플랫폼과의 결합도가 그리 높지 않음.

### Design

특별한 얘기는 없어서 기록 생략.

### Toolkits and Libraries

- 써드 파티 툴킷이나 라이브러리 도입 시에도 직교성을 고려.
- 이 도구들에 관한 세부사항은 격리 시켜 두어야 함.
- 애노테이션을 선언적으로 명시하거나, 데코레이터 패턴이 적용된 것이 그 예.
- 만약 격리되어 있지 않다면, 도구의 변경이 애플리케이션에 미치는 영향이 상당할 것.

### Coding

개발 할 때 단지 자신이 무엇을 하고 있는지 외에, 애플리케이션의 더 큰 관점도 항상 인지해야 함. 그렇지 않으면 의도치 않게 다른 모듈에 있는 기능/지식을 중복. 아래는 코드에서 직교성을 유지하는 3가지 방법.

1. Keep your code decoupled
    - shy 코드를 작성. 다른 모듈에게 불필요한 어떤 것도 드러내지 않는 것.
    - 디미터 법칙 활용. 어떤 객체의 상태를 바꿔야 한다면 그냥 그 객체에게 시키는 것.
2. Avoid global data
    - 코드가 전역 데이터를 참조한다면, 이 데이터를 공유하는 다른 컴포넌트와 엮이는 것.
    - 데이터가 읽기 전용이더라도 멀티 스레딩 추가 등의 이유로 문제 될 수 있음.
    - 컨텍스트를 담은 객체를 생성하고 인자로 넘기는 것을 권장.
3. Avoid similar functions
    - 때때로 거의 대부분 코드가 비슷한데 가운데 알고리즘만 조금 다른 경우가 있음.
    - 이 때 코드를 중복하는 대신, 전략 패턴 등을 이용.

### Testing

- 단위 테스트의 작성은 일종의 직교성 테스트이기도 함.
- 테스트를 빌드하고 실행하는 데 많은 준비가 필요하지는 않는지?
- 버그 수정 또한 직교성을 평가하는 좋은 기회.
- 문제를 고칠 때 얼마나 변경이 국소화 되는지를 보면 됨.

### Documentation

- 문서 작성에도 직교성이 적용됨.
- 두 개의 축은 내용과 프리젠테이션.
- 워드 프로세서는 이를 위해 스타일 시트와 매크로를 지원함.
- 마크다운의 경우 작성자는 내용에 집중하게 해주고 프리젠테이션은 도구의 렌더링을 이용.

### Living with Orthogonality

- 직교성은 DRY 원칙과 밀접.
- DRY는 시스템의 중복을 줄여주고,
- 직교성은 시스템 컴포넌트 간의 상호의존을 줄여줌.
- 이 둘을 잘 사용하면 시스템이 유연하고 이해하기 쉬우며 디버그/테스트/유지보수에 유리해짐.

## Topic 11. Reversibility

- 대부분의 것은 변하기 마련.
- 그런데 문제는 크리티컬한 결정은 뒤집기 어렵다는 것.
- 특정 벤더사의 DB, 아키텍처 패턴, 배포 모델 등을 한 번 결정하고 나면,
- 큰 비용을 들이지 않고서는 돌이키기 힘든 길을 고수하게 됨.

### Reversibility

- 우리는 처음부터 최선의 선택을 내릴 수 없음.
- 어떤 결정을 고정이라고 간주하고 변동에 대비 않는 것은 실수.
- DRY, 디커플링, 외부 설정 사용 등을 통해,
- 우리는 돌이킬 수 없는 크리티컬한 결정으로부터 자유로울 수 있음.

```
Tip 18) There Are No Final Decisions
```

### Flexible Architecture

- 서버 사이드 아키텍처의 베스트 프랙틱스는 정말 많이 바뀜.
- 우리가 이 변동성을 예측할 수 있을까? X
- 우리가 할 수 있는 것은 바꾸기 쉽게 만들기.
- 써드 파티 API를 추상화 레이어 뒤로 숨겨라.
- 코드를 컴포넌트로 세분화 시켜 두어라(지금은 한 서버로 배포를 한다고 해도).
- 그리고 유행을 따르지 말라고도 조언.

```
Tip 19) Forgo Following Fads
```

## Topic 12. Tracer Bullets

- 복잡하고 시시각각 변하는 세상에서 과녁을 어떻게 명중시킬 수 있는가?
- 심호흡하고 집중해서 단 한 번의 기회로 총알을 발사할 수도 있음.
- 그러나 예광탄<sup>tracer bulllet</sup>으로 조준을 계속 조정해 나갈 수도.
- 실용적인 실시간 피드백을 가리킴.

### Code That Glows in the Dark

- 시스템을 정의하는 중요한 요구사항을 찾아라.
- 의심가거나 리스크가 큰 지점을 찾아라.
- 여기부터 코드를 시작.

```
Tip 20) Use Tracer Bullets to Find the Target
```

- 가장 첫 번째 예광탄은 "hello world!".
- 단순히 프로젝트를 생성한 뒤 이것의 컴파일과 실행 여부를 확인하는 것.
- 다음으로 애플리케이션에서 불확실한 부분을 찾아 스켈레톤을 추가하여 동작 여부 확인.
- 예컨대, 화면에서 사용자 질의를 받아 적절한 SQL로 변환 후 DB로부터 얻어 온 결과를 화면에 잘 출력하는지 먼저 확인.
- 이런 방식의 개발은 프로젝트가 영원히 끝나지 않는다는 아이디어와 맥락을 같이 함.
- 요구사항은 계속 바뀌고 기능은 추가됨. 점진적 접근 방식.
- 이와 대비되는 방식은, 모듈을 여러 개로 나누고 개발한 뒤, 이들을 조립하여 어느날 짠 하고 전체를 완성시키는 방식.
- 예광탄 방식의 장점은 첫 째로, 사용자들이 동작하는 무언가를 빠르게 볼 수 있다는 것.
- 진행 과정을 볼 수 있고, 서로 피드백을 주고 받으며 기여할 수 있음.
- 또한 나아가고 있다는 좋은 느낌을 받을 수도.

### Tracer Bullets Don't Always Hit Their Target

- 예광탄은 우리가 무엇을 맞추고 있는지 보여줌.
- 항상 타깃을 맞출 수 있는 것은 아님.
- 하지만 타깃에 맞을 때까지 조정할 수 있음.
- 이는 코드에서도 마찬가지.
- 처음 선택한 기술이 100% 상황에 맞는지 알 수 없을 수도.
- 그러면 목표에 맞게 계속 조정해 나가면 됨.

### Tracer Code versus Prototyping

- 프로토타이핑과 같다고 느낄 수도 있겠으나 차이점이 있음.
- 프로토타입은 결과로부터 교훈을 얻은 뒤 다시 시작함.
- 예광탄 코드 접근법에서는 이렇게 얻어진 결과물을 토대로 점진적으로 확장해 나감.
- 버리는 코드가 아니라 최종 시스템의 뼈대가 됨.

## Topic 13. Prototypes ans Post-it Notes

- 프로토타이핑은 완전한 규모의 제품에 비해 저렴.
- 그러면서 아이디어를 확인하고 불확실성을 줄여 나감.
- 이런 프로토타이핑을 코드에 한정해서 생각할 필요는 없음.
- 포스트잇 노트는 애플리케이션 로직이나 작업 흐름 같이 동적인 것을 포로토타이핑 하는 데 매우 훌륭.
- 칠판을 통해 사용자 인터페이스를 그려볼 수도 있음.
- 그런데 만약 세부사항을 포기할 수 없는 환경이라면 프로토타입 대신 예광탄 스타일 개발을 고려.

### Things to Prototype

- 리스크가 있거나, 시도해 본 적 없거나, 최종 시스템에 있어 매우 중요한 부분이거나, ...
- 아키텍처, 기존 시스템에 새로운 기능, 외부 데이터의 구조나 내용, 써드 파티 도구 등을 프로토타입핑.
- 배움의 경험. 이 가치는 만들어진 코드 그 자체가 아니라, 과정에서 배운 것에 있음.

```
Tip 21) Prototype to Learn
```

### How to Use Prototypes

프로토타이핑 시 무시해야 하는 세부 사항들.

- 정확성<sup>correctness</sup>
- 완전성<sup>completness</sup>
- 강건함<sup>robustness</sup>
- 스타일<sup>style</sup>

대신, 고려하고 있는 시스템의 특정 관심사에 집중해야 함.

### How Not to Use Prototypes

- 시작에 앞서 지금 작성하는 코드가 버려질 것임을 모두에게 명확히 이해시킬 것.
- 만약 그럴 수 없는 상황이라면 예광탄 방식을 고려.

## Topic 14. Domain Languages

```
Tip 22) Program Close to the Problem Domain
```

- 우리는 애플리케이션의 도메인 용어들을 이용해서 코드를 작성하려 노력.
- 나아가면 문법과 시멘틱도 도메인의 것을 사용.
- sytanx와 semantics의 차이는 [여기](https://stackoverflow.com/questions/17930267/what-is-the-difference-between-syntax-and-semantics-in-programming-languages) 참고.

### Some Real-World Domain Languages

책에서는 RSpec, Cucumber, Phoenix Routes, Ansible을 예로 들고 있음. 익숙치 않은 Phoenix Routes 코드만 기록.

```ruby
scope "/", HelloPhoenix do
    pipe_through :browser # Use the default browser stack

    get "/", PageController, :index
    resources "/users", UserController
end
```

### Characteristics of Domain Languages

- RSpec과 Phoenix 라우터는 호스트 언어(ruby, elixir)로 작성됨.
- 이들은 메타프로그래밍과 매크로를 사용하긴 하지만(책에서 이를 devious 코드라 표현),
- 궁극적으로는 보통의 코드처럼 컴파일 되고 실행됨.
- Cucumber 테스트와 Ansible 설정은 자신만의 언어로 작성됨.
- Cucumber 테스트는 실행될 코드나 데이터구조체로 변환되고,
- Ansible은 언제나 데이터 구조체로 변환됨.
- 참고로 RSpec과 라우터는 내부 도메인 언어의 예시이고,
- Cucumber와 Ansible은 외부 언어를 사용.

### Trade-Offs Between Internal and External Languages

- 내부 도메인 언어는 호스트 언어의 장점을 그대로 취할 수 있음.
- 하지만, 호스트 언어의 한계도 그대로 가져감. 문법을 지켜야 하는 것이 그 예.
- 한편, 외부 언어 사용에는 이런 제한이 없음.
- 언어에 대한 파서를 작성하기만 하면 무엇이든 괜찮음.
- 이런 작업이 간단하지는 않을 수도 있다는 게 단점.
- 절약되는 시간 보다 더 많은 노력을 쏟지 않기를 권장.
- 그래서 가능한 외부 언어로는 YAML, JSON, CSV 같은 기성품을 사용.
- 그럴 수 없다면 내부 언어를 살펴보라.

### An Internal Domain Language on the Cheap

- 너무 많은 메타프로그래밍을 하지 말라고 권고.
- 대신, 그냥 그 일을 하는 함수를 작성하라고.
- RSpec의 경우 `describe`, `it`, `expect`, `to`, `eq` 같은 루비 메서드를 그대로 사용.

## Topic 15. Estimating

- 추정하는 법을 배우면, 아래 요구의 가능성을 알아볼 수 있음.
- "우리는 네트워크를 통해 S3로 백업을 전송할거에요"

```
Tip 23) Estimate to Avoid Surprises
```

### How Accurate Is Accurate Enough?

- 추정을 하기에 앞서 질문의 맥락을 이해해야 함.
- 질문이 높은 정확성을 필요로 하느냐, 아니면 대략적 수치로 되느냐.
- 한 가지 흥미로운 것은 어떤 단위를 사용하는지에 따라 결과의 해석에 차이가 생김.
- 130 근무일이 필요하다고 하면, 사람들은 이것이 정확한 수치라고 생각.
- 대략 6개월이 필요하다고 하면 5-7개월로 해석함.
- 둘 다 같은 기간이고 단위만 다름.
- 전달하려는 의도에 부합하는 단위를 선택.

### Where Do Estimates Come From?

- 모든 추정은 문제의 모델을 기반으로 함.
- 자세한 얘기를 하기에 앞서, 가장 기본이 되는 추정의 비결을 언급.
- "ask someone who's already done it"
- 과거에 비슷한 경험을 한 사람이 없는지 찾고, 문제를 어떻게 해결했는지 볼 것.

#### Understand What's Being Asked

- 추정의 가장 처음은 질문을 이해하는 것.
- 위에서 다뤘던 정확성 이슈에 더해,
- 도메인의 범위를 이해해야 함.
- 이 범위는 종종 질문의 답을 구성하는 요소가 됨.
- "교통 체증이 없고, 차에 충분한 연료가 있다면, 거기 가는데 20분이면 충분해요."

#### Build a Model of the System

- 임시변통의 아주 기본적인<sup>rough-and-ready bare-bones</sup> 모델을 만들어라.
- 문제를 좀 더 쉽게 접근할 수 있게 돕는 도구.
- 모델을 만들면 정확성은 떨어짐. 대신 단순함을 얻는 트레이드 오프.
- 정확성을 높이려는 노력을 2배로 하더라도, 정확성은 아주 조금만 올라갈 뿐임에 유의.

#### Break the Model into Components

- 일단 모델을 얻었으면, 이를 좀 더 작은 구성요소로 분해.
- 이 구성요소들 간 상호작용을 표현하는 수학적 규칙을 발견해야 함.
- 어떤 요소는 단지 결과 값에 더해질 뿐이고, 어떤 것은 곱셈 요소가 되는 등 다양.
- 이런 식으로 결과에 영향을 주는 매개변수를 식별.

#### Give Each Parameter a Value

- 매개변수까지 식별했다면, 각각에 값을 할당.
- 곱셈 요소 같이 결과에 큰 영향을 주는 값들이 있음.
- 이 값을 잘 추정(subestimate)하여 오류를 줄일 수 있음.

#### Calculate the Answers

- 답이 하나만 나오는 경우는 드묾.
- 여러 번 계산하고, 중요 파라미터 값을 계속 조정해 보며,
- (스프레드시트 같은 것이 도움이 됨)
- 어느 것이 모델을 이끌어 가는지 파악.
- 주요 파라미터는 답변에도 녹임.
- "시스템이 만약 SSD와 32GB 메모리를 가진다면 응답 시간은 대략 3/4초가 될 것이고, 16GB라면 1초 정도가 됩니다."
- 계산 과정에서 도출된 답이 이상하게 느껴질 때도 있음.
- 계산이 정확했다면 우리가 문제를 잘못 이해하고 있는 것일 수도 있으며 중요한 정보가 됨.

#### Keep Track of Your Estimating Prowess

- 추정치를 기록해 두는 것은 나중에 얼마나 근접했는지 확인할 때 좋음.
- 전체 추정치가 세부 추정치들의 종합이라면 이들 역시 기록해 두자.
- 의외로 추정치가 정확하다는 것을 발견.
- 혹 틀렸더라도 피드백으로 여기고 오답 이유를 분석.
- 모델이 잘못된 건지, 파라미터를 잘못 선정한 건지.

### Estimating Project Schedules

- 얼마나 걸릴 것이냐는 질문을 많이 받음.
- 추정의 불확실성을 줄이는 2가지 방법을 이야기.

#### Painting the Missile

- 아래는 집 페인트 칠에 걸리는 시간.

> “Well, if everything goes right, and this paint has the coverage they claim, it might be as few as 10 hours. But that's unlikely: I'd guess a more realistic figure is closer to 18 hours. And, of course, if the weather turns bad, that could push it out to 30 or more.”

- 보통은 이런 식으로 여러 숫자를 시나리오에 따라 제시.
- 미국 해군은 PERT(Program Evaluation Review Technique)를 사용.
- 낙관적, 그리고 비관적 추정을 함께 가져가는 것.
- 범위 값을 통해 추정이 갖는 불확실성을 드러낼 수 있음.

#### Eating the Elephant

- 첫 기능을 코딩하고 테스트 끝낸 뒤 이를 첫 번째 이터레이션으로 지정.
- 이를 기반으로 각 이터레이션에 걸릴 시간을 측정하고, 이터레이션은 몇 개가 될지를 결정.
- 매 이터레이션마다 지난 이터레이션의 결과를 반영해서 정확도를 꾸준히 조정.
- 코끼리를 한 번에 한 입씩 먹으라는 오래된 농담에 비유.

```
Tip 24) Iterate the Schedule with the Code
```

### What to Say When Asked for an Estimate

- "금방 올께요"
- 바로 답변하기 보다는 어느 정도 시간을 갖고,
- 위에서 언급한 단계들을 밟아간다면 좋은 결과를 얻을 수도.

# Chapter 4. Pragmatic Paranoia

```
Tip 36) You Can't Write Perfect Software
```

- 완벽한 소프트웨어 만들기는 불가능.
- 이를 오히려 받아들이고 기회로 활용하라는 이야기.
- 우리는 보통 다른 사람의 코드를 믿지 않아야 하며,
- 따라서 DB 제약 설정, 입력값 검증, 단언문을 통한 상태 확인 등을 함.
- 실용주의 프로그래머는 여기서 더 나아가, 자기 자신도 믿지 않음.
- 완벽한 코드를 작성할 수 있는 사람은 없다는 것을,
- 자신에게도 적용시키며 실수를 대비하기 위한 노력들을 함.

## Topic 23. Design by Contract

- 계약은 우리의 권리와 책임을 정의.
- 여기에는 계약이 지켜지지 않았을 때에 대한 약속도 포함.
- 인간의 상호작용을 돕는 기본적 도구 중 하나.
- 이는 소프트웨어 모듈에도 적용될 수 있음.

### DBC

Eiffel 언어에서의 DBC 개념 이야기.

- Bertrand Meyer가 개발.
- 프로그램의 정확성을 보장하고자,
- 소프트웨어 모듈의 권리와 책임을 명시하는 기법.
- 그런데 무엇이 정확한 것인가?
- 명시된 것보다 덜 하지도 더 하지도 않는 것.
- 요구<sup>claim</sup>를 문서화하고 검증하는 것이 DBC의 핵심.

모든 함수/메서드는 무언가를 하기에 앞서, 현재 세상의 상태에 대한 기대를 갖고 있음. Meyer는 이런 기대와 요구를 아래와 같이 설명.

- Preconditions
  - 루틴이 실행되기 전에 참이어야 하는 것.
  - 이것이 거짓이면 루틴은 실행되지 않음.
  - 좋은 데이터를 넘겨주는 것은 호출자의 책임.
- Postconditions
  - 루틴이 보장해야 하는 실행 결과.
  - 루틴에 사후조건이 있다는 것은 무한 루프가 허용되지 않음을 의미.
- Class invariants
  - 클래스가 호출자의 관점에서 항상 참임을 보장해줘야 하는 것.
  - 루틴의 내부 처리 동안은 불변이 유지되지 않을 수 있지만,
  - 루틴이 종료되어 호출자에게 제어권이 넘어갈 때는 항상 참이어야 함.
  - 어떤 객체의 잔고가 항상 0 이상인 상태를 유지하는 것이 한 예가 아닐까.

아래와 같이 표현하기도.

> 모든 루틴의 선행조건이 호출자에 의해 만족된다면, 루틴은 자신의 완료 시점에 모든 사후조건과 불변을 보장.

아래는 Clojure 언어에서 specs라는 걸 이용해 선행/사후조건을 적용하는 예시.

```clojure
(defn accept-deposit [account-id amount]
    { :pre  [ (> amount 0.00)
              (account-open? account-id) ]
      :post [ (contains? (account-transactions account-id) %) ] }
    "Accept a deposit and return the new transaction id"
    ;; Some other processing goes here...
    ;; Return the newly created transaction:
    (create-transaction account-id :deposit amount))
```

여기에 입력 갑으로 음수가 들어간다면 아래와 같은 런타임 예외 발생.

```
Exception in thread "main"...
Caused by: java.lang.AssertionError:
Assert failed: (> amount 0.0)
```

마지막으로 10번째 주제였던 직교성과 비교.

- 직교성에서는 코드를 "부끄럽게<sup>shy</sup>" 작성하라고 했음.
- 여기서는 코드를 "게으르게<sup>lazy</sup>" 작성하길 권장.
- 시작하기에 앞서 받아들이는 것에 엄격해야 하고,
- 반환 값으로는 가능한 적은 것을 약속.

```
Tip 37) Design with Contracts
```

#### Class Invariants and Functional Languages

- 이는 네이밍에 관한 것.
- Eiffel은 객체지향 언어라서 "클래스 불변"이라고 명명.
- 하지만 실은 좀 더 넓은 범위의 개념이며, 상태<sup>state</sup>에 가까움.
- 객체지향 언어에서 상태는 클래스의 인스턴스에 연관됨.
- 함수형 언어에서는, 상태를 함수에 넘겨주고, 바뀐 상태를 반환.
- 불변 개념은 이런 환경에서도 유용함.

### Implementing DBC

아래의 것들을 생각하지 않는 코드 작성은 "우연에 의한 프로그래밍<sup>programming by coincidence</sup>".

- 입력 도메인 범위가 어떻게 되나?
- 경계 조건은 무엇인가?
- 루틴이 무엇을 해야 하나?
- (좀 더 중요한 것으로는) 루틴이 무엇을 하지 말아야 하나?

DBC를 코드적으로 지원하지 않는 언어라고 해도 괜찮음. 이는 그저 설계 기법.

#### Assertions

- 가정들을 문서화하는 것도 좋은 출발.
- 하지만 이를 컴파일러가 검사하게 하면 더 큰 이득.
- 단언을 통해 부분적으로 DBC 구현이 가능.
- 부분적이라는 이유는,
- DBC에서의 상속도 어렵고,
- try-catch를 통해 예외를 무시하거나,
- 글로벌 설정 등을 통해 예외가 안 일어나게 할 수도 있으며,
- old 표현식도 없고,
- 런타임 시스템이나 라이브러리 호출에도 검사를 넣기 어려움.

### DBC and Crashing Early

- DBC를 이용하면 충돌을 일찍 일으킬 수 있고,
- 문제에 관해 좀 더 정확한 정보를 보고할 수 있음.
- `sqrt` 메서드에 음수 파라미터를 넣는 경우를 예로 들어보자.
- DBC에서는 `sqrt_arg_must_be_positive`라는 에러를 스택 트레이스와 함께 제공.
- 하지만 만약 이런 검사 없이 `NaN`을 반환한다면,
- 이 값을 가지고 무언가를 시도하는 곳에서 문제가 일어남.
- 문제 원인을 분석하기가 좀 더 어려워지는 것.

### Semantic Invariants

- 어기지 않아야 하는 요구사항을 표현하기 위해, 시멘틱 불변<sup>semantic invariants</sup>을 사용.
- 그런데 이 규칙은 바뀌지 않는 근본적인 것을 나타냄.
- 사용자 신용 카드 결제의 경우, 1개의 결제가 계좌에 중복으로 적용되면 안 되는 규칙이 있을 수 있음.
- 이런 경우 시멘틱 불변을 아래와 같이 선언.

> Err in favor of the consumer

### Dynamic Contracts and Agents

딱히 기록할 내용 없음.

## Topic 24. Dead Programs Tell No Lies

- 에러가 났음을 부정하거나 무시하는 경우가 있음.
- 하지만 실용주의 프로그래머는 에러가 있을 수 있음을 받아들일 줄 앎.
- 에러는 우리에게 정보를 가져다 줌.

### Catch and Release Is for Fish

예외를 잡고 메시지를 남긴 뒤 다시 예외를 던지는 경우가 있음.

```rb
try do
    add_score_to_board(score);
rescue InvalidScore
    Logger.error("Can't add invalid score. Exiting");
    raise
rescue BoardServerDown
    Logger.error("Can't add score: board is down. Exiting");
    raise
rescue StaleTransaction
    Logger.error("Can't add score: stale transaction. Exiting");
    raise
end
```

하지만, 실용주의 프로그래머는 아래와 같이 함.

```rb
add_score_to_board(score);
```

이렇게 하는 이유는 2가지.

1. 에러 핸들링으로 애플리케이션 코드를 흐리게 하지 않음.
2. (더 중요) 코드가 덜 커플링 되어 있음.
    - 첫 번째 예시에서는 메서드가 일으킬 수 있는 모든 예외가 나열됨. 
    - 작성자가 예외를 추가한다면 같이 반영 못 할 수도.
    - 두 번째 예시에서는 예외가 자동으로 전파됨.

```
Tip 38) Crash Early
```

### Crash, Don't Trash

- 문제를 가능한 빨리 감지하는 것의 이점은,
- 좀 더 빨리 충돌시킬 수 있다는 것.
- 충돌은 종종 우리에게 있어 최선의 선택.
- Erlang 창시자인 Joe Armstrong은 아래와 같이 말함.

> Defensive programming is a waste of time. Let it crash!

- 프로그램은 실패하도록 설계하되,
- 이런 실패를 감독관<sup>supervisor</sup>이 관리.
- 감독관은 코드를 실행할 책임이 있고,
- 코드가 실패했을 때 무엇을 해야 하는지를 알고 있음.
- 재시작이나 뒷정리 등이 그 예.
- 감독관이 실패할 수도 있으니 감독관 트리를 구성.

감독관 얘기는 좀 와닿지 않음. 그냥, 빠른 실패가 더 좋은 건 아닐지, 실패가 발견됐을 때 더 이상 진행하지 않는 것이 좋은 선택은 아닐지 고민해 보면 될 것.

## Topic 25. Assertive Programming

```
Tip 39) Use Assertions to Prevent the Impossible
```

- 일어나지 않을 일은 단정문을 통해 확인.
- 자바에서는 설명적 문자열과 함께 assert 가능.
- 단정문을 실제 에러 핸들링에는 사용 X.

```java
assert result != null && result.size() > 0 : "Empty result from XYZ";
```

- 그런데 자바의 경우 `-ea` JVM 옵션이 있어야 assert 실행됨.
- 기본은 실행되지 않음이기에, 개인이나 동료에겐 대부분 무시되는 문장일 것.
- 하지만 코드로 추가 되어 있으니, 읽거나 변경 시 항상 약간의 비용을 더해줄 것이고,
- 이런 것들이 여러 개 쌓여 있을 때, 비용 대비 얼마나 이득인지 개인적으로 의문.

### Assertions and Side Effects

- [Heisenbug](https://en.wikipedia.org/wiki/Heisenbug) 이야기.
- 단정문을 만들다가 오히려 단정문에 버그가 있을 수 있으니 조심하라는.
- 예컨대 아래 코드.

```java
while (iter.hasMoreElements()) {
    assert(iter.nextElement() != null);
    var obj = iter.nextElement();
    // ...
}
```

### Leave Assertions Turned On

- 위 내용들이 의미 있으려면, 이 얘기가 빠질 수 없음.
- 일단, 아래 이야기는 단정문에 대한 흔한 오해라고 함.

> Assertions add some overhead to code. Because they check for things that should never happen, they'll get triggered only by a bug in the code. Once the code has been tested and shipped, they are no longer needed, and should be turned off to make the code run faster. Assertions are a debugging facility.

- 여기에는 2가지 잘못된 가정이 들어 있음.
- 첫째로, 테스트가 모든 버그를 발견한다고 생각.
- 둘째로, 실제 프로덕션 환경에서도 예상 가능한 일만 일어남.
- 따라서 프로덕션에서도 단정문을 활용하여,
- 예상치 못한 문제를 fail-fast 시키고,
- 문제가 있을 때 좀 더 빠르게 문제를 찾아가길.

## Topic 26. How to Balance Resources

- 우리는 코드를 작성할 때면 언제나 리소스를 관리함.
- 메모리, 트랜잭션, 스레드, 네트워크 연결, 파일, 타이머, ...
- 이들은 모두 제한된 가용성을 가짐.
- 대부분의 경우 아래의 사용성 패턴을 가짐.
- 리소스를 할당하고, 사용하고, 할당을 다시 해제.

```
Tip 40) Finish What You Start
```

```rb
def read_customer
    @customer_file = File.open(@name + ".rec", "r+")
    @balance       = BigDecimal(@customer_file.gets)
end

def write_customer
    @customer_file.rewind
    @customer_file.puts @balance.to_s
    @customer_file.close
end

def update_customer(transaction_amount)
    read_customer
    @balance = @balance.add(transaction_amount,2)
    write_customer
end
```

- 위 코드에서 몇 가지 문제가 있음.
- 일단, `read_customer`와 `write_customer`가 지나치게 커플링.
- 이 둘은 `customer_file` 인스턴스 변수를 공유함.
- 만약, 요구사항 변경으로 `update_customer`가 아래와 같이 바뀐다면?

```rb
def update_customer(transaction_amount)
    read_customer
    if (transaction_amount >= 0.00)
        @balance = @balance.add(transaction_amount,2)
        write_customer
    end
end
```

- 여기서도 `else` 문을 추가하여 직접 `close`를 호출해 줄 수도 있으나,
- 한 번에 한 곳이 아니라 여러 곳을 함께 살피며 고쳐나가야 하는 근본적 문제는 여전함.
- 그래서 아래와 같이 변경.

```rb
def read_customer(file)
    @balance=BigDecimal(file.gets)
end

def write_customer(file)
    file.rewind
    file.puts @balance.to_s
end

def update_customer(transaction_amount)
    file=File.open(@name + ".rec", "r+")          # >--
    read_customer(file)                           #    |
    @balance = @balance.add(transaction_amount,2) #    |
    file.close                                    # <--
end
```

- 여기서 좀 더 나아갈 수 있음.
- 리소스의 생명주기 스코프를 블럭 단위로 제한하는 것.
- 블럭이 끝나면서 `file` 변수는 끝나고,
- 외부 파일은 닫힘(일일이 수동으로 닫는 게 아니라 자동으로 닫아줌).
- 이런 식으로 범위를 제한해 주는 것은 언제나 도움이 됨.

```rb
def update_customer(transaction_amount)
    File.open(@name + ".rec", "r+") do |file|         # >--
        read_customer(file)                           #    |
        @balance = @balance.add(transaction_amount,2) #    |
        write_customer(file)                          #    |
    end                                               # <--
end
```

```
Tip 41) Act Locally
```

### Nest Allocations

- 한 번에 여러 리소스를 관리하는 방법에 대한 이야기.
- 여기에는 2가지 제안이 있다고 함.
- 첫 번째로, 고아 리소스가 생기지 않도록, 할당된 순서와 반대로 할당 해제.
- 두 번째로, 서로 다른 코드 부분에서 같은 리소스들을 할당한다면, 데드락을 피하고자, 항상 같은 순서로 할당.

### Objects and Exceptions

- 할당과 해제는 객체 지향 클래스의 생성자<sup>constructor</sup>와 소멸자<sup>destructor</sup>를 생각나게 함.
- 리소스를 클래스 안에 캡슐화하면 유용.
- 특정 리소스가 필요하면 관련 클래스의 객체를 생성하고,
- 이 객체가 스코프를 벗어나면 GC에 의해 처리되며 객체 소멸자가 리소스를 해제.
- 예외가 리소스 해제를 방해하는 언어에서 특히 유용하다고 함.

### Balancing and Exceptions

예외가 발생할 때의 리소스 해제는 보통 아래의 2가지 방법 중 하나.

1. 변수 스코프 사용 (C++나 Rust에서의 스택 변수)
2. `try...catch` 블럭에서 `finally` 절 사용

그 중에서 아래는 Rust 예제.

```rust
{
    let mut accounts = File::open("mydata.txt")?; // >--
    // use 'accounts'                             //    |
    ...                                           //    |
}                                                 // <--
// 'accounts' is now out of scope, and the file is
// automatically closed
```

#### An Exception Antipattern

```
begin
    thing = allocate_resource()
    process(thing)
finally
    deallocate(thing)
end
```

- 무엇이 잘못됐을까?
- 만약 리소스 할당이 실패하고 예외가 발생한다면?
- `finally` 절이 실행되고 할당도 되지 않은 리소스를 해제하려 함.
- 아래와 같이 해야 함.

```
thing = allocate_resource()
begin
    process(thing)
finally
    deallocate(thing)
end
```

### Checking the Balance

- 리소스가 실제로 잘 해제 됐는지를 확인하는 것이 좋음.
- 이를 위한 간단한 이야기 2가지를 함.

## Topic 27. Don't Outrun Your Headlights

```
Tip 42) Take Small Steps—Always
```

- 소프트웨어 개발에서 너무 먼 미래는 예측할 수 없음.
- 항상 작고 신중한 스텝을 밟아야 함.
- 피드백을 얻고 계속 조정하며 앞으로 전진.
- 피드백은 단위 테스트나, 데모, 대화 등 다양.
- "너무 큰" 작업이나 스텝은 X.
- 여기서 "너무 큰"이라 함은 점치기<sup>fortune telling</sup>가 필요한 것.
- 예를 들면 아래의 것들.
    - 완료하는 데 몇 개월이 걸릴 것으로 추정.
    - 미래의 유지보수나 확장성을 설계할 계획.
    - 사용자의 미래 요구를 추측.
    - 미래의 기술적 가용성을 추측.
- 물론 이것들 중에서도 충분히 예상 가능한 미래라면 "너무 큰"이 아님.
- 미래가 어떨 것이라고 더 많이 예측할수록, 더 많은 리스크를 감수.
- 불활실한 미래를 설계하는 데 시간을 쏟지 말고,
- 언제든 대체 가능한 코드를 작성하라.
- 대체가능함을 위해선 물론 응집성, 결합도, DRY 등의 고민 필요.

> Instead of wasting effort designing for an uncertain future, you can always fall back on designing your code to be replaceable.

### Black Swans

- 역사상 중요했던 사건들은 예측하기 힘들고 드물게 일어났지만,
- 우리의 일상에 큰 영향을 미쳤다는 블랙 스완 이야기.
- 소프트웨어에서도 마찬가지.

```
Tip 43) Avoid Fortune-Telling
```

# Chapter 5. Bend, or Break

- 오늘날의 변화 속도를 따라가기 위해,
- 코드는 가능한 느슨하게(유연하게) 작성해야 함.
- 그렇지 않으면 코드는 금방 낡아 버리고 고치기 어려워짐.

## Topic 28. Decoupling

커플링은 변경의 적.

- 'Topic 8. The Essence of Good Design'에서,
- 변경하기 쉬운 코드를 작성하는 것이 좋은 디자인 설계라고 했음.
- 커플링은 함께 변경해야 하는 것들을 늘림.
- 함께 변경해야 하는 것들을 모두 추적하거나,
- 무언가를 변경했을 때 망가지는 것들의 원인을 파악하는 것은 어려운 일.
- 커플링이 이행적<sup>transitive</sup>라는 이야기도 함.
- `A -> B -> C -> D -> E`에서 A는 결국 E에게도 의존하는 것.

```
Tip 44) Decoupled Code Is Easier to Change
```

코드 디커플링을 위해 필요한 것들.

- Train wrecks - 메서드 호출 체인
- Globalization - 정적 자원들의 위험
- Inheritance - 상속이 왜 위험한지

아래는 커플링의 신호들.

- 관련 없는 모듈이나 라이브러리들끼리의 이상한 의존성
- 한 모듈의 "간단한" 변경이 관련 없는 모듈로 퍼져나가거나 어딘가를 깨뜨림
- 어디에 영향을 줄지 몰라 변경을 꺼리는 개발자
- 변경의 영향을 모르기에 회의에 모든 사람이 들어와야 함

### Train Wrecks

```java
public void applyDiscount(customer, order_id, discount) {
    totals = customer
            .orders
            .find(order_id)
            .getTotals();
    totals.grandTotal = totals.grandTotal - discount;
    totals.discount   = discount;
}
```

- 너무 많은 세부사항이 노출되어 있음.
- 만약, 어떤 주문도 40% 이상 할인하면 안 된다는 요구사항이 들어온다면?
- 여기 외에도 `totals`의 모든 세터를 확인해야 함.

```
Tip 45) Tell, Don't Ask
```

- 합계를 다루는 책임은 `totals` 객체에 있어야 함.
- 묻지 말고 말해야 함(TDA: Tell, Don't Ask).
- 대상의 내부 상태에 기반해서 대상의 행위를 결정하지 말고,
- 내부 상태와 행위 세부 내용 모두 대상 객체에게 맡기라는 것.
- 이런 캡슐화를 통해 지식이 코드 전체에 산재하는 것을 막을 수 있음.
- 코드를 바꾸면 아래와 같은 모습.

```java
public void applyDiscount(customer, order_id, discount) {
    customer
        .orders
        .find(order_id)
        .getTotals()
        .applyDiscount(discount);
}
```

- 같은 원리를 `customer` 객체에도 적용시킬 수 있음.
- `order`에 대해서도 마찬가지.

```java
// customer TDA
public void applyDiscount(customer, order_id, discount) {
    customer
        .findOrder(order_id)
        .getTotals()
        .applyDiscount(discount);
}

// order TDA
public void applyDiscount(customer, order_id, discount) {
    customer
        .findOrder(order_id)
        .applyDiscount(discount);
}
```

- 여기서 잠깐.
- `custoemr`에 `applyDiscountToOrder(order_id)`를 추가할 순 없을까?
- 무조건 TDA 적용은 X.
- 이런 근거로 저자는 지금 모습이 편안하고 실용적이라고 함.
- 개인적으로는 편안함 때문이라면 그 기준이 개인 별로 천차만별이라 위험하고,
- 실용적이라는 것은 결론을 근거로 들고 있는 모순.
- 고객은 주문 없이도 살아갈 수 있음.
- 한편, 고객이 주문을 알아야 한다면,
- 고객이 의존하는 객체들은 어마어마하게 많을 것.
- 주문이 바뀔 때마다, 또는 다른 의존 객체들이 바뀔 때마다, 고객이 영향 받음.
- 그래서 아래와 같은 방식이 좀 더 변경을 국소화 해준다고 생각.

```java
public void applyDiscount(customer, order_id, discount) {
    orderRepository
        .find(customer.id, order_id)
        .ifPresent(o -> o.applyDiscount(discount));
}
```

#### The Law of Demeter

```
Tip 46) Don't Chain Method Calls
```

- 무언가에 접근할 때 1개 이상의 "."을 사용하지 않는 것을 권장.
- 물론, 거의 바뀌지 않는 곳이라면 상관 없음.
- 예컨대, 아래처럼 언어 차원에서 제공해 주는 것.
- 1판을 작성한 후로 20년이 지났지만 아래 체이닝에 변경은 없었음.

```rb
people
    .sort_by {|person| person.age }
    .first(10)
    .map {| person | person.name }
```

#### Chains and Pipeline

- 함수를 파이프라인으로 조합하기도 함.
- 이는 train wreck 아님.
- 숨겨져야 하는 구현 세부사항에 의존하는 것이 아니기에.
- 물론 파이프라인은 커플링을 가져옴.
- 하지만 목적은 변경하기 쉬운 것.

### The Evils of Globalization

- 전역적으로 접근 가능한 데이터는 애플리케이션 컴포넌트 간 커플링을 퍼뜨리는 원천.
- 애플리케이션의 모든 메서드가 갑자기 추가적 파라미터를 같는 것과 같음.
- 코드를 재사용 가능하게 만들면 도움이 됨.
- 인터페이스가 명확해지고, 다른 코드 부분과 디커플링 됨.
- 그런데 전역 데이터는 이런 구분을 어렵게 만듦.
- 단위 테스트를 작성할 때 이 문제가 종종 드러나곤 함.
- 겉으로 보기엔 드러나지 않는 환경을 미리 마련해야 함.

```
Tip 47) Avoid Global Data
```

#### Global Data Includes Singletons

- 싱글톤 역시 전역 데이터. 단지 이름이 길 뿐.
- 이런 경우 `Config.log_level` 보다는,
- `Config.log_level()`이나 `Config.getLogLevel()`을 사용하는 것이 좀 더 나음.

#### Global Data Includes External Resources

- 변할 수 있는<sup>mutable</sup> 외부 리소스 역시 전역 데이터.
- 데이터베이스, 데이터 저장소, 파일 시스템, 서비스 API 등이 이에 해당.
- 이들을 다룰 때 역시 리소스를 감싸서 제어권을 제한해야 함.

```
Tip 48) If It's Important Enough to Be Global, Wrap It in an API
```

### Inheritance Adds Coupling

상속 역시 뒤에서 다루겠지만, 상속의 오용 역시 커플링으로 이어짐.

### Again, It's All About Change

- 커플링 된 코드는 변경하기 어려움.
- 한 곳에서의 변경이 코드 어딘가에 영향을 줄 수 있음.
- 그리고 이 영향을 찾기 어려움.
- 한달 후 프로덕션에서 찾게 될 수도.
- 코드를 부끄럽게 유지하라.
- 직접적으로 아는 이들만 그것을 다루게 하라.
- 이렇게 하면 커플링을 줄여줄 것이고, 변경하기 더 쉬움.

## Topic 29. Juggling the Real World

- 끊임없이 뭔가 일어나고 움직이는 복잡한 세상에 잘 통합되고자,
- 반응적 애플리케이션을 만드는 방법에 대한 이야기.

### Events

- 이벤트는 정보 가용성<sup>availability of information</sup>을 나타냄(무슨말이지).
- 외부 세상에서 오기도 하고, 내부 연산의 결과이기도 함.
- 리스트에서 다음 요소를 읽어들이는 것도 이벤트라고 할 수 있음.
- 이런 이벤트에 반응하는 애플리케이션을 만들면,
- 사용자 입장에서는 더 상호작용적이고,
- 애플리케이션은 리소스를 좀 더 효율적으로 사용.
- 이를 위한 방법 4가지를 차례로 살펴볼 예정.

### Finite State Machines

- FSM(Finite State Machine)은 몇 줄만의 구현으로,
- 잠재적 혼란을 피할 수 있게 도와줌.
- FSM을 사용하는 것은 쉬운 일이지만,
- 많은 개발자들의 오해로 멀리하는 듯 함.

#### The Anatomy of a Pragmatic FSM

- 상태 머신은 기본적으로 이벤트를 어떻게 다룰 것인지에 대한 명세.
- 몇 개의 상태로 구성되며, 이 중 하나는 현재 상태를 가리킴.
- 각 상태 별로 중요한 이벤트들을 명시하고,
- 이벤트 마다 시스템의 새로운 상태를 정의.

![FSM example](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780135956977/files/images/events_simple_fsm.png)

- FSM에 관해 한 가지 흥미로운 것은 FSM을 아래와 같이 표로 나타낼 수 있다는 것.

|         | Header  | Data    | Trailer | Other |
|---------|---------|---------|---------|-------|
| Initial | Reading | Error   | Error   | Error |
| Reading | Error   | Reading | Done    | Error |

- 이를 코드로 나타내면 아래와 같음.

```rb
TRANSITION = {
    initial: {header: :reading},
    reading: {data: :reading, trailer: :done},
}

state = :initial

while state != :done && state != :error
    msg = get_next_message()
    state = TRANSITIONS[state][msg.msg_type] || :error
end
```

#### Adding Actions

- 앞에서 살펴본 순수 FSM은 이벤트 스트림 파서임.
- 유일한 출력값이 최종 상태.
- 특정 전이<sup>transition</sup>마다 트리거 되는 행위를 추가할 수 있음.
- 아래는 문자열을 읽어 들이는 상태 당이어그램과 코드.
- 상태와 액션을 표로 나타낼 수 있는데, 이를 코드에도 그대로 드러냄에 주목.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780135956977/files/images/event_string_fsm.png)

```rb
TRANSITIONS = {

    #   current       new state         action to take
    # ---------------------------------------------------------
    
    look_for_string: {
        '"'      => [ :in_string,       :start_new_string ],
        :default => [ :look_for_string, :ignore ],
    },

    in_string: {
        '"'      => [ :look_for_string, :finish_current_string ],
        '\\'     => [ :copy_next_char,  :add_current_to_string ],
        :default => [ :in_string,       :add_current_to_string ],
    },

    copy_nex_char: {
        :default => [ :in_string,       :add_current_to_string ],
    },
}

state = :look_for_string
result = []

while ch = STDIN.getc
    state, action = TRANSITIONS[state][ch] || TRANSITIONS[state][:default]
    case action
    when :ignore
    when :start_new_string
        result = []
    when :add_current_to_string
        result << ch
    when :finish_current_string
        puts result.join
    end
end
```

#### State Machines Are a Start

- 상태 머신을 사용할 기회를 좀 더 적극적으로 찾아보길 권장.
- 물론 이벤트와 관련된 모든 문제를 해결해 주지는 못함.
- 이벤트를 다루는 또 다른 방법에 대해서도 이어서 다룸.

### The Observer Pattern

- 옵저버 패턴에서는 *observable*이라 불리는 이벤트 소스가 있음.
- 그리고 이 이벤트들에 관심있는 클라이언트(*observer*라 불리는)들이 함께 존재.
- 옵저버는 옵저버블에 자신의 관심사를 등록.
- 함수의 참조를 넘기는 방식이 일반적.
- 이벤트가 발생하면, 옵저버블은 옵저버 목록을 순회하며,
- 등록 시점에 넘겨 받았던 함수를 호출함.
- 이벤트는 이 호출의 파라미터로 사용됨.
- 아래는 애플리케이션을 종료하는 데 쓰이는 `Terminator` 모듈 예제.

```rb
module Terminator
    CALLBAKCS = []
    
    def self.register(callback)
        CALLBAKCS << callback
    end

    def self.exit(exit_status)
        CALLBACKS.each { |callback| 
            callback.(exit_status)
        }
        exit!(exit_status)
    end
end

Terminator.register(-> (status) {
     puts "callback 1 see #{status}"
})

Terminator.register(-> (status) {
    puts "callback 2 see #{status}"
})

Terminator.exit(99)
```

- 하지만, 옵저버 패턴은 한 가지 문제가 있음.
- 옵저버들이 옵저버블에 등록되어야 하므로 커플링이 생김.
- 또한, 일반적으로 콜백들은 동기적으로 다뤄지므로 성능 병목이 있을 수도.
- 이런 문제는 Publish/Subscribe 전략으로 극복 가능.

### Publish/Subscribe

- pubsub는 옵저버 패턴의 일반화.
- 하지만 커플링과 성능 문제를 극복.
- *publisher*와 *subscriber*는 서로 채널을 통해 연결.
- 이 채널은 분리된 별개의 코드이며,
- 분리 수준은 라이브러리나 프로세스 또는 분산 인프라스트럭처 등 다양하고,
- 구현 세부사항은 숨겨져 있음.
- 모든 채널은 이름을 가짐.
- 구독자는 이런 이름을 가진 1개 이상의 채널에 관심사를 등록.
- 발행자는 등록된 이들에게 이벤트를 발행.
- 구독자/발행자 커뮤니케이션은 우리 코드 바깥에서, 비동기적으로 이뤄짐.
- 커플링이 줄어드는 장점을 가지는 한편, 내부 행위를 한 눈에 파악하기 어려움.

### Reactive Programming, Streams, and Events

- 스트림은 이벤트를 데이터 컬렉션인 것처럼 다룰 수 있게 도와줌.
- 조작하고, 조합하고, 필터링하는 등 우리가 흔히 사용하는 방식.
- 나아가 일반 컬렉션과 이벤트 스트림을 조합할 수도 있게 함.
- 그리고 스트림은 비동기. 즉, 이벤트 도착에 코드가 반응.
- 예제 코드는 특별할 것 없어 기록 생략.

#### Streams of Events Are Asynchronous Collections

- 동기적 프로세싱과 비동기적 프로세싱을 편리하고 공통된 API로 통일시켜줌.
- 우리가 다뤄야 하는 대상이 언제 이용 가능한지 고려할 필요 없음.
- 이는 매우 강력한 추상화.

### Events Are Ubiquitous

- 이벤트는 어디에나 있음.
- 어떤 것은 명시적. 버튼 클릭, 타이머 만료, ...
- 어떤 것은 덜 명시적. 누군가의 로그인, 패턴 매칭하는 파일 라인, ...
- 원천이 무엇이든 선형적 코드보다 더 높은 반응성과 디커플링을 가져다 줌.

## Topic 30. Transforming Programming

변환은 매우 중요.

- 모든 프로그램은 데이터를 변환함.
- 입력을 출력으로 바꾸는 것.
- 우리가 지금까지 걱정했던 많은 것들이 해결되기 때문.
- 구조는 깔끔해지고, 에러 핸들링은 좀 더 일관적이게 되고, 커플링은 낮아짐.

아래 터미널 명령어 역시 변환.

```sh
$ find . -type f | xargs wc -l | sort -n | tail -5
```

- `find . -type f`: 현재 디렉토리의 모든 파일 목록을 표준 포맷으로 작성
- `xargs wc -l`: 표준 입력으로부터 라인을 읽어들이고, 이를 정리해서 `wc -l` 커맨드의 인자로 넘김. `wc -l`은 인자로 넘어온 파일들의 내용 길이를 계산.
- `sort -n`: 각 라인은 숫자로 시작한다고 가정하고, 표준 입력을 정렬. 표준 출력에 결과를 작성.
- `tail -5`: 표준 입력을 읽고 마지막 5개 라인을 표준 출력으로 작성.

이 파이프라인을 그림으로 나타내면 아래와 같음.

![linux find pipeline](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780135956977/files/images/wc-pipeline.png)

원래의 요구사항은 "라인이 가장 긴 파일 5개를 찾아라"이며, 5가지 일련의 변환으로 나누어짐.

- list of files
- list with line numbers
- sorted list
- highest five + total
- highest five

```
Tip 49) Programming Is About Code, But Programs Are About Data
```

### Finding Transformations

- 변환을 찾는 가장 쉬운 방법은 요구사항부터 출발.
- 일단 요구사항의 입력과 출력을 결정.
- 이는 전체 프로그램을 나타내는 함수를 정의한 것.
- 이제 이 입력을 출력으로 이끄는 여러 단계들을 찾기.
- 주어진 문자들로 만들 수 있는 모든 단어를 나열하는 입출력 예시는 아래와 같음.

```
"lvyin" is transformed to ->    3 => ivy, lin, nil, yin
                                4 => inly, liny, viny
                                5 => vinyl
```

- 이 *anagram finder*는 다시 4개의 변환 과정으로 나뉨.

Step    | Transformation | Sample data
------- | -------------- | -----------
Step 0: | Initial input  | "ylvin"
Step 1: | All combinations of three or more letters | vin, viy, vil, vny, vnl, vyl, iny, inl, iyl, nyl, viny, vinl, viyl, vnyl, inyl, vinyl
Step 2: | Signatures of the combinations | inv, ivy, ilv, nvy, lnv, lvy, iny, iln, ily, lny, invy, ilnv, ilvy, lnvy, ilny, ilnvy
Step 3: | List of all dictionary words which match any of the signatures | ivy, yin, nil, lin, viny, liny, inly, vinyl
Step 4: | Words grouped by length | 3 => ivy, lin, nil, yin <br/> 4 => inly, liny, viny <br/> 5 => vinyl

#### Transformations All the Way Down

이번에는 Step 1을 다시 한 번 쪼개고 있음.

Step      | Transformation | Sample data
--------- | -------------- | -----------
Step 1.0: | Initial input | "vinyl"
Step 1.1: | Convert to characters  | v, i, n, y, l
Step 1.2: | Get all subsets  | [], [v], [i], … [v,i], [v,n], [v,y], … [v,i,n], [v,i,y], … [v,n,y,l], [i,n,y,l], [v,i,n,y,l]
Step 1.3: | Only those longer than three characters  | [v,i,n], [v,i,y], … [i,n,y,l], [v,i,n,y,l]
Step 1.4: | Convert back to strings  | [vin,viy, … inyl,vinyl]

이제 코드를 작성할 수 있는 수준이 됨(아래 언어는 Elixir).

```ex
defp all_subsets_longer_than_three_characters(word) do
    word
    |> String.codepoints()
    |> Comb.subsets()
    |> Stream.filter(fn subset -> length(subset) >= 3 end)
    |> Stream.map(&List.to_string(&1))
end
```

#### What's with the |> Operator?

- 많은 함수형 언어처럼 Elixir도 파이프라인 연산자가 있음.
- 이는 종종 *forward pipe* 또는 그냥 *pipe*라고 불리기도 함.
- 왼쪽의 값을 받아서 오른쪽에 있는 함수의 첫 번째 인자로 넘겨주는 것.
- 아래 두 코드는 같은 일을 함.

```ex
"vinyl" |> String.codepoints |> Comb.subsets()
Comb.subsets(String.codepoints("vinyl"))
```

- 파이프라인 연산자가 단지 문법적 설탕이 아니라,
- 다르게 생각할 수 있는 혁신적 기회를 주는 거라고 함.
- 개인적으론 문법 설탕. 하지만 편리해 보이는 건 확실.

#### Keep on Transforming...

이번엔 Step 2를 세분화.

Step      | Transformation | Sample data
--------- | -------------- | -----------
Step 2.0: | Initial input  | vin, viy, … inyl, vinyl
Step 2.1: | convert to signatures | inv, ivy … ilny, inlvy

```ex
defp as_unique_signatures(subsets) do
    subsets
    |> Stream.map(&Dictionary.signature_of/1)
end

defp find_in_dictionary(signatures) do
    signatures
    |> Stream.map(&Dictionary.lookup_by_signature/1)
    |> Stream.reject(&is_nil/1)
    |> Stream.concat(&(&1))
end

defp group_by_length(words) do
    words
    |> Enum.sort()
    |> Enum.group_by(&String.legnth/1)
end
```

#### Putting It All Together

```ex
def anagrams_in(word) do
    word
    |> all_subsets_longer_than_three_characters()
    |> as_unique_signatures()
    |> find_in_dictionay()
    |> group_by_length()
end
```

### Why Is This So Great?

일단 메인 함수를 다시 살펴보자.

```
word
  |> all_subsets_longer_than_three_characters()
  |> as_unique_signatures()
  |> find_in_dictionary()
  |> group_by_length()
```

- 이전 변형의 출력을 다음 변형의 입력으로 전달. 이는 매우 자연스럽게 읽히는 코드.
- 또 한 가지. OOP 방식으로 위를 구현하면, 여러 객체가 서로 통신하며, 서로의 상태를 계속 변경. 이는 꽤나 커플링.
- OO 시스템이 변경하기 어려운 이유 중 하나.
- 하지만 상태 없는 객체들도 매우 흔하게 다루기에 별로 와닿지 않음.

```
Tip 50) Don't Hoard State; Pass It Around
```

- 변형적<sup>transformational</sup> 모델에서는 데이터 풀이 아니라 데이터가 흘러다님.
- 데이터는 함수의 동료.
- 파이프라인은 code -> data -> code -> data ...의 연속.
- 데이터가 더 이상 특정 함수 그룹에 묶이지 않음.
- 이는 커플링의 감소.

### What About Error Handling?

- 변형 모델에서 에러는 어떻게 다룰까?
- 기본적으로 날것의 값 대신 이를 감싼 데이터 구조체를 주고 받음.
- 이 구조체에는 또한 값이 유효한지 여부를 포함.
- Haskell에서는 이 래퍼가 `Maybe`라고 불림.
- Scala에서는 `Option`.

#### First, Choose a Representation

- Elixir에서는 함수가 튜플을 반환.
- 이는 `{:ok,value}` 또는 `{:error,reason}`을 포함.

```ex
iex(1)> File.open("/etc/passwd")
{:ok, #PID<0.109.0>}
iex(2)> File.open("/etc/wombat")
{:error, :enoent}
```

#### Then Handle It Inside Each Transformation

코드 살펴보면 이해가 좀 더 쉬움.

```ex
def find_all(file_name, pattern) do
    File.read(file_name)
        |> find_matching_lines(pattern)
        |> truncate_lines()
    end
end

def find_matching_lines({:ok, content}, pattern) do
    content
        |> String.split(~r/\n/)
        |> Enum.filter(&String.match?(&1, pattern))
        |> ok_unless_empty()
end

def find_matching_lines(error, _), do: error

# ------------

def truncate_lines({:ok, lines}) do
    lines
        |> Enum.map(&String.slice(&1, 0, 20))
        |> ok()
end

def truncate_lines(error, _), do: error

# ------------

defp ok_unless_empty([]), do: error("nothing found")
defp ok_unless_empty(result), do: ok(result)

defp ok(result),    do: {:ok,   result}
defp error(reason), do: {:error, reason}
```

#### Or Handle It in the Pipeline

- 위 예시에서 에러 핸들링의 부담이 변형들에게 옮겨감.
- Elixir 같이 함수 호출에 패턴 매칭을 사용하는 언어에서는 그 부담이 줄긴 하겠지만 여전히 좋은 모습은 아님.
- 우리는 에러가 생겼을 때 파이프라인의 나머지 코드가 실행되지 않기를 원함.
- 이는 파이프라인의 이전 단계가 성공하기 전까지는 함수의 실행을 지연하고 싶은 것.
- 이를 위해 아래와 같이 수정해 볼 수 있음.

```ex
def and_then({ :ok, value }, func), do: func.(value)
def and_then(anything_else, _func), do: anything_else

def find_all(file_name, pattern) do
    File.read(file_name)
    |> and_then(&find_matching_lines(&1, pattern))
    |> and_then(&truncate_lines(&1))
end

# 나머지는 동일
```

- 위에서 `and_then` 함수는 바인드 함수의 예시.
- 이는 무언가를 감싼 값을 받고, 그 값에 대해 함수를 실행하며, 새로운 감싼 값을 반환.
- 이런 약간의 도우미를 통해 나머지 변형들의 단순화를 꾀함.

## Topic 31. Inheritance Tax

- 객체지향 언어를 사용하는가?
- 상속을 사용하는가?
- 멈춰라.

### Some Background

Simula의 상속 이야기.

- 상속은 1969년에 Simula 67에서 처음 소개.
- 이는 여러 타입의 이벤트를 같은 리스트에 큐잉하는 좋은 해결책이었음.
- *prefix* 클래스들이라 불리는 것들을 사용.

```
link CLASS car;
  ... implementation of car

link CLASS bicycle;
  ... implementation of bicycle
```

- 여기서 `link`가 *prefix* 클래스.
- 이는 연결 리스트의 기능을 더해주는 역할.
- 자동차와 자전거 모두 교통 신호를 기다리는 목록에 추가할 수 있음.
- 현대 시대의 용어로 `link`는 부모 클래스.
- 행위라기 보다, 서로 다른 타입을 엮는 것.
- 이는 Java와 C++ 같은 언어에서 계승됨.

Smalltalk의 상속 이야기.

- Simula에 이어 Smalltalk도 나옴.
- 스몰토크 창시자인 앨런 케이는, 2019 Quora에서, 스몰토크가 상속을 가지게 된 이유를 언급.
- 여기서의 상속은 타입이 아니라, 순수하게 행위를 위한 것.
- 행위의 동적 조직화.
- Ruby와 JavaScript 같은 언어에서 볼 수 있는 특징.

> So when I designed Smalltalk-72—and it was a lark for fun while thinking about Smalltalk-71—I thought it would be fun to use its Lisp-like dynamics to do experiments with "different programming" (meaning various was to accomplish "this is like that except").

지금은 이 2가지 목적으로 상속을 사용. 하지만, 어느 쪽이든 문제가 있음.

### Problems Using Inheritance to Share Code

- 상속은 커플링.
- 자식 클래스 의존은 부모, 부모의 부모 등 모든 조상에 대한 의존.

```rb
class Vehicle
    def initialize
        @speed = 0
    end
    def stop
        @speed = 0
    end
    def move_at(speed)
        @speed = speed
    end
end

class Car < Vehicle
    def info
        "I'm car driving at #{@speed}"
    end
end

# top-level code
my_ride = Car.new
my_ride.move_at(30)
```

- `my_car.move_at` 호출은 부모 클래스인 `Vehicle`에서 일어남.
- 만약, 누군가 `Vehicle`의 `move_at`을 `set_velocity`로 리네임 하면서,
- `@speed` 인스턴스 변수도 `@velocity`로 바꿔야 한다면,
- `Vehicle`을 참조하는 곳만 깨질 것이라 예상.
- 그러나 `Car`를 참조하는 곳도 함께 깨짐.
- 그리고 인스턴스 변수의 변경은 내부 구현 세부사항이나,
- 여기서는 `Car`에도 영향을 주게 됨.
- so much coupling

#### Problems Using Inheritance to Build Types

- 종종 상속을 새로운 타입을 정의하는 도구로 사용.
- 처음엔 단순할지 모르나, 매우 복잡한 계층이 만들어짐.
- 이런 복잡성은 애플리케이션을 깨지기 쉽게 만듦.
- 한 곳의 변경이 위 아래 계층에 영향을 주기 때문.
- 한편 Car가 일종의 Vehicle이지만, 동시에 Asset이나 LoanCollateral일 수 있음.
- 이는 다중 상속 문제로 이어짐.
- C++에서는 다중상속을 명확성에 대한 의구심 때문에 안 좋은 이름으로 부름.
- 결과적으로, 많은 최근의 OO 언어들은 다중상속을 제공 안 함.

```
Tip 51) Don't Pay Inheritance Tax
```

### The Alternatives Are Better

상속을 필요 없게 만드는 3가지 기법을 소개.

1. Interfaces and protocols
2. Delegation
3. Mixins and traits

#### Interfaces and Protocols

- OO 언어에서는 클래스가 행위 집합을 구현하도록 지정할 수 있음.
- 예를 들어, `Car` 클래스에게 `Drivable`와 `Locatable` 행위를 구현하게 명시.

```java
public interface Drivable {
    double getSpeed();
    void stop();
}

public interface Locatable() {
    Coordinate getLocation();
    boolean locationIsValid();
}

public class Car implements Drivable, Locatable {
    // Code for class Car. This code must include
    // the functionality of both Drivable
    // and Locatable
}
```

- 자바에서는 `Drivable`와 `Locatable`를 가리켜 인터페이스라 부름.
- 다른 언어에서는 protocol이나 trait라 부르기도.
- 이렇게 하면 클래스들을 타입으로 사용할 수 있음.
- 같은 인터페이스를 구현하기만 하면 같은 타입.
- 아래와 같은 식으로.

```java
List<Locatable> items = Arrays.asList(
    new Car(...),
    new Phone(...),
    new Car(...)
);

void printLocation(Locatable item) {
    if (item.locationIsValid() {
    print(item.getLocation().asString());
}

items.forEach(printLocation);
```

```
Tip 52) Prefer Interfaces to Express Polymorphism
```

- 인터페이스와 프로토콜은 상속 없이도 다형성 제공.

#### Delegation

```rb
# 상속
class Account < PersistenceBaseClass
end

# 위임
class Account
    def initialize(...)
        @repo = Persister.for(self)
    end

    def save
        @repo.save()
    end
end
```

- 위 예시에서 상속 대신 위임을 사용하면,
- 클라이언트 코드에 프레임워크 API를 노출하지 않으면서도,
- 프레임워크의 기능을 사용할 수 있음.

```
Tip 53) Delegate to Services: Has-A Trumps Is-A
```

- 여기서 좀 더 나아갈 수도 있음.
- 왜 `Account`가 영속에 대해서 알아야 하나?

```rb
class Account
    # nothing but account stuf
end

class AccountRecord
    # wraps an account with the ability
    # to be fetched and stored
end
```

- 좀 더 디커플링 됨.
- 하지만 비용이 따름.
- 보일러플레이트 코드를 좀 더 작성해야 함.
- 다행히 mixin과 trait이 우리의 일을 대신해 줌.

#### Mixins, Traits, Categories, Protocol Extensions, ...

- 믹스인의 기본 개념은 간단.
- 상속 없이 클래스나 객체가 새로운 기능을 갖도록 확장.
- 여러 함수들의 집합을 만들고, 여기에 이름을 붙이고, 클래스나 객체에서 이를 확장.
- 원래 클래스들이 할 수 있는 것과 믹스인의 것을 병합하는 것.
- [Working with Mixins in Ruby](https://www.culttt.com/2015/07/08/working-with-mixins-in-ruby/)에서 'When would you use a Mixin over Inheritance?' 부분에 상속에 비해 믹스인이 가지는 이점이 잘 나와 있음.
- 상속이 "type of something"이라면 믹스인은 "capable of something".

```
Tip 54) Use Mixins to Share Functionality
```

## Topic 32. Configuration

외부 환경 설정을 이용해서 애플리케이션을 매개변수화 하라는 이야기.

- 코드가 의존하는 값이 애플리케이션이 사용되기 시작한 후 바뀔 수 있음.
- 애플리케이션이 서로 다른 환경(고객)에서 실행될 수 있고,
- 이 서로 다른 환경을 위한 환경(고객) 특화 값들이 필요할 수도.
- 이런 값들을 애플리케이션 외부에서 관리하라.
- 이는 애플리케이션을 매개변수화 하는 것.
- 즉, 코드를 실행되는 환경에 맞추는 것.

```
Tip 55) Parameterize Your App Using External Configuration
```

환경설정에서 관리하는 값들은 보통 아래의 것들.

- 외부 서비스(DB, 3rd API, ...)를 위한 자격증명<sup>credential</sup>
- 로그 레벨과 목적지
- 애플리케이션이 사용하는 포트, IP 주소, 장비, 클러스터 이름
- 환경 특화된 유효성 검사 파라미터
- 세금 비율 같이, 외부에서 설정하는 파라미터
- 사이트 특화된 포매팅 세부사항
- 라이센스 키

### Static Configuration

- 평문 파일이나 DB 테이블에 설정을 저장해서 사용하곤 함.
- 데이터가 구조화 되어 있고, 세금 비율 같이 고객에 의해 변경될 수 있는 경우는,
- DB 테이블에 저장하는 것이 좀 더 유리할 수 있음.
- 용도에 따라 분리해서 관리.
- 보통은 애플리케이션이 기동할 때 이 값들이 읽히고,
- 전역 데이터로써 관리되곤 함.
- 저자는 이 방식을 권장하지 않는다고.
- 대신, API 뒤로 설정 정보들을 감싸라고.
- 이는 코드와 설정 세부 사항을 디커플링.

### Configuration-As-A-Service

- 여전히 애플리케이션 외부에서 설정들을 관리하면서도,
- 평문 파일이나 데이터베이스가 아니라,
- 서비스 API 뒤에 저장된 것으로 바라보고자 함.
- 이렇게 하면 여러 애플리케이션이 설정 정보를 공유할 수 있음.
- 물론 인증/허가 제한도 가능.
- 그리고 설정 변경을 전역적으로 반영할 수 있음.
- 또한 설정을 특수화 된 UI를 통해 관리할 수 있음.
- 더불어 설정이 동적이 됨.

### Don't Write Dodo-Code

- 설정 외부화 없이는 코드가 적응력이나 유연함을 갖기 어령무.
- 적응하지 못하는 종은 사라지기 마련.
- 도도 새가 적응하지 못하고 멸종 됐다는 얘기 곁들임.

# Chapter 6. Concurrency

**동시성<sup>concurrency</sup>**

- 2개 이상의 코드 조각이 마치 동시에 동작하는 것처럼 동작하는 것.
- 이를 위해서는 실행 중인 코드의 조각들이 서로 다른 문맥에서 실행될 수 있어야 함.
- 주로 피버<sup>fiber</sup>, 스레드, 프로세스 등을 이용.

**병렬성<sup>parallelism</sup>**

- 동시 동작하는 것처럼 보이는 게 아니라, 동시에 동작하는 것.
- 2개를 동시에 할 수 있는 하드웨어가 필요.
- CPU의 멀티 코어라던지, 멀티 CPU, 서로 연결된 멀티 컴퓨터 등을 이용.

모든 것은 concurrent.

- 동시성은 일반적인 크기의 시스템이라면 필수불가결.
- 사용자와 상호작용하면서도, 데이터를 읽어들이고, 외부 서비스와 통신하고, ...
- 이를 순차적으로 하는 것은 비효율.
- 따라서 동시성은 필수.
- 이런 환경에서 시간적 커플링<sup>temporal coupling</sup>을 깨뜨리는 방법을 이야기.
- 동시성과 병렬성을 어렵게 만드는 공유 상태에 대해서도 다룸.
- 동시성을 잘 다루기 위한 방법 중 하나로 액터와 프로세스도 이야기.
- *blackboard*도 언급.

## Topic 33. Breaking Temporal Coupling

- 소프트웨어 아키텍처에 있어 시간은 종종 고려되지 않는 요소.
- 하지만 동시성<sup>concurrency</sup>과 순서<sup>ordering</sup>는 중요.
- 만약 A 메서드가 B보다 항상 먼저 호출되어야 한다면 이는 시간적 결합도.
- 한 번에 1개의 리포트만 실행될 수 있다면 이 역시 결합도.
- 버튼 클릭 이벤트를 받기 전에 스크린이 다시 그려지길 기다려야 하는 것도 마찬가지.
- 이런 접근법은 경직되고 비현실적.
- 우리는 동시성을 허용해야 하고,
- 시간 또는 순서 의존성을 디커플링 해야 함.
- 이렇게 함으로써 유연하고 추론하기 쉬우며 좀 더 신뢰성 있고 빠른 반응성을 기대.

### Looking for Concurrency

- 애플리케이션 워크플로우를 설계 일부로 모델링하고 분석해야 함.
- 무엇이 동시에 일어날 수 있고, 무엇이 엄격한 순서대로 일어나야 하는지 찾아야 함.
- 액티비티 다이어그램 같은 도구를 이용해 순서도를 그려볼 수 있음.

```
Tip 56) Analyze Workflow to Imporve Concurrency
```

- 액티비티 다이어그램에서 액션은 모서리가 둥근 박스로 표현.
- 액션을 떠나는 화살표는 다른 액션으로 이어짐.
- 또는 동기화 막대<sup>synchronization bar</sup>라고 불리는 두꺼운 선으로 이어짐.
- 이 두꺼운 선으로 향하는 모든 액션이 완료되어야, 이 선을 떠나는 화살들이 계속 진행될 수 있음.
- 이런 액티비티 다이어그램을 통해 병렬로 실행될 수 있는 것들을 찾아 병렬성을 극대화할 수 있음.

![activity diagram of parallelism](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780135956977/files/images/pina-colada.png)

### Opportunities for Concurrency

- 액티비티 다이어그램은 잠재적 동시성을 보여주는 것이지,
- 그것이 꼭 그래야 한다고 말하는 것은 아님.
- 예컨대, 위의 피나 콜라다 예제에서 바텐더가 모든 일을 동시에 하려면 손이 5개여야.
- 하지만 그래서 설계가 필요.
- 다이어그램을 보면 8번의 작업이 몇 분 정도 소요됨을 알 수 있음.
- 이 시간을 기다리는 동안 바텐더는 10번이나 11번을 수행할 수도.

### Opportunities for Parallelism

- 동시성은 소프트웨어 메커니즘, 병렬성은 하드웨어 관련.
- 우리가 멀티 프로세서를 갖고 있다면(그것이 로컬이든 원격이든),
- 전체 소요 시간을 줄이기 위해 일을 나눌 수 있음.
- 이상적인 분리 대상은 서로 독립적인 작업들.
- 흔한 방법 중 하나로 fork join과 같은 개념을 이야기.
- 한 가지 예시는 Elixir 언어의 컴파일러.
- 이는 프로젝트를 여러 모듈로 나누고 각각을 병렬로 컴파일 함.
- 때로는 모듈간 의존성이 있는데, 이 경우엔 의존 작업이 끝날 때까지 기다리게 됨.

### Identifying Opportunities Is the Easy Part

- 동시성과 병렬성으로 이점을 취할 수 있는 지점을 식별하는 것은 생각보다 간단.
- 이제 문제는 이를 어떻게 구현할 것인가에 대한 것.
- 이는 뒤이은 챕터들에서 다루게 됨.

## Topic 35. Shared State Is Incorrect State

- 식당에서 직원에게 애플 파이 1개를 부탁.
- 직원은 뒤를 돌아 디스플레이에서 파이가 1개 남아 있음을 확인하고 알았다고 함.
- 같은 식당에서 다른 직원도 다른 손님에게 파이 1개를 부탁 받음.
- 역시나 디스플레이를 확인하고 알았다고 함.
- 손님 2명 중 1명은 결국 실망하게 될 것.
- 문제는 공유된 상태.
- 직원들이 서로를 고려하지 않고 디스플레이를 본 것.

```
Tip 57) Shared State Is Incorrect State
```

### Nonatomic Updates

- 위 사례에서 두 직원이 동시에 한 일은 아래 코드와 같음.

```rb
if display_case.pie_count > 0
    promise_pie_to_customer()
    display_case.take_pie()
    give_pie_to_customer()
end
```

- 여기서 문제는 2개의 프로세서가 같은 메모리에 쓰기를 할 수 있다는 것이 아님.
- 문제는 어떤 프로세스도 메모리의 읽기 일관성을 보장할 수 없다는 것.
- 파이 갯수를 읽어들이고 업데이트 하는 것이 원자적 연산이 아님.
- 값이 중간 상태일 수 있음.

#### Semaphores and Other Forms of Mutual Exclusion

- 세마포어란, 한 번에 한 사람만 소유할 수 있는 것을 가리킴.
- 세마포어를 만들고 이를 이용해서 리소스에 대한 접근 제어.

```rb
case_semaphore.lock()

if display_case.pie_count > 0
    promise_pie_to_customer()
    display_case.take_pie()
    give_pie_to_customer()
end

case_semaphore.unlock()
```

- 이 방식에는 다소 문제가 있음.
- 접근자들이 세마포어를 사용한다는 관례에 모두 동의를 했기에 가능한 것.
- 만약 누군가 이를 깜빡한다면 다시 혼란에 빠지게 됨.

#### Make the Resource Transactional

- 위 방식은 접근을 보호하는 역할을 접근자에게 위임해 버림.
- 이제 접근을 중앙화 해보자.

```rb
slice = display_case.get_pie_if_available()
if slice
    give_pie_to_customer()
end

def get_pie_if_available()
    @case_semaphore.lock()

    if @slices.size > 0
        update_sales_data(:pie)
        return @slices.shift
    else
        false
    end

    @case_semaphore.unlock()
end
```

- 파이 조각 갯수를 확인하고 얻는 행위를 하나의 API로 변경하고,
- 그 API 안에서 세마포어 구현을 함.
- 하지만 이 방식도 문제가 있음.
- 만약, `update_sale_data`에서 예외가 발생한다면?
- 세마포어는 잠금을 해제하지 못한 상태를 영원히 유지하게 됨.
- 뒤이은 `get_pie_if_available` 호출자들은 계속 대기.
- 그래서 아래와 같이 해야 함.

```rb
def get_pie_if_available()
    @case_semaphore.lock()

    try {
        if @slices.size > 0
            update_sales_data(:pie)
            return @slices.shift
        else
            false
        end
    }
    ensure {
        @case_semaphore.unlock()
    }
end
```

- 보통은 언어에서 이런 처리를 돕기에 아래와 같은 코드가 되곤 함.

```rb
def get_pie_if_available()
    @case_semaphore.protect() {
        if @slices.size > 0
            update_sales_data(:pie)
            return @slices.shift
        else
            false
        end
    }
end
```

### Multiple Resource Transactions

- 파이와 함께 아이스크림도 팔아야 한다고 해보자.
- 위 코드를 아래와 같은 방식으로 고려해 볼 수 있음.

```rb
slice = display_case.get_pie_if_available()
scoop = freezer.get_ice_cream_if_available()

if slice && scoop
    give_order_to_customer()
end
```

- 하지만 이 코드는 동작하지 않음.
- 파이는 얻었지만 아이스크림을 얻으려 하는 순간 그럴 수 없다는 걸 알게 되면?
- 파이만 얻은 상태로 아무 것도 할 수 없게 됨.
- 그래서 아래와 같이 바꿔볼 수 있음.

```rb
slice = display_case.get_pie_if_available()

if slice
    try {
        scoop = freezer.get_ice_cream_if_available()
        if scoop
            try {
                give_order_to_customer()
            }
            rescue {
                freezer.give_back(scoop)
            }
            end
    }
    rescue {
        display_case.give_back(slice)
    }
end
```

- 하지만 이 역시 이상적이진 않음.
- 코드가 일단 정말 별로다.
- 비즈니스 로직이 잡일에 묻혀버림.
- 앞서 리소스 그 자체가 리소스를 핸들링 하도록 했었으나,
- 지금은 리소스가 2개인 상황.
- 1개의 리소스로 2개를 몰아 넣는 것은 별로.
- 실용적 접근법은 아이스크림을 얻은 파이<sup>apple pie à la mode</sup>를 하나의 새로운 자원으로 보는 것.
- 물론 현실 세계에서는 복합 메뉴가 많을 수 잇고,
- 그 메뉴마다 새로운 모듈을 만들고 싶지는 않을 것.

### Non-Transactional Updates

- 동시성 문제에 있어서 사람들이 공유 메모리에 집중하려는 경향.
- 하지만 동시성 문제는 애플리케이션 코드가 함께 사용하는 리소스가 있는 곳이라면 어디서든 발생.
- 이 리소스는 파일, 데이터베이스, 외부 서비스 등 무엇이든 될 수 있음.

```
Tip 58) Random Failures Are Often Concurrency Issues
```

### Other Kinds of Exclusive Access

- 대부분의 언어는 공유 자원에 대한 배타적 접근을 지원하는 라이브러리들을 갖고 있음.
- 뮤텍스<sup>mutexes</sup>(mutual exclusion), 모니터, 세마포어 등으로 불림.
- 하지만 Rust처럼 언어 차원에서 지원하는 것도 있음. 데이터 소유권 개념인데, 오직 한 번에 1개의 변수나 파라미터만이 변경 가능한 데이터의 참조를 가질 수 있음.
- 함수형 언어로 동시성을 쉽게 만들 수 있다고는 하지만 역시나 같은 문제들에 직면.
