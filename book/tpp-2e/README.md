# From the Preface to the First Edition

> You work small miracles every day.

# What Makes a Pragmatic Programmer?

실용주의 프그래머라면, 아래 특성들 중 많은 것을 갖고 있을 것.

1. Ealry adopter/fast adapter
    - 기술과 기법에 대한 직감이 있고, 새로운 것을 시도하기 좋아함.
    - 새로운 것이 나타났을 때 빠르게 살펴보고 기존의 지식과 통합할 수 있음.
    - 자신감은 자신의 경험에서 흘러나옴.
2. Inquisitive (호기심 많다는 뜻)
    - 질문하길 좋아함.
    - 사소하고 작은 사실들의 수집가.
    - 이는 지금 이후의 결정에 영향을 미침.
    - 양자역학이 뭐지? 넌 그걸 어떻게 했니? 라이브러리에 문제가 있니? 심볼릭 링크는 어떻게 구현된 거지?
3. Critical thinker
    - 사실을 먼저 파악한 뒤에야 주어진 것을 받아들임.
    - 동료가 "원래 그렇게 해왔어"라고 말하거나,
    - 벤더가 모든 문제의 해결책을 약속하면,
    - 이의를 제기할 줄 앎.
4. Realistic
    - 직면한 문제의 본질을 이해하려 함.
    - 이는 문제가 얼마나 어렵고 해결하는 데 얼마나 걸릴지에 대한 좋은 감을 가져다 줌.
    - 깊이 있는 이해는 그것을 지속할 수 있는 체력이 됨.
5. Jack of all trades (만물박사라는 의미)
    - 다양한 기술과 환경에 익숙해지려 부단히 노력함.
    - 새로운 개발에 대한 최근 정황들을 꾸준히 알아둠.
    - 비록 현재 직업이 스페셜리스트가 되길 강요하는 상황이더라도,
    - 언제나 새로운 영역과 새로운 도전에 부딪히려 함.

가장 기본적인 특성을 가장 마지막에 언급.

```
Tip 1) Care About Your Craft
Tip 2) Think! About Your Work
```

- 실용주의 프로그래머가 되기 위해서, 일을 하고 있을 때 자신이 그것을 어떻게 하고 있는지를 의식적으로 생각해야 함.
- 일회성 감사가 아니라 모든 프로젝트, 매일, 당신이 내리는 모든 결정에 대한 지속적인 평가가 필요.
- 꾸준히 생각하고 자신의 일에 대해 실시간으로 비판하라.

# Individual Pragmatists, Large Teams

- 종종 "소프트웨어는 엔지니어링 규율"이라면서,
- "개별 멤버들이 그들을 위한 결정을 내리면 소프트웨어는 무너진다"고 함.
- 그러나, 소프트웨어 개발에는 개인과 그들의 장인정신을 배제할 수 없음.

# It's a Continuous Process

- 매일의 작은 보살핌이 오랫동안 지속될 때 훌륭한 결과가 나온다는 이야기.
- "Kaizen" = 많은 작은 개선들을 꾸준히 지속하는 것을 가리키는 일본 단어.
- 이는 일본 제조업에서의 극적인 생산성과 품질 향상을 가져온 주된 이유였다고.
- 1판에서도 있었던 이야기로 기억.

# 1. A Pragmatic Philosophy

- 이것은 당신의 경력이고 인생이다. (1. It's Your Life)
- 무엇이 실용주의 프로그래머를 구분시켜 주는가?
- 일단, 문제 그 자체보다 더 큰 그림과 맥락에서 문제를 바라봄.
- 또한, 자신들이 하는 모든 것에 책임감을 가짐. (2. The Cat Ate My Source Code)
- 프로젝트를 깨끗하게 유지하는 사람들. (3. Software Entropy)
- 대부분의 사람들은 변화를 어려워함. 때로는 좋은 이유 때문이기도 하고, 때로는 단순한 관성 때문.
- 변화를 착수하기 위한 전략들을 뒤에서 살펴 볼 예정. (4. Stone and Boiled Frogs)
- 일의 맥락을 이해하는 것은 소프트웨어가 얼마나 좋아야 하는지에 대한 지침이 됨. 완벽이 좋아보일지 모르나 트레이드 오프가 있기 마련. (5. Good-Enough Software)
- 물론, 다양한 지식과 경험을 가지고 있어야 함. 배움은 지속적인 과정. (6. Your Knowlege Portfolio)
- 우리는 진공 상태에서 일하는 게 아니고, 여러 사람과 상호 작용하며 일함. (7. Communicate!)
- 실용주의 프로그래밍은 실용주의 사고에서 자라나기 시작함.
- 1장은 이런 철학에 대한 이야기.

## Topic 1. It's Your Life

- 이건 당신의 인생임.
- 당신이 가진 것이고, 당신이 실행하는 것이며, 당신이 만드는 것.
- 더 적게 받는 것 같고, 더 적게 대우 받는 것 같다고 느끼는 사람들에게 아래와 같이 질문함.

> Why can't you change it?

```
Tip 3 You Have Agency
```

- 작업 환경이 열악하거나, 작업이 지루한가?
- 그렇다면 고쳐라. 하지만 영원히 시도하지는 마라.
- 마틴 파울러는 아래와 같이 이야기.

> You can change your organization or change your organization.

- 소프트웨어 개발은 개인에게 주어진 주도권이 큰 직업군에 속함.
- 주도적으로 행동하고 원하는 것을 취할 것.

## Topic 2. The Cat Ate My Source Code

- 실용주의 철학의 가장 초석이 되는 아이디어는 책임감.
- 경력 발전, 배움과 교육, 프로젝트, 매일의 작업 속에서 당신과 당신의 일에 대한 책임감.
- 책임감과 더불어, 무지나 에러 등을 받아들이는 것에 두려움이 없음.
- 기쁜 일은 아니겠지만 분명 일어나는 일임.
- 충분한 테스팅, 좋은 문서화, 견고한 자동화에도 불구.
- 배포는 늦어지고 예상치 못한 기술적 문제는 일어남.
- 이런 문제가 생기면, 자신에 대한 역량을 믿으면서도, 스스로의 부족한 점(무지나 실수)도 인정해야 함.

### Team Trust

- 신뢰는 창의성과 협력에 있어 필수.
- 신뢰의 환경에서는 소신 있게 말할 수 있으며 서로를 믿을 수 있음.
- 신뢰의 손상은 복구하기 어려움.

### Take Responsibility

- 자신이 맡은 일이 제대로 수행되도록 노력.
- 그러나 자신의 통제 밖에 있는 위험은 분명히 구분해야 함.
- 불가능한 상황에 대해서까지 책임감을 가지면 안 됨.
- 한편, 책임지기로 마음 먹었다고 하더라도, 실수나 판단의 오류가 있을 수 있음.
- 이럴 땐 솔직하게 문제를 받아들이고, 변명이 아닌 대안을 제시.
- 공급 업체가 오지 않았다면 이를 대비한 계획이 있었어야 함.
- 코드가 포함된 저장 장치가 망가졌다면 백업이 있었어야 함.
- 핑계나 변명을 찾지는 말자.

```
Tip 4) Provide Options, Don't Make Lame Execuses
```

## Topic 3. Software Entropy

- 소프트웨어 개발이 대부분의 물리 법칙으로부터 자유롭긴 하지만,
- 엔트로피의 급격한 증가는 우리를 힘들게 함.
- 엔트로피란 물리학 용어이며, 시스템의 무질서 양을 가리킴.
- 소프트웨어에서 무질서가 증가하면 우리는 이를 "소프트웨어 부패"라고 부름.
- 혹자는 좀 더 긍정적 용어인 "기술 부채"라 부름.
- 언젠가 갚을 수 있는 의미로 사용되는 것이긴 하나 실제로는 그렇지 않음.
- 용어가 어찌됐던 부채와 부패는 통제할 수 없는 수준으로 퍼져나감.
- 하지만 이것이 통제할 수 있는 심리적, 문화적 요인이 있음.
- 깨진 유리창 이야기.

```
Tip 5) Don't Live with Broken Windows
```

- 깨진 유리창을 그대로 내버려 두지 말 것.
- 나쁜 설계, 잘못된 결정, 부실한 코드 등.
- 발견되고 얼마 지나지 않아 고쳐져야 함.
- 적절히 고칠 시간이 없다면 땜빵 식으로라도 해결해 두어야 함.
- 소프트웨어 부패의 여러 요인이 있지만, 무엇보다 방치가 부패를 가장 가속화 시키는 요인.

### First, Do No Harm

- 깨진 유리창이 하나라도 없다면,
- 본인이 그 첫 번째 깨진 유리창의 주인공이 되지 않으려 부단히 노력.
- 스스로에게 "No broken windows"라고 말하라.

## Topic 4. Stone Soup and Boiled Frogs

- 군인이 전쟁을 마치고 마을로 돌아와서,
- 물 냄비에 돌 3개를 넣고 수프라며 만들기 시작하니,
- 자기 것을 지키느라 급급했던 마을 사람들이 하나 둘씩 재료를 들고 나와,
- 다 같이 모여 앉아 좋은 수프를 먹게 되었다는 이야기.
- 군인이 가진 것은 없었으나 촉매제<sup>catalyst</sup>처럼 행동함.
- 결과적으로 마을에 몇 달간 없었던 좋은 일로 이어짐.
- 아주 잘 알고 있는 일이라는 이유로 모든 것을 할 수 있는 권한을 요구하면,
- 멍한 시선, 지연, 위원회의 구성, 예산 승인 등 일이 복잡해짐.
- 이 대신 돌을 꺼내는 것을 권장.
- 합리적으로 요청할 수 있는 것을 찾아내고, 그것을 잘 개발한 뒤, 사람들에게 보여주고, 놀라게 하라.
- 그리고 "만약 이것을 추가하면 이렇게 이렇게 더 나아집니다"라고 말하라.
- 별로 중요하지 않은 것처럼 말하고, 뒤에 앉아서 사람들이 물어보기를 기다려라.
- 사람들은 더 쉽게 동참할 것.
- 미래를 보여주며 사람들을 모여들게 하라.

```
Tip 6) Be a Catalyst for Change
```

### The Villagers' Side

```
Tip 7) Remember the Big Picture
```

- 개구리를 끓는 물에 넣으면 바로 튀어 나오지만,
- 차가운 물에서 점차 온도를 높여나가면 개구리는 인지하지 못하고 죽음.
- [끓는 물 속의 개구리 신드롬](https://ko.wikipedia.org/wiki/%EB%81%93%EB%8A%94_%EB%AC%BC_%EC%86%8D%EC%9D%98_%EA%B0%9C%EA%B5%AC%EB%A6%AC)
- 이는 앞서 다뤘던 깨진 유리창과는 다른 문제.
- 깨진 유리창에서는, 돌보는 사람이 아무도 없다는 것을 인지했기에, 엔트로피에 대적할 의지를 잃어버림.
- 끓는 물 속 개구리는, 변화를 인지조차 못하는 것.
- 큰 그림을 보려고 노력하라. 주위에서 무엇이 일어나는지 꾸준히 확인.

## Topic 5. Good-Enough Software

- 실제 세상에서 품질에 대한 완벽한 통제권을 가질 수는 없음.
- 우리는 "충분히 좋은" 소프트웨어를 만들 수 있어야 함.
- 사용자, 유지보수자, 본인 스스로의 마음에 있어서 충분히 좋은.
- 우리의 생산성은 올라가고 사용자들은 만족할 것.
- `충분히 좋은 != 엉성하고 형편 없이 만들어진 코드`임에 유의.

### Involve Your Users in the Trade-Off

```
Tip 8) Make Quality a Requirements Issue
```

- 사용자에게 소프트웨어가 얼마나 좋기를 원하는지 물어본 적이 있는가?
- 물론, 심박 조율기나 오토파일럿, 광범위하게 사용되는 저수준 라이브러리 등을 만든다면, 타협의 여지가 없을 수 있음.
- 하지만, 신형 제품을 만드는 곳이라면, 마케팅 담당자는 지켜야 하는 약속이 있고, 고객은 배포일을 기반으로 계획을 세우며, 회사는 자금 유동의 제약을 받음.
- 불가능한 약속을 하라거나, 기일을 맞추기 위해 기본 엔지니어링 절차들을 무시하라는 것이 아님.
- 시스템의 범위와 품질은 시스템 요구사항으로써 논의되어야 함.
- 의외로 고객들은 약간의 결함이 있더라도 오늘을, 빛나지만 이런 저런 부가기능이 달린 나중보다 선호.
- 또한 고객들이 빨리 써 볼수록 피드백을 통해 궁극적으로 더 좋은 솔루션으로 나아갈 수 있음.
- 내일의 완벽함보다 오늘의 판타지.

### Know When to Stop

- 지나치게 꾸미고 다듬다 보면 완전히 좋은 프로그램도 망가짐.
- 계속 나아가면서, 코드가 잠시 동안이라도 자신의 일을 하게 두어라.
- 완벽할 필요도 없고, 완벽한 적도 없음.

## Topic 6. Your Knowledge Portfolio

- 지식과 경험은 가장 중요한 매일의 직업적 자산.
- 하지만, 이 자산은 시간이 지나면서 낡고 더 이상 쓸모 없어지기도.
- 그러므로 새로운 것을 배우는 능력이 가장 중요한 전략적 자산.

### Your Knowledge Portfolio

지식 포트폴리오는 재정적 포트폴리오와 매우 유사.

1. 정기적으로 투자 - 습관처럼
2. 다양성은 장기적 성공에 주요 요인
3. 보수적인 것과 고위험 고수익 투자 사이에서 균형
4. 저점일 때 사고 고점일 때 팔아서 수익 극대화
5. 포트폴리오는 주기적으로 리뷰하고 리밸런싱 해야 함

### Goals

1. 매년 한 가지 이상의 새로운 언어를 배워라.
    - 각 언어들은 같은 문제를 서로 다르게 접근함.
    - 서로 다른 언어를 배움으로써, 틀에서 벗어나고 사고를 넓힐 수 있음.
2. 매달 기술 서적을 읽어라.
    - 깊은 이해를 위해서는 장문의 책을 읽는 것이 도움이 됨.
    - 처음엔 현재 사용하는 기술과 관련된 것을 읽는 것으로 시작하고,
    - 충분히 익혔다면 프로젝트와 관련 없는 것으로 이를 넓혀라.
3. 비기술적 서적 역시 읽어라.
    - 우리는 결국 사람들과 일함.
    - 인간 측면의 문제는 완전히 다른 기술 세트를 요구함.
    - 흔히 소프트 스킬이라고 부름(아이러니하게 마스터하기 어려움hard).
4. 수업을 들어라.   
    - 오프라인이나 온라인 등 흥미로운 코스를 찾아보라.
5. 지역 사용자 그룹과 밋업에 참가하라.
    - 고립은 경력에 있어 치명적.
    - 회사 바깥의 사람들은 어떻게 일하는지 가서 보라.
6. 서로 다른 환경을 경험하라.
    - 윈도우 환경에서만 일했다면 리눅스 환경에서도 시간을 보내라.
7. 최신 정보를 꾸준히 찾아라.

### Critical Thinking

```
Tip 10) Critically Analyze What You Read and Hear
```

아래 질문들을 통해서 비판적으로 읽고 생각하라는 이야기.

1. Ask the "Five Whys"
2. Who does this benefit?
3. What's the context?
4. When or Where would this work?
5. Why is this a problem?

## Topic 7. Communicate!

- 가지고 있는 것도 중요하지만, 포장하는 것도 중요.
- 아무리 좋은 아이디어, 코드, 실용주의 사고라도 효과적 커뮤니케이션이 있어야 가치를 가짐.
- 우리는 단순히 기계와 언어로 소통하는 것 외에도 하루에 정말 많은 커뮤니케이션을 함.
- 영어를 단지 또 다른 프로그래밍 언어라고 생각하라.
- 코드 작성할 때와 마찬가지로 DRY, 자동화 등을 중요하게 고려.

```
Tip 11) English is Just Another Programming Language
```

### Know Your Audience

- 커뮤니케이션, 말하기, 괴롭히기를 구분해서 정의.
- 청중의 요구, 관심사, 역량을 이해해야 함.
- 그리고 피드백을 모아야 함.
- 질문을 기다리지 말고 물어보라.
- 바디 랭기지와 표정을 살펴보라.

> The meaning of your comunication is the response you get.

### Know What You Want to Say

- 말하기 전에 계획을 세우고 개요를 작성하라.
- "이렇게 하면 청중들에게 내가 말하고자 하는 바가 제대로 전달 되는 걸까?"를 물어라.
- "그렇다"고 대답할 수 있을 때까지 다듬어라.

### Choose Your Moment

- 청중들이 무엇을 듣기 원하는지 뿐만아니라,
- 그들의 우선순위가 무엇인지 이해해야 함.
- 소스 코드가 사라져 방금 상사 때문에 지친 매니저라면,
- 당신의 새로운 개발 방법론에 대한 이야기는 잘 들리지 않을 것.
- 반면, 소스 코드 리포지토리에 대한 아이디어에는 좀 더 수용적.
- "지금 말하기 좋은 타이밍인가?"를 생각하자.

### Choose a Style

- 어떤 이는 단지 사실만 포함된 요약을 좋아함.
- 어떤 이는 길고 넓게 얘기하길 좋아함.
- 어떤 이는 A라는 주제에 초보자일 수도 있고 전문가일 수도.
- 혹시 모르겠거나 애매하다면 물어보라.

### Make It Look Good

- 많은 개발자들이 문서를 작성할 때 오로지 내용에만 집중.
- 하지만, 당신의 아이디어는 중요함. 보기 좋은 모습으로 잘 전달 될 수 있어야 함.

### Involve Your Audience

- 문서 작성의 초기 단계부터 독자를 참여 시킬 것.
- 피드백을 얻고 아이디어를 수용하라.

### Be a Listener

- 사람들이 들어주길 원한다면 당신이 사용해야 하는 유일한 방법이 있음.
- 바로 다른 이들의 이야기를 들어주는 것.
- 자신이 모든 정보를 갖고 있다고 하더라도, 강연을 하는 공식적 자리라고 하더라도.
- 질문을 던지고, 자신들의 언어로 다시 말하게 하는 등의 노력으로 사람들을 참여시킬 것.

### Get Back to People

```
Tip 12) It's Both What You Say and the Way You Say It
```

- 당신이 질문했을 때 상대방이 응답이 없다면 공손치 못하다고 여길 것.
- 반대로는 어떠한가? 당신은 잘 응답하고 있는가?
- 아무리 단순한 답이라도 항상 답을 해주어라.
- 사람들에게 꾸준히 정보를 제공하다 보면,
- 때로는 실수에 있어 관대하게 만들어 주기도 하고,
- 당신이 그들을 잊지 않았다고 느끼게 해 줌.
- 이런 식으로 더 많이 커뮤니케이션할수록 더 많은 영향력을 가질 수 있음.

### Documentation

```
Tip 13) Build Documentation In, Don't Bolt It On
```

- 문서화 중요하다는 이야기.
- 중복하지 않고 코드 가까이 두면 도움이 됨.
- 예를 들어, 소스 코드에서 공개용 API에는 이것의 이유/목적을 코멘트로 작성하라.
- 어떻게 그 목적을 달성하는지는 코드에 나와 있으므로 중복을 피하는 것이고(코드와 코멘트 모두를 중복으로 수정 X), - DRY
- 소스 코드에 이유를 적으니 코드 가까이 둠으로써 수정할 기회를 더 많이 만드는 것.

# 2. A Pragmatic Approach

## Topic 8. The Essence of Good Design

```
Tip 14) Good Design Is Easier to Change Than Bad Design
```

- 잘 설계 된 것은 그것을 사용하는 사람에게 잘 맞음.
- 이를 코드에 적용시킨다면, 변경하기 쉬운 것을 가리킴.
- ETC = Easier to Change
- 모든 설계 원칙은 ETC의 특수화.
- 디커플링이 좋은 이유도, 관심사 분리로 변경을 쉽게 만들어 주기 때문.
- SRP는 한 번에 한 모듈만 변경할 수 있게 도와줌.
- 좋은 네이밍은 가독성을 높여 결국 변경을 도움.

### ETC Is a Value, Not a Rule

- 가치는 결정을 도와줌(내가 이것을 해야 하는가 말아야 하는가).
- 소프트웨어 개발에 있어서 ETC는 가이드이며,
- 여러 갈랫길 사이에서 결정할 수 있게 도와줌.
- 처음에는 연습이 필요.
- 파일 저장 시, 테스트 작성 시, 버그 수정 시, 의식적으로 스스로에게 물어야 함.
- "방금 내가 한 게 전체 시스템의 변경을 어렵게 만드나 쉽게 만드나?"
- ETC에는 암묵적 전제가 잇음.
- 여러 길 중에서 어느 것이 미래에 변경을 쉽게 만들어 주는지 알 수 있다는 것.
- 대부분의 경우 상식을 따르거나 경험에서 우러난 추측을 통해 가능.
- 때로는 단서가 없음. 그러나 이 경우에도 2가지를 할 수 있음.
- 먼저, 언제든 쉽게 대체될 수 있게 하는 것. 쉬운 변경을 위한 가장 궁극적인 대안.
- 둘째로, 감각을 익히는 방법으로 취급. 한 번 예상해보고, 시간이 지난 뒤 다시 와서 어떻게 바뀌었는지 살펴보라.

## Topic 9. DRY - The Evils of Duplication

프로그래머는 유지보수 모드를 끊임 없이 유지해야 함.

- 많은 사람들이 애플리케이션이 릴리즈 되고 나서야 유지보수가 시작된다고 생각.
- 여기서 유지보수란, 버그를 고치고 기능을 강화하는 것.
- 하지만 이는 잘못된 생각.
- 우리의 이해는 매일 매일 바뀜.
- 새로운 요구사항이 도착하고,
- 기존의 요구사항은 진화함.
- 환경도 계속 바뀜.
- 무엇이 됐든 유지보수는 별개의 활동이 아닌,
- 전체 개발 프로세스의 루틴 영역.

유지보수를 어렵게 만드는 것은 중복.

- 무언가를 바꾸려면 그 대상을 찾아야 함.
- 그런데 그 바꿔야 하는 지식은 명세, 프로세스, 프로그램 들에 중복되어 있음.

소프트웨어 개발을 신뢰성 있게, 그리고 효율적으로 유지보수 하려면 DRY가 필요.

> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

```
Tip 15) DRY-Don't Repeat Yourself
```

### DRY Is More Than Code

- 1판에서 설명이 부족했는지,
- 많은 사람들이 DRY를 코드에 한정해서 생각함.
- 하지만, DRY는 지식<sup>knowledge</sup>과 의도<sup>intent</sup>의 중복에 관한 것.

