# Tools

# 16. Version Control and Branch Management

- VCS는 필수라고 생각.
- 하지만 VCS 전략은 각 상황을 고려하여 선택해야.
- 여러가지 전략과 각각의 장단점을 소개할 예정.
- 그 중에서도 "trunk-based development"가 경험적으로 확장 가능했다고 언급.
- one repository, no dev branches의 의미.

## What is Version Control?

- 시간의 흐름에 따른 파일의 변경(버전)을 추적.
- 이런 파일들의 집합과 메타데이터를 리포지토리라고 부르며 VCS의 관리 대상.
- 여러 개발자가 동시에 작업할 수 있게 해줌.
- 파일을 한 번에 한 사람만 수정할 수 있게 하는 방식으로 이를 지원.
- 이전의 변경이 의도치 않게 덮어 쓰여지는 것을 방지하는 것.

### Why Is Version Control Important?

- 버저닝과 이를 활용한 취소.
- 여러 개발자들 간 또는 여러 시점 간 협업이 가능.
- 커밋은 부수적으로 행위의 변화를 가져오기도 함.
- 커밋 로그를 남기며 변경에 설명을 더하고, 커밋에 앞서 정적 분석이나 체크리스트를 확인하는 등의 행위를 유발시킴.
- VCS를 설치하고 설정하는 등의 단점도 있지만 상대적으로 매우 값싼 비용.

### Centralized VCS Versus Distributed VCS

생략

## Branch Management

- 대비되는 단어는 단일 "trunk"

### Work in Progress Is Akin to a Branch

- 진행 중인 작업은 모두 브랜치에 대응.
- 중앙집중형 VCS에서도 마찬가지.
- 커밋되지 않은 로컬 변경과 브랜치에 커밋된 것은 개념적으로 크게 다르지 않음.

### Dev Branches

- 지속적 단위 테스트가 없던 시절, 변경은 시스템에 대한 regression 위험을 가졌음.
- 이 때는 trunk를 특별한 것으로 간주하는 것이 이치에 맞았음.
- "우리 팀은 피처 개발 브랜치를 사용하고, 트렁크에 커밋하지 않는다"
- "새로운 변경이 모든 검증을 끝내고 난 뒤에야 트렁크로"
- 이것이 제품의 불안정성을 해결하기 위한 적절한 방법이기도 하지만,
- CI나 철저한 코드 리뷰 등의 품질 관리 노력이 더 나은 해결책이라고 주장.
- (이 품질 관리 노력이 어느 정도 수준인지가 중요할 듯. 좋은 해결책이 되기 어려운 수준일 수도)
- 광범위한 개발 브랜치의 사용이 제품 안정성을 위한 수단이 되는 것은 본질적으로 잘못된 것.
- 동일한 커밋들이 결국 트렁크에 병합됨.
- 작은 병합이 더 쉬움.
- 엔지니어는 자신이 작성한 변경을 병합하는 것이 쉬움.
- 관련 없는 변경들의 병합, 그리고 나중에 병합하는 것은 어려움.
- 병합에 대한 회귀 테스트의 실패 책임자가 누구인지 찾는 것도 쉬움.
- 대규모 병합은 문제의 격리를 더 어렵게 함.
- 수정은 더더욱 어려움.
- 규모 확장에도 심각한 위험.
- 병합 자체도 더욱 어려워지고 오래 걸리기 때문.

#### HOW DID WE BECOME ADDICTED TO DEV BRANCHES?

- 오래된 개발 브랜치를 병합하는 것은 안정성을 낮춘다고 판단.
- 그래서 브랜치 병합은 위험하다고 결론.
- 브랜치 기반 개발 전략을 버리고 테스팅으로 문제를 해결하지는 않음.
- 대신, 속도를 낮추고 증상을 조율하는 데 시간을 보냄.
- 조직이 커지면서 브랜치는 늘어나고, 브랜치 병합 전략을 조율하는 데 더 많은 노력이 들어감.
- 일부 개발자는 빌드 마스터/머지 코디네이터/컨텐츠 관리 엔지니어가 됨.
- 대규모 병합이 되면 다른 개발 중인 브랜치들은 이를 또한 반영해야 하며 다시 테스트 해야 함.
- 이런 병합과 반복 테스트는 pure overhead.
- 패러다임의 전환이 필요.
- CI와 테스팅에 크게 의존하며, 빌드를 항상 그린으로 유지하고, 런타임에는 불완전하고/테스트되지 않은 피처는 비활성화 하는, 트렁크 기반의 개발을 권장.
- 하나의 Source of Truth만 있어야 함.
- 릴리즈를 위한 하나의 리비전만 있게 됨.
- 이는 1장에서 소개했던 "shift left"(이제서야 나오는 구나) 접근법.

### Release Branches

- 릴리즈 간격이 몇 시간 보다 길다면 릴리즈 브랜치를 만드는 게 합리적일 수도.
- 그리고 만약 릴리즈 사이에 큰 결함이 발견되면 트렁크에서 릴리즈 브랜치로 수정 사항을 cherry-pick.
- 개발 브랜치와 비교하면 릴리즈 브랜치는 일반적으로 무해함.
- 개발 브랜치와 릴리즈 브랜치의 주요 차이는 종료 상태.
- 릴리즈 브랜치는 결국엔 제거됨(abandoned).
- 하지만 개발 브랜치는 계속 트렁크로 병합되고, 다른 팀에 의해 추가적으로 분기되기도.
- 높은 수준의 조직에서는 릴리즈 브랜치가 거의 없다고 함.
- 지속적 배포(하루에도 여러 번 릴리즈)를 달성하는 곳은 릴리즈 브랜치를 생략하는 경향.
- 단순하게 수정을 반영하고 재배포 하는 것이 더 쉬움.
- cherry-pick과 브랜치는 불필요한 오버헤드.
- 물론, 고객에게 명시적인 릴리즈 결과물을 제공하는 곳에서는, 고객에게 정확히 무엇이 전달되었는지가 중요하기에, 이 방식의 적용은 어려울 수도.
- 복잡한 브랜치와 머지 전략은 생산성의 장애물.
- 트렁크를 안정된 상태로 유지하는 다른 방법들이 있음.

## Version Control at Google

- 구글에선 50,000명의 엔지니어가 공유하는 하나의 리포지토리를 사용(monorepo).
- 구글에서 진행하는 대부분의 프로젝트가 여기에 모여 있음. 오픈소스만 제외.
- Gmail 등의 공개 제품 외에 제품 개발을 지원하는 데 필요한 내부 인프라까지도 포함.
- Piper라고 불리는 중앙화된 인하우스 VCS를 사용.
- 하루에 보통 60,000 ~ 70,000개의 커밋이 일어남.
- 트렁크에 새로운 클라이언트를 생성하고, 파일을 추가하고, 리뷰되지 않은 변경을 커밋하는 것은 15초 정도 소요.
- 참고로, Piper는 사내에서 만들어 졌기에 커스터마이징도 쉬움.
- 리포지토리 하위 트리의 커밋들을 승인할 수 있는 엔지니어 이름이 적힌 OWNERS라는 파일들이 있음.
- 이를 활용해서 Piper가 소유/승인이 좀 더 잘 이뤄질 수 있게 하고 있음.

### One Version

- Piper 도구가 강력하긴 하지만, 그것만으로는 지금과 같은 협업은 어려움.
- "One Version"이라고 불리는 버전 컨트롤 '정책'이 필요.
- 이 정책은 "Single Source of Truth" 개념의 확장이며 아래와 같음.

> Developers must never have a choice of "What version of this component should I depend upon?

- 개인에겐 이런 선택의 제한이 장애물로 보일 수도.
- 그러나 조직 차원에서 이는 효율적인 스케일링의 매우 중요한 요소.

### (Nearly) No Long-Lived Branches

- One Version Rule에는 좀 더 깊은 생각과 정책들이 내포되어 있음.
- 그 중 가장 중요한 것은 아래와 같음.

> development branches should be minimal, or at best be very short lived

- Phoenix Project의 "reducing work-in-progress" 교훈은 개발 브랜치에 적용한 것.
- 트렁크에 작은 증분만이 이뤄져야 하고, 정기적으로 커밋 되어야 함.
- 그리고 준비 되기 전까지는 런타임에 비활성화 되어야 함.
- 더불어, 가능하다면 가시성을 통해 다른 개발자에게 숨겨져야.
- 혹은 두 의존성이 하나의 프로그램 내에서 공존할 수 있도록 설계되어야(패키지/클래스 명 등의 충돌이 없어야 한다는 의미로 들림).
- 구글에서는 1,000개 팀에서 이런 개발 브랜치를 가진 곳은 2군데.
- 흔한 일이 아니며 매우 특수한 이유를 가짐.

### What About Release Branches?

- 많은 구글팀에서 릴리즈 브랜치를 사용(제한된 체리 픽과 함께).
- 월간 릴리즈를 준비를 하면서 다음 릴리즈를 작업하는 경우에 이상적.
- 체리 픽을 최소화하고, 트렁크와의 재병합 계획은 금지.
- 아마도 여기서의 릴리즈 브랜치는, 트렁크에서 릴리즈 브랜치를 따고 그 릴리즈 브랜치로 배포가 나가는 형태인 것으로 보임.

## Monorepos

- One Version 유지를 쉽게 만들어 줌.
- 어떤 버전이 오피셜인지 결정하는 프로세스도 없고,
- 어떤 리포지토리를 봐야 하는지 고민할 필요도 없음.
- 빌드 도구 입장에서도 리포지토리를 고르는 절차 없음.
- 이런 일관성은 새로운 도구나 최적화 도입 등의 스케일링을 쉽게 도와줌.
- 엔지니어들의 코드나 시스템 디자인 결정을 공유하기도 쉬움.
- 다만, monorepo 방식이 결국엔 One Version을 위한 수단.
- 이 목적을 달성하기 쉽다면 다른 수단들도 충분한 대안이 될 수 있음.
