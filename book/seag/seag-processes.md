# Processes

# 8. Style Guides and Rules

- 대부분의 엔지니어링 조직에서는 코드베이스를 관리하는 규칙을 가짐.
- 소스 파일의 저장소, 코드 포매팅, 네이밍, 패턴, 예외, 스레드, ...
- 규칙은 곧 법. 단지 제안이나 추천이 아닌, 강한 의무를 가진 법.
- 한편, 가이드는 추천과 베스트 프랙틱스의 제공.
- 가이드는 룰과 다르게 변이의 여지가 있음.
- 구글에서 스타일 가이드는 언어 마다 다양.
- Dart, R, Shell 같은 언어에서는 간결(네이밍과 포매팅 같은 주요 원칙 대해서만 집중).
- C++, Python, Java 같은 곳에서는 더 많은 디테일을 포함.
- 이런 스타일 가이드들은 코드베이스를 유지보수 가능한 상태로 유지하기 위한 목적들에서 하나씩 비롯됨.

## Why Have Rules?

- "좋은" 행동은 장려하고 "나쁜" 것은 억제하기 위함.
- 여기서 "좋은"과 "나쁜"은 조직이 무엇을 중요하게 여기느냐에 따라 달라짐.
- 조직의 가치를 먼저 생각해야 하는 이유임.
- 잘 정착된 규칙과 가이드는 코딩의 공통 어휘 모습을 갖춰나감.
- 이는 엔지니어로 하여금 그들이 말하고 싶은 것 대신 코드가 말해야 하는 것에 집중하게 도와줌.

## Creating the Rules

- "What rules should we have?"는 핵심 질문이 아님.
- "What goal are we trying to advance?"가 핵심.
- 목적에 초점을 두면 어떤 규칙이 유용한지 판별하기 쉬움.

### Guiding Principles

- 구글에는 3만명의 엔지니어들이 있음.
- 그만큼 다양한 기술과 배경들이 함께 존재.
- 각 조직에 맞게 가치를 다르게 산정하긴 하지만,
- 시간과 규모의 확장에도 엔지니어링 환경을 지속시키는 것이 공통된 목표.
- 이런 맥락에서 규칙의 목적은, 개발 환경의 복잡성을 다루고, 코드베이스를 관리 가능한 상태로 유지시키며, 개발자의 생산성을 보호하는 것.
- 여기서 트레이드 오프가 발생.
- 규칙이 많으면 선택의 제약이 많아짐.
- 하지만 충돌을 줄이고 일관성을 얻을 수 있음.
- 이런 것들을 고려할 때, 아래 5가지가 규칙 개발에 도움이 됨을 발견.
  - Pull their weight
  - Optimize for the reader
  - Be consistent
  - Avoid error-prone and surprising constructs
  - Concede to practicalities when necessary

#### Rules must pull their weight

- 스타일 가이드로 추가되는 모든 것에는 비용이 따름.
- 새로 배워야 하고 적응해야 하며 기억해야 함.
- 따라서, 자명한 것들은 규칙에서 제외시키려 노력.
- 예를 들어 C++의 `goto` 사용 금지를 규칙으로 삼지는 않음.
- 이미 개발자들은 이를 피하려는 경향이 있는데, 굳이 규칙으로 넣는 것은 오버헤드.
- 한 두명의 잘못으로 만드는 규칙은 전체의 정신적 부담으로 이어짐. 이는 스케일링에 걸림돌.

#### Optimize for the reader

- 규칙의 또 다른 원칙은 코드의 저자가 아닌 독자에 최적화하라는 것.
- 코드는 작성되는 시간보다 읽히는 시간이 더 김.
- 예를 들어, 파이썬에서 조건문<sup>conditional expression</sup>이 `if` 문장보다 짧음.
- 하지만 읽기에는 더 어려움. 따라서 조건문의 사용을 금하고 있음.
- 같은 맥락으로 엔지니어들은 각자의 코드에 의도한 행위의 증거를 명시적으로 남겨야 함.
- 예컨대, Java, JavaScript, C++ 스타일 가이드에서는 슈퍼클래스 메서드를 오버라이드 할 때 override 애노테이션이나 키워드를 사용하도록 강제.
- API에는 상호작용을 충분히 추론할 수 있는 명확한 도큐먼트를 남김.
- 사용하려는 함수의 구현을 보지 않고도 알 수 있게 하는 것이 목적.
- 도큐먼트 주석(파일, 클래스, 함수 블럭 앞에 작성하는)는 코드의 설계나 의도를 담음.
- 구현 주석은 불명확한 선택을 강조하거나 정당화하고, 까다로운 부분을 설명하며, 코드의 중요한 부분을 드러냄.

#### Be consistent

- 구글에서는 어느 회의실에서도 화상 회의 설정은 동일한 인터페이스를 가짐.
- 새로운 설정을 배우느라 시간을 낭비하지 않아도 됨.
- 이는 소스 코드에 대해서도 마찬가지.
- 일관성은 어느 엔지니어든지 코드베이스의 익숙하지 않은 부분에 뛰어들게 하고 빠르게 일할 수 있게 도움.
- 각 프로젝트는 고유한 성격을 갖지만, 도구와 기술과 라이브러리는 모두 동일.

#### Advantages of consistency

- 일관성으로 인한 제약은 분명히 발생. 하지만 편익은 큼.
- 코드를 다룰 때도 일관성이 자유를 제한하는 것 같지만, 더 적은 노력으로 더 많은 일을 할 수 있게 도와줌.
- 일단, 코드를 작성하거나 읽을 때, 코드가 어떻게 표현되느냐보다 코드가 무엇을 하는지에 집중할 수 있음.
- 일관성은 스케일링을 돕기도 함. tooling이 조직 스케일링의 핵심인데, 일관성이 있으면 코드를 만들고 수정하고 이해하는 도구 작성이 쉬움.
- 엔지니어의 팀 간 이동에도 도움. 좀 더 빠르고 쉽게 코드에 적응.
- 시간이 흐름(엔지니어가 프로젝트를 떠나고, 새로운 사람이 들어오고, 오너십이 바뀌고, 프로젝트가 병합되거나 쪼개지고, ...)에도 탄력성을 유지.

#### Avoid error-prone and surprising constructs

- 구글 스타일 가이드는 언어에서 다소 놀랍거나 일반적이지 않거나 교모한 문법 사용을 제한함.
- 복잡한 피처는 종종 한 눈에 파악하기 어려운 함정을 가지고 있음.
- 이를 깊이 생각하지 않고 작성하는 것은 버그를 만들어 낼 수도.
- 작성 시에는 잘 고려가 되었더라도 이후에 이를 다루는 엔지니어에게도 문제.
- 파이썬 스타일 가이드의 경우 리플렉션 같은 [power features](https://google.github.io/styleguide/pyguide.html#219-power-features)를 금지.
- 파이썬에서의 `hasattr()`과 `getattr()`은 문자열로 객체의 속성에 접근할 수 있게 함.

```py
// some_file.py:
A_CONSTANT = [
'foo',
'bar',
'baz',
]

// other_file.py:
values = []
for field in some_file.A_CONSTANT:
values.append(getattr(my_object, field))
```

- `foo`, `bar`, `baz` 필드에 접근한다는 사실을 어떻게 알 수 있겠는가?
- 독자를 위한 어떠한 명확한 증거도 없음. 따라서 검증도 어려움.

#### Concede to practicalities

- 가끔 필요하다면 최적화나 실용성에 규칙을 포기하기도.
- C++ 스타일 가이드가 익셉션 사용을 금하고 있지만, 컴파일러 최적화를 위해 `noexcept`의 사용을 허용하기도.
- 성능 외에도 상호호환성 케이스도 존재.

### The Style Guides

- 언어 스타일 가이드에는 크게 3가지 범주가 있음.
- Rules to avoid dangers
- Rules to enforce best practices
- Rules to ensure consistency

#### Avoiding danger

- 스타일 가이드에는 언어 특징에 관련하여 기술적 이유로 해야 하는 것과 하지 말아야 할 것을 명시.
- 정적 멤버나 변수 사용, 람다 표현식 사용, 예외 처리, 스레딩 생성, 접근 제어, 클래스 상속 등.
- 사용하기 어렵거나 제대로 사용하기 어려운 것에 대한 규칙들도 포함.
- 각각의 규칙에는 장단점과 함께 결론에 이르기까지의 설명도 포함.

#### Enforcing best practices

- 소스 코드 작성의 베스트 프랙틱스들도 담고 있음.
- 이는 코드 베이스를 건강하고 유지보수 가능하게 도와줌.
- 예컨대, 코드 저자가 주석을 어디에 어떻게 남겨야 하는지를 가이드.
- 일반적인 주석 컨벤션을 기본으로 하고, 이를 좀 더 확장하여 의도가 불분명할 수 있는 곳에도 주석을 작성해야 함.
- switch 문이 완료되지 못하는 경우, 빈 예외 캐치 블럭, 템플릿 메타프로그래밍 등이 이에 해당.
- 그 외에도 소스 파일을 구조화하는 방법, 네이밍, 가독성을 위한 포맷팅 등 다양.
- 새롭거나 아직 잘 이해되어지지 않은 언어 피처는 제한을 둠.
- 만약 엔지니어가 이를 사용하고 싶다면 스타일 가이드 소유자에게 예시와 함께 토론하며 포함시킬 수도.

#### Building in consistency

- 사소한 것들도 스타일 가이드에 많이 포함되어 있음.
- 이들은 기술적으로 큰 영향을 가지는 것들이 아님.
- 네이밍 컨벤션, 들여쓰기 스페이싱, 임포트 순서 등.
- 무엇을 선택하든 다른 선택에 비해 큰 이점을 가지는 것도 아님.
- 하지만 하나를 선택함으로써 끝없는 논쟁 순환을 줄이고 앞으로 나아갈 수 있음.

## Changing the Rules

- 시간이 지나면서 스타일 가이드를 결정했던 배경 등이 계속 바뀜. 언어의 버전도 계속 올라감.
- 규칙이 다른 모습으로 바뀔 때가 되었는지를 알아차리는 것이 스타일 가이드를 계속 최신화해 나가는 중요한 프로세스의 일부.
- 주어진 결정의 추론을 문서화 해 두는 것은 무언가 바뀌어야 할 때를 인지하는 데 큰 도움이 됨.
- 과거의 좋은 결정이 지금은 그렇지 않을 수 있음.
- 그 외 내용은 기록 생략.

## Guidance

- 규칙<sup>rule</sup>에 더해 프로그래밍 안내<sup>guidance</sup>도 다양한 형태로 제공.
- 엔지니어링 경험의 지혜 모음이며, 그 동안 배운 교훈으로부터 추출한 베스트 프랙틱스를 문서화한 것.
- 규칙은 "must"이고 안내는 "should".
- 지침 풀의 한 예시는 자주 사용하는 랭기지들의 지침서.
- 스타일 가이드는 규범적이고 무엇을 해야 하고 하지 말아야 하는지를 강제하는 반면,
- 이 지침서는 피처들을 안내하고 설명함.
- 한 사례로, 새로운 코드베이스에서 사용해야 하는 언어에 익숙하지 않다면 "<Language>@Google 101" 코스 등을 밟는다고 함.

## Applying the Rules

- 규칙은 잘 시행되기만 하면 큰 가치를 가져다 줌.
- 규칙은 사회적으로(교육과 훈련을 통한) 또는 기술적으로(도구를 통한) 시행될 수 있음.
- 구글에선 규칙이 필요로 하는 베스트 프랙틱스들을 훈련시킬 여러 공식적 코스들이 존재.
- 또한 문서들을 정확하고 최신 상태로 유지할 수 있는 리소스를 꾸준히 투자.
- 코드 리뷰가 가이드나 규칙 학습에 중요한 역할을 수행.
- 물론 도구에 의한 자동 검증도 매우 중요.
- 자동화 된 도구는 또한 규칙이 해석되고 적용되는 방식의 편차를 최소화 시켜줌.
- 그리고 스케일링에도 도움.
- 하지만 모든 것을 도구로 해결할 수는 없음.
- 일부 기술적 규칙들은 확실히 살마의 판단을 필요로 함.
- 어떤 규칙들은 기술적이라기보다 사회적.
- 잘 정의하기 어렵고 도구로 해결하기에는 복잡하며 비싸질 수 있는 것들.
- 예를 들어, 한 번에 변경이 일어나는 크기를 작게 유지하는 것이 있음.
- 크기가 작으면 리뷰하기 쉽고 빠르며 더 통찰력 있께 살펴볼 수 있음.
- 버그를 만들어 낼 가능성도 적어짐.
- 하지만 작은 것의 명확한 정의는 어려움.
- 한 줄의 변경이 때로는 수백 줄의 변경보다 더 어려울 수 있음.
- 이런 것들은 도구로 자동화 하는 대신 사회적 해결을 통해 극복.

### Error Checkers

- 랭귀지 용법을 다루는 많은 규칙들이 정적 분석 도구로 시행 가능.
- C++의 경우 대략 90%까지 자동 도구로 검증할 수 있었다고 함.
- 자동화된 검증은 코드 저자가 많은 규칙을 기억해야 하는 부담을 덜어줌.
- 규칙 준수의 비용을 낮게 유지하면 엔지니어들이 좀 더 행복하게 이를 따라갈 수 있음.

### Code Formatters

- 일반적으로 스타일 체커와 포매터를 이용해서 코드의 일관된 포매팅을 수행.
- 한 가지 흥미로운 건 라인 길이에 대한 질문이 멈췄다는 것.
- 엔지니어들은 단지 스타일 체커를 실행하고 다음 단계로 넘어감.
- 코드 리뷰도 더 적은 비용으로 이뤄짐.
- 가장 규모가 큰 코드베이스를 매니징할 때, 사람이 수행한 포매팅과 자동화 된 도구를 이용한 결과를 비교한 적이 있음.
- 평균적으로 로봇이 더 나은 결과를 보였음.
- 때로는 매트릭스 포매팅 같이 도메인 지식이 중요할 때가 있으며 이 때는 사람이 더 나은 결과를 보임.
- 구글에선 이런 포매팅을 제출 전 체크에서 수행한다고 함.

# 9. Code Review

- 코드 리뷰의 정의는 단순하나, 코드 리뷰 프로세스의 구현은 매우 다양.
- 구글에서는 모든 변경이 커밋 전 리뷰를 받아야 하며, 모든 엔지니어는 리뷰를 시작하고 변경을 리뷰해야 하는 책임이 있음.
- 코드 리뷰는 일반적으로 프로세스와 도구의 지원 모두 필요.
- 구글에서는 Critique라는 도구를 사용하긴 하나,
- 이 챕터에서는 특정 도구보다는 프로세스를 집중적으로 다룸.
- 버그를 탐지하는 등의 코드 리뷰 이점은 잘 정립되어 있고 명확함.
- 그러나 감지하기 힘든 다른 이점들(심리적 효과를 비롯한)도 존재.

## Code Review Flow

- 코드 리뷰는 소프트웨어 개발의 많은 단계에서 일어남.
- 구글에서는 커밋 전에 변경을 리뷰하며, 이를 precommit review라고 부름.
- 코드 리뷰의 최종 목적은 다른 엔지니어에게 변경에 대한 동의를 얻는 것.
- 동의를 표현할 때 "looks good to me"(LGTM) 라고 태깅.
- 구글에서의 코드 리뷰는 아래의 단계로 이뤄짐.
  1. 저자가 코드베이스에 변경을 작성하고 리뷰 도구를 활용해 리뷰를 시작.
  2. 그리고 저자가 먼저 셀프 리뷰를 하거나 자동화 된 리뷰 코멘트를 확인. 저자가 만족했다면 1명 이상의 리뷰어에게 변경사항을 메일로 보냄.
  3. 리뷰어는 도구를 활용해 변경을 확인하고 코멘트를 남김. 일부 코멘트는 명시적인 해결을 요구. 어떤 것은 단지 정보 전달.
  4. 저자는 피드백을 반영하여 변경을 수정하고 다시 스냅샷을 업로드. 그리고 리뷰어에게 답장. 3~4단계는 계속 반복될 수 있음.
  5. 리뷰어가 만족한다면 LGTM과 함께 변경을 수락. 기본적으로는 1개의 LGTM만 받아도 통과.
  6. 변경이 LGTM으로 표기되면 저자는 변경을 코드베이스로 커밋.

## How Code Review Works at Google

- 코드리뷰의 대략적인 프로세스를 알아보았음.
- 하지만 디테일이 중요.
- 구글에서는 변경에 대해 "승인"을 필요로 하는 리뷰의 3가지 측면이 있음.
- 먼저, 정확성과 표현력에 대한 검사.
  - 코드가 적절한지, 저자가 주장한 동작을 하는지.
  - 종종 팀 멤버가 진행하지만 꼭 그래야 하는 것은 아님.
  - 승인 시 LGTM 권한 "비트"에 반영됨.
- 다음으로, 코드 소유자로부터의 적절성 여부 검사.
  - 구글에서는 코드베이스가 계층을 가진 트리 구조로 되어 있고,
  - 각 부분마다 소유자가 있음.
  - 보통 테크 리드나 특정 영역의 전문가.
  - 소유 권한을 얼마나 넓게 또는 얇게 가져가는지는 팀 마다 다름.
- 마지막은 언어의 "가독성"을 검사.
  - 스타일 가이드나 베스트 프랙틱스를 잘 따르고 있는지 확인.
- 이런 통제 레벨이 부담스럽게 여겨질 수도 있고 때로는 정말 그러기도 함.
- 그러나 보통은 한 사람이 이 3가지 역할을 수행하여 속도를 높임.
- 그리고 저자가 마지막 2개의 역할을 수행하기도.
- 보통은 2가지 단계를 거침. 동료 엔지니어로부터 1개의 LGTM을 얻고, 코드 소유자나 가독성 리뷰어에게 승인을 얻는 것.
- 이렇게 하면 코드리뷰를 2가지 관점에서 살펴볼 수 있게 하면서도 시간을 절약해 줌.

## Code Review Benefits

- 구글에서 코드 리뷰는 아무리 작은 변경이라고 하더라도 필수.
- 코드리뷰가 코드 변경의 속도를 늦추기도 하지만 그래도 필수.
- 장기적으로 더 큰 이점을 가져다 준다고 생각하기 때문.
- 아래의 6가지.
  - Checks code correctness
  - Ensures the code change is comprehensible to other engineers
  - Enforces consistency across the codebase
  - Psychologically promotes team ownership
  - Enables knowledge sharing
  - Provides a historical record of the code review itself

### Code Correctness

- 다른 내용은 일반적인 것들이었고 아래 내용이 기억에 남음.
- 정확성 평가가 주관적이 되는 것을 막기 위해, 저자의 접근 방식을 존중해야 함.
- 리뷰어는 개인적 의견 때문에 대안을 제시할 수 없음.
- 대안은 표현력(덜 복잡하게 하는 등)나 기능성(더 효율적이게 하는 등)을 향상시킬 수 있는 경우에만 제시.
- 일반적으로 엔지니어들은 완벽한 해결책에 대한 동의를 기다리기보다, 코드베이스를 향상시키는 변경에 대해 승인하도록 권장됨.
- 이는 코드 리뷰의 속도를 높임.

### Comprehension of Code

- 코드리뷰는 일반적으로 저자가 아닌 다른 사람이 변경을 검사하는 첫 번째 기회.
- 뛰어난 엔지니어라도 저자의 관점에 치우치느라 발견하지 못한 것을 리뷰어가 피드백 해 줄 수 있음.
- 코드리뷰는 변경이 더 많은 청중들에게 이해가능한지를 검사하는 첫 번째 테스트.
- 이는 코드가 작성보다 읽히는 데 더 많이 사용되기 때문에 매우 중요.
- 따라서 저자와는 다른 관점을 지닌 리뷰어를 찾는 게 도움이 됨.
- 리뷰어가 설계와 관련하여 저자에 대해 존중을 가져야 하는 것과 별개로,
- 저자는 "고객은 항상 옳다"는 마인드로 코드 표현력에 관한 리뷰어의 질문을 바라보아야 함.
- 지금 받은 질문들은 시간이 지나면서 다른 사람들에 의해서도 계속 반복될 것.
- 접근법이나 로직을 바꾸라는 것이 아님. 하지만 좀 더 명확하게 설명할 필요는 있음.
- 코드 정확성과 함께 코드 표현력은 LGTM의 주요 요소.

### Code Consistency

- 규모가 확장 됨에 따라 당신이 작성한 코드는 의존성을 가지며 유지보수도 이뤄짐.
- 많은 사람들이 당신의 코드를 읽고 이해해야 함.
- 따라서 코드는 일관성 표준을 따라야 하고, 과도하게 복잡한 것도 피해야 함.
- 리뷰어들은 이 코드가 코드베이스의 표준에 따라 얼마나 잘 살아갈 수 있는지(코드의 건강) 평가해야 함.
- 정확성과 표현력을 나타내는 LGTM과 별개로 코드 가독성은 유지보수를 위한 것.
- 특정 프로그래밍 언어를 위한 베스트 프랙틱스를 잘 따랐는지, 구글 코드 리포지토리의 언어들과 일관성을 갖췄는지 등을 평가.

### Psychological and Cultural Benefits

- 코드리뷰는 중요한 문화적 이점도 가짐.
- 신입 때 느꼈던 코드리뷰의 가장 큰 이점.
- 소프트웨어 엔지니어들에게 코드가 "그들의 것"이 아님을 인지하게 함.
- 자신의 결과물을 자랑스럽게 여기고 비판을 꺼리는 것은 인간의 본성.
- 코드리뷰는 이런 비판의 감정적 완충 작용을 하기도.
- 좀 더 정제되고 중립적인 비판을 주고 받도록 돕기 때문.
- 코드리뷰의 또 다른 심리적 이점은 "validation".
- 자신에게 너무 비판적인 경우 이 validation은 안정감을 제공.
- 마지막으로 코드리뷰를 시작하기 전 한 번 더 변경에 대해 신경쓰게 됨.
- 나중으로 미룰 수도 있었던 단위 테스트를 마무리 하고 코드리뷰를 올리는 등.

## Code Review Best Practices

- 코드리뷰는 조직에 마찰과 지연을 가져올 수도.
- 이는 코드리뷰 그 자체의 문제라기 보단, 어떤 코드리뷰 구현을 골랐느냐의 문제.
- 코드리뷰를 가치 있는 프로세스로 자리 잡게 하려면 몇 가지 베스트 프랙틱스가 필요.
- 이들 대부분은 프로세스를 민첩하고 빠른 상태로 유지시켜 스케일링에 유리하게 해 줌.

### Be Polite and Professional

- 신뢰와 겸손의 구글 문화는 코드리뷰에도 적용.
- 예컨대, 코드 표현력에 관해서는 단지 한 명의 다른 엔지니어로부터 LGTM을 얻는 것으로 충분.
- 엔지니어들은 추가적인 리뷰 단계 없이, 변경 사항이 제출될 수 있다는 것을 이해하고 코멘트와 LGTM을 남김.
- 일반적으로, 리뷰어는 저자의 접근 방식을 존중해야 하고, 저자의 접근법에 결점이 있을 때만 이를 지적해야 함.
- 만약 저자가 다른 접근법들이 동일하게 유효함을 증명할 수 있다면, 리뷰어들은 저자의 선호를 받아들여야만 함.
- 각 접근법에서 결점이 발견된다고 하더라도 저자나 리뷰어 모두 리뷰를 배움의 기회로 삼을 수 있음.
- 리뷰어는 저자의 특정 접근법에 기반하여 성급하게 결론으로 넘어가는 것을 유의해야 함.
- 접근법이 잘못됐다고 가정하기 전에, 왜 이 방식으로 되었을지 질문하는 것이 좋음.
- 리뷰어는 코드리뷰를 24시간 내에 해야 함.
- 만약 이 시간 내에 할 수 없다면, 최소한 변경 사항을 보았고 가능한 빠른 시간 내에 리뷰를 할 것이라고 응답해 주는 것이 좋은 프랙틱스.
- 리뷰어는 조금씩 나눠서 코드 리뷰를 하면 안 됨. 이는 저자에게 고통.
- 리뷰어 뿐만 아니라 저자에게도 전문성이 요구됨.
- 코드는 당신의 것이 아니라 팀의 것. 한 번 코드베이스에 들어가면 더 이상 당신의 것이 아님.
- 당신의 접근법에 대한 질문에 열려 있어야 함.
- 왜 그 방식을 취했는지 설명할 준비가 되어 있어야 함.
- 저자의 책임 중 하나는 코드를 이해 가능하고 미래에도 유지 보수 가능한 상태로 유지하는 것.
- 각 리뷰어의 코멘트를 TODO 아이템으로 간주하는 것은 중요.
- 무조건 리뷰 코멘트를 수용해야 하는 것은 아니지만 최소한 다뤄지긴 해야 함.
- 만약 코멘트에 동의하지 않는다면 리뷰어에게 이를 알리고 왜 resolved로 마킹하지 않는지 설명.
- 이런 논쟁이 일어날 때 정중함이 유지되게 하고자 PTAL(please take another look)을 부탁하는 것도 방법.
- 코드리뷰는 저자와 리뷰어 모두에게 배움의 기회임을 기억. 동의하지 않는 것으로부터 인사이트를 종종 얻기도 함.

### Write Small Changes

- 변경을 작게 가져가는 것이 코드리뷰를 민첩하게 유지하는 데 가장 도움되는 프랙틱스.
- 구글에선 규모가 큰 변경은 권장하지 않으며, 리뷰어는 너무 큰 변경은 정당하게 거절할 수 있음.
- 여기서 "작은" 변경은 일반적으로 200라인이 넘지 않는 코드를 가리킴.
- 참고로, 구글에서 변경들의 35% 이상이 한 파일에 대한 것이라고 함.
- 변경이 작을수록, 리뷰를 기다리는 시간을 줄이고, 읽기도 쉽고, 버그를 찾아내기도 쉽고, ...
- 하지만 새로운 메이저 기능 개발 등 때로는 작은 변경의 강제가 오버헤드가 되기도 함.
- 때로는 큰 변경도 허용하는 것이 도움이 될 것.

### Write Good Change Descriptions

- 변경 설명의 첫 줄에는 요약의 의미로 변경 유형을 명시해야 함.
- 첫 줄은 매우 중요. 코드리뷰 툴에서 보이는 제목이기도 하며, 이메일의 제목, 코드 히스토리 요약 등에 표기.
- 설명에는 세부적인 내용도 담겨 있어야 함. "Bug fix"는 리뷰어나 미래 코드 독자에게 도움 X.
- 여러 수정이 일어난다면 열거해서 알려줘야 함.
- 설명은 변경의 역사적 자료이며, 구글의 코드 서치 같은 도구에서 내용 검색에도 활용되고, 이후의 버그 픽스에 유용한 도움이 됨.
- 변경의 설명 뿐만 아니라 구현 곳곳에도 의도가 제대로 드러나지 않는 부분이 있다면 주석을 사용하라는 이야기도.

### Keep Reviewers to a Minimum

- 구글에서 대부분의 코드리뷰는 리뷰어가 1명.
- 1명에 의해 코드 정확성, 소유자의 승인, 언어 가독성 검사가 이뤄지기에, 조직 규모 확장에도 잘 녹아들 수 있음.
- 리뷰어가 많으면 여러 통찰력을 이끌어낼 수 있긴 함.
- 하지만 이는 결과적으로 마이너스.
- 가장 중요한 LGTM은 첫 번째 것이며, 이후의 것들은 당신이 생각하는 만큼의 가치를 더해주지 않음.
- 추가 리뷰어들의 비용은 그것이 가져다 주는 가치를 빠르게 넘어가버림.
- 코드리뷰 프로세스의 최적화는 엔지니어가 올바른 일을 할 것이라는 신뢰를 바탕으로 함.
- 때로는 여러 리뷰어가 참여하는 게 좋기도 함. 이 경우에는 각 리뷰어가 서로 다른 관점으로 리뷰를 진행해야 함.

### Automate Where Possible

- 코드리뷰는 사람 프로세스이며 사람의 입력이 중요.
- 하지만 자동화 될 수 있는 부분이 있다면 그렇게 해야 함.
- 대표적인 예는 변경에 대한 정적 분석.
- 구글에서는 코드리뷰 도구가 presubmit이라 부르는 단계에서 여러 자동화를 수행.
- 문제가 없는지를 감지하고 필요하면 변경을 거절. 그리고 저자에게 이 문제를 해결하라고 알림.
- 이는 코드리뷰 프로세스 자체를 돕기도 하지만, 리뷰어들이 보다 중요한 것에 집중할 수 있게 도와줌.

## Types of Code Reviews

- 코드리뷰 마다 유형이 있으며, 각각에 맞는 방식을 취해야 함.
- 보통 아래 유형 중 하나.
  - Greenfield reviews and new feature development
  - Behavioral changes, improvements, and optimizations
  - Bug fixes and rollbacks
  - Refactorings and large-scale changes

### Greenfield Code Reviews

- 가장 흔치 않은 코드리뷰 유형은 완전히 새로운 코드(따라서 greenfield 리뷰로 불림).
- 그린필드 리뷰는 코드가 시간 테스트를 이겨낼 수 있는지를 판단하는 가장 중요한 시간.
- 시간 테스트라 함은 시간이 흐르고 규모가 커지고 내재된 가정이 바뀌는 변화에도 코드가 쉽게 유지될 수 있는냐에 대한 것.
- 새로운 코드의 도입은 단지 대안을 제공하는 것이 아니라 실제 문제를 해결해야 함.
- 구글에서는 새로운 코드가 필요할 때 대규모의 디자인 리뷰를 거침.
- 이는 코드리뷰와는 별개. 코드리뷰에서는 과거에 결정된 디자인 결정에 대해 논쟁 하지 않음.
- 코드의 지속 가능성을 보장하고자 그린필드 리뷰는 API가 합의된 디자인에 부합하는지 확인.
- 그리고 완전히 테스트 되어야 함. 모든 API 엔드포인트가 단위 테스트를 가지는 것.
- 더불어, 코드는 적절한 소유자를 가져야 하고, 충분한 주석이 달려 있어야 하며, 추가적 문서들도 필요하면 제공되어야 함.

### Behavioral Changes, Improvements, and Optimizations

- 대부분의 코드 변경은 이미 존재하고 있는 코드에 대한 수정.
- API 엔드포인트의 수정, 기존 구현의 개선, 성능 등의 요소에 대한 최적화 등이 이에 해당.
- 그린필드에 적용되었던 가이드라인이 여기에도 적용됨.
  - 이 변경이 꼭 필요한 것인지?
  - 이 변경이 코드베이스를 더 향상시키는지?
- 때로는 코드 삭제가 최고의 개선이 되기도 함.
- 행위의 수정은 필연적으로 적절한 테스트의 수정도 동반.
- CI를 통해 회귀영향은 없는지도 확인.
- 이는 최적화에도 필요한 것들.
- 최적화에는 리뷰어가 조언을 할 수 있도록 추가적으로 성능 벤치마크도 필요.

### Bug Fixes and Rollbacks

- 필연적으로 버그 수정 변경을 제출하게 됨.
- 이 때는 다른 이슈를 함께 다루려는 유혹을 피해야 함.
- 이는 코드 리뷰의 크기를 늘리고, 회귀 영향 테스트도 어렵게 만들며, 롤백도 힘들어짐.
- 버그 수정은 그 자체에만 집중해야 하고, 관련된 테스트만 함께 수정.
- 버그는 보통 현재의 테스트가 충분하지 않음을 드러내며,
- 따라서 버그 수정의 리뷰어는 단위 테스트도 함께 수정되었는지 물어보는 것이 중요.
- 때때로 구글처럼 큰 규모의 코드베이스에서 일어나는 수정은 예상치 못한 의존성 실패를 일으키기도 함.
- 이 경우 롤백을 허용하며, 이전 변경의 리버트라고 하더라도 코드리뷰는 여전히 필요.
- 잠재적 롤백 가능성을 가진 어떤 변경이든 가능한 작고 원자적이어야 함.
- 그래야 롤백 시 추가적 문제를 일으킬 가능성이 적고, 빠르게 롤백 수행도 가능.

### Refactorings and Large-Scale Changes

- 제목이랑 내용이랑 매칭이 잘 안 됨.
- 사람이 아닌 기계가 만들어 내는 코드 변경들이 있으며,
- 이 경우에도 비슷하게 코드리뷰를 진행한다는 이야기.

# 11. Testing Overview

- 2000년대 이후로 개발자 주도의 자동화된 테스트가 급속도로 발전.
- 이는 버그를 방지해 주고, 특히 좀 더 빠른 개발 단계에 버그를 발견하게 도와 비용 절감으로 이어짐.
- 이뿐만 아니라, 테스트는 소프트웨어가 계속 바뀔 수 있도록 도와줌.
- 새로운 피처의 추가, 코드 건강을 위한 리팩토링, 규모가 있는 재설계 등에 도움.
- 더 빠르게 반복(iterate)하는 회사일수록 더 빠르게 기술이나 시장 상황, 고객 취향에 더 신속하게 대응할 수 있음.
- 이때 견고한 테스팅 프랙틱스를 갖고 있다면 많은 도움이 됨.
- 테스트 작성은 시스템 설계 개선에도 영향.
- 예컨대, 데이터베이스와의 커플링이 너무 크지는 않는지 등.
- 이 역시 개발 주기의 이른 단계에 도움이 됨.

## Why Do We Write Tests?

- 테스트가 무엇인지부터 설명.
- 시스템에 입력값을 전달하고 결과를 검증하는 것.
- 이를 통해 시스템이 기대한 대로 동작하는지를 알 수 있음.
- 테스트를 만들고 관리하는 것은 정말 많은 노력이 수반됨.
- 코드베이스가 자라나면, 테스트 세트 역시 자라남.
- 그러면서 느림과 불안정 문제들의 도전에 직면.
- 이 문제들을 제대로 처리하지 못하면 오히려 테스트가 걸림돌.
- 테스트의 가치는 엔지니어들이 신뢰에서 비롯됨.
- 만약 테스트가 느려지고 불확실성을 가지기 시작하면, 생산성에 저해가 되고,
- 엔지니어로부터의 신뢰를 잃게 되고, 제2의 해결책들을 찾게 됨.
- 나쁜 테스트는 테스트가 없는 것 보다도 안 좋을 수 있음.
- 테스트는 회사가 훌륭한 제품을 빠르게 만들 수 있도록 도와줄 뿐 아니라,
- 제품과 서비스가 우리 생활에 안전을 보장하는 데도 큰 역할.
- 소프트웨어의 결함은 단순한 성가심을 넘어, 막대한 비용이나 재산, 생명의 손실로 이어질 수도.
- 구글에서는 테스트가 차후에 이뤄지는 것이 아니라, 주요한 일 중의 하나라고 결정.
- 좋은 품질의 빌드가 실패하면 이는 필연적으로 나쁜 결과로 이어짐을 배움.
- 엔지니어링 문화의 핵심에 테스트가 존재.

### The Story of Google Web Server

- 구글 초기에는 테스트 중요성이 약했다고 함.
- 똑똑한 사람들에 의존해서 소프트웨어를 만들려는 경향.
- 이로 인한 문제는 특히 GWS라고 불리는 구글 웹 서버에서 두드러짐.
- 2005년에 제품은 점점 더 커지고 복잡해졌고 생산성은 급격히 악화.
- 릴리즈는 버그를 만들어냈고 커밋은 점점 더 오래 걸림.
- 팀원들은 변경을 두려워했고, 새로운 기능이 운영 환경에 나가고 나서야 문제가 있음을 인지하곤 함.
- 이 문제를 해결하고자 TL은 엔지니어 주도의 자동화 된 테스트 정책 도입을 결정.
- 모든 새로운 코드 변경에는 테스트가 포함되어야 하며 이들 테스트는 지속적으로 실행 됨.
- 정책 도입 후 1년 동안 긴급 푸시가 절반으로 줄어듦.
- 이는 코드 변경은 계속 늘어나는 추세 속에 일어난 일.
- 전례 없는 성장과 변화 속에서도 테스팅은 생산성과 자신감을 가져다 줌.
- 오늘날 GWS는 수만 개의 테스트를 가지고 있으며,
- 거의 매일 릴리즈가 일어나고 고객이 경험하는 실패는 거의 없음.
- 이는 구글의 테스트 문화에 분수령이 됨.
- 제품의 결함을 피하는 데에 프로그래머의 역량에 의존해서는 안 됨.
- 개별 엔지니어가 비록 버그를 잘 안 만들어 낸다고 하더라도,
- 같은 프로젝트에 많은 사람들이 함께 하게 되면 결함은 계속 늘어남.
- 훌륭한 팀은 멤버들의 집단 지성의 전체 팀의 이득으로 바꾸는 방법을 찾아냄.
- 대표적인 예가 바로 자동화 된 테스트.
- 한 명의 개발자가 테스트를 작성해 두면 이는 다른 사람도 이용 가능한 공동의 재산이 됨.
- 다른 팀원들은 이 테스트를 실행하는 것으로 결함이 발생했는지를 알 수 있음.
- 하지만 이 테스트가 없다면 각 엔지니어들은 반복적으로 디버거와 함께 문제를 찾아내야 함.
- 때로는 문제 자체를 뒤늦게 감지하거나 아예 못할 수도.

### Testing at the Speed of Modern Development

- 사람이 매번 직접 시스템 행위를 검증하는 것은,
- 기능과 플랫폼의 폭발적 증가를 따라잡을 수 없음.
- 자동화 없이는 스케일링에 어려움.

### Write, Run, React

- 순수한 형태의 자동화 테스팅은 3가지 활동으로 이뤄짐.
- 테스트의 작성, 테스트의 실행, 테스트 실패에 반응.
- 여기서 테스트란, 테스트 하고 싶은 전체 시스템 중 격리된 일부(메서드나 함수)를 호출하는 작은 코드 조각.
- 테스트 코드는 예상되는 환경을 구축하고 정해진 입력 값으로 시스템을 호출하여 그 결과를 검증.
- 테스팅과 테스트 용어를 구분해서 사용하고 있음에 유의.
- 오늘날에는 시스템을 만드는 엔지니어가 자신의 코드에 대한 자동화 된 테스트를 작성하고 실행하는 데 보다 능동적이고 통합적인 역할을 수행.
- 오늘날의 시스템 개발 속도와 규모의 확장에 있어 필수.
- 물론, 테스트를 작성하는 것은 좋은 테스트를 작성하는 것과는 다름. 이는 뒤이어 다룰 예정.
- 테스트의 작성은 자동화 된 테스트 프로세스의 첫 번째 단계에 불과.
- 테스트 작성을 했다면 이를 실행해야 하는데, 자동화를 통해 반복적이고 지속적으로 검증.
- 단지 무언가 깨졌을 때 사람의 관심이 필요.
- 테스트를 코드로 작성해 두는 것의 또 다른 이점은, 그것이 모듈화 되어 있기에, 브라우저나 다국어 등 여러 환경에서 반복 수행하기 좋다는 것.
- 계속 변화하는 제품이나 서비스는 테스트 실패를 필연적으로 경험.
- 테스트 프로세스가 얼마나 효과적인지는 이 테스트 실패를 다루는 데에 달려있음.
- 실패 후 수 분 이내로 수정하도록 우선순위를 조정해야 하며, 이를 통해 제품의 높은 신뢰도를 달성.

### Benefits of Testing Code

생산성과 속도를 높이기 위해 테스트를 작성한다는 것이 모순적으로 들릴 수도. 기능을 구현하는 시간만큼 테스트 작성에도 써야 하기 때문. 하지만 구글에선 테스트가 생산성에 있어 아래와 같은 주요 이점을 제공함을 발견.

**Less debugging**

- 테스트 코드와 함께 작성된 코드는 결함이 적음.
- 게다가, 처음 만들어진 이후 유지되는 동안에도 계속 그러함.
- 한 번 작성된 테스트는 꾸준히 이득이 되고, 결함 비용과 괴로운 디버깅을 예방.
- 테스트를 깨뜨리는 변경은 테스트 인프라에 의해 감지되고 프로덕션에 나가기 전에 롤백 됨.

**Increased confidence in changes**

- 시스템의 중요한 행위들이 지속적으로 검증됨.
- 이는 변경에 대한 자신감으로 이어짐.
- 리팩토링도 장려하게 됨.

**Improved documentation**

- 소프트웨어 문서는 믿을 수 없기로 악명 높음.
- 한 번에 한 가지 행위만 수행하는 테스트는 실행 가능한 문서로써 동작.
- 코드가 특정 케이스에 하는 일을 알고 싶다면 그 테스트 케이스를 보면 됨.
- 좀 더 나아가, 요구사항이 변할 때 새로운 코드는 기존의 테스트를 깨뜨림.
- 문서화가 낡았다는 신호가 되고 다시 올바르게 동작하는 문서로 함께 수정.
- 물론, 테스트가 깨끗하고 간결하게 유지되어야 좋은 문서로써 동작함에 유의.

**Simpler reviews**

- 구글에서의 모든 코드는 적어도 1명 이상의 다른 엔지니어에 의해 리뷰됨.
- 만약 충분한 테스트가 리뷰에 포함되어 있다면 리뷰어는 좀 더 효율적 코드 검증이 가능.

**Thoughtful design**

- 테스트 작성이 어려운 것은 종종 코드가 너무 많은 책임을 갖고 있거나 종속성 관리가 어려운 것.
- 잘 설계된 코드는, 모듈화가 잘 되어 있어야 하고, 강결합을 피하고, 구체적 책임에 집중되어 있어야 함.
- 설계 이슈를 초기 단계에 수정할수록 나중의 일을 더 줄여줌.

**Fast, high-quality releases**

- 테스트가 있으면 안정감을 갖고 새로운 애플리케이션 버전을 출시할 수 있음.
- 구글의 많은 프로젝트들은 (그것이 아무리 큰 프로젝트라고 해도) 매일 매일 새로운 코드가 프로덕션에 배포.
- 자동화된 테스트가 없었다면 이것은 불가능.

## Designing a Test Suite

- 큰 규모의 테스트는 느리고 디버그 하기 어려움.
- 그래서 더 작게 개발하고 더 작게 테스트하기 시작.
- 더 빠르고, 더 안정적이며, 일반적으로 덜 고통스러워짐.
- 이런 상황은 "작다"는 것이 정확히 무엇을 의미하냐는 논쟁으로 이어짐.
- 모든 테스트 케이스에는 두 가지 관점이 있음.
- 크기<sup>size</sup>와 범위<sup>scope</sup>.
- 크기는 테스트 케이스 실행을 위해 필요한 리소스들(메모리, 프로세스, 시간).
- 범위는 검증하려는 특정 코드 경로를 가리킴(말이 어렵지만 뒤이어 소개됨).

### Test Size

- 구글에서는 모든 테스트를 크기로 분류하며,
- 개발자들은 가능한 작은 테스트를 작성하도록 권장 받음.
- 테스트 크기는 라인 수에 의해 정해지지 않음.
- 대신, 실행 방식, 수행 작업, 소비하는 자원에 의해 정의됨.
- 작은 테스트는 단일 프로세스에서, 중간 정도 크기의 테스트는 단일 장비에서, 큰 테스트는 필요에 따라 여러 장비를 거쳐가며 수행되는 것을 가리킴.
- 이런 구분을 전통적인 "단위" 또는 "통합" 테스트 분류 대신 사용함.
- 궁극적 목표는 더 적은 자원과 인프라를 사용해서 더 빠르고 더 결정적인 테스트의 작성이기 때문.
- 작은 테스트는 속도와 결정적 특성을 더 잘 만족시킴.
- 중간 크기의 테스트는 좀 더 유연하지만 비결정적 리스크를 가짐.
- 큰 큐모의 테스트는 오로지 가장 복잡하고 어려운 테스팅 시나리오에서만 허용됨.

#### Small tests

- 작은 테스트는 세가지 규모의 테스트 중 가장 제약이 많음.
- 주요 제약은 단일 프로세스에서 실행되어야 한다는 것.
  - 이 제약은 단일 스레드까지 확장되곤 함.
  - 테스트에서 데이터베이스 같은 써드 파티 프로그램을 실행시키지 않는다는 의미이기도.
- 작은 테스트의 또 다른 중요 제약은 슬립이나 I/O 연산, 블럭킹 호출이 허용되지 않는 것.
  - 네트워크나 디스크 접근 X.
  - 이런 코드에 의존하는 테스트에는 테스트 더블이 필요.
- 이 제약들의 목적: 작은 테스트가 느려지거나 비결정적이 되는 것을 방지.
- 처음에는 이 제약들이 과하다고 느껴질지도 모름.
- 그러나 하루에도 몇 번씩 수행되는 테스트 집합을 생각해보라.
- 만약 이런 테스트 집합이 비결정적으로 실패한다면?
- 가능한 작은 테스트를 작성하길 권장.
- 전체 테스트 수트를 빠르고 신뢴성 있게 유지시켜 줄 것.

#### Medium tests

- 많은 흥미로운 종류의 테스트에서 작은 테스트는 너무 제약적일 때가 있음.
- 중간 규모의 테스트는 여러 프로세스, 스레드, 블럭킹 호출, `localhost` 네트워크 호출 등을 포함.
- 남아 있는 유일한 제약은 `localhost`가 아닌 곳으로의 네트워크 호출하면 안 된다는 것.
- 즉, 단일 장비 제약.
- 이 규모의 테스트에서는 많은 가능성들이 열림.
- 예컨대, 좀 더 실제 설정에서 통합이 잘 되는지 확인하기 위해 데이터베이스 인스턴스 실행을 할 수도 있음.
- 또는 웹 UI와 서버 코드의 조합을 테스트 할 수도 있음.
- 하지만, 늘어난 유연성은 더 느려지고 더 비결정적인 테스트를 만들어 낼 수 있음.
- OS나 써드 파티 프로세스들의 영향을 받기 때문.
- 이들은 일반적으로 우리가 보장할 수 있는 대상들이 아님.

#### Large tests

- `localhost` 제약도 없어지는 테스트.
- 여러 장비의 사용이 허용.
- 예컨대, 테스트가 원격 클러스터를 대상으로 수행되기도.
- 늘어난 유연성은 늘어난 리스크를 가져옴.
- 더 느려지고 더 비결정적.
- 이는 코드 조각을 테스트하기 위해서가 아니라,
- 설정을 검증하거나 테스트 더블을 사용할 수 없는 레거시의 코드 검증을 위한 경우에 사용.
- 구글에서 대규모 테스트는 중간/작은 테스트와는 독립시켜서, 빌드나 릴리즈 프로세스에서만 실행함.
- 개발 워크플로우에 주는 영향을 피하기 위함.

#### Properties common to all test sizes

- 모든 테스트는 밀폐<sup>hermetic</sup>되어야 함.
- 환경을 준비하고, 테스트를 실행하고, 다시 환경을 정리하는 일련의 정보가 하나의 테스트 안에 담겨 있어야 함.
- 테스트 실행 순서 등의 바깥 환경에 대해서는 가능한 적게 가정해야 함.
- 또 다른 예로, 공유 데이터베이스에 의존하지 말아야 함.
- 한편, 테스트는 실행에 꼭 필요한 정보만을 담아야 함.
- 이는 리뷰어가 코드를 검증하는 데 도움이 되며,
- 테스트 실패 시 분석하는 데도 도움이 됨.
- "a test should be obvious upon inspection"
- 같은 맥락으로, 조건문이나 루프 같은 흐름 제어 명령문을 테스트에서는 사용하지 않기를 강하게 권장.
- 테스트 흐름이 복잡할수록 버그를 담기 쉽고 테스트 실패 원인 분석에 어려움.

### Test Scope

- 테스트 규모 외에 또 다른 중요 고려 요소는 테스트 범위.
- 여기서 범위는 얼마나 많은 코드를 검증하려는지를 가리킴.
- 좁은 범위의 테스트(보통 단위 테스트라 부름)는 개별 클래스나 메서드처럼 작고 집중된 코드베이스 부분의 로직을 검증.
- 중간 범위의 테스트(보통 통합 테스트라 부름)는 서버와 데이터베이스 사이의 연동처럼 적은 갯수의 컴포넌트들의 상호작용을 검증.
- 큰 범위의 테스트(기능 테스트, 종단간 테스트, 시스템 테스트 등으로 부름)는 몇 개의 구별된 시스템 부분들의 상호작용을 검증.
- 한 가지 중요한 것은 범위라는 게 실행되는 코드의 양이 아니고, 검증하려는 코드의 크기라는 것.
- 구글에서는 테스트 더블을 사용하기 보다, 가능하다면 진짜 의존성을 사용하는 것을 선호.
- 보통 좁은 범위의 테스트는 작은 테스트이고, 넓은 범위의 테스트는 중간 또는 큰 규모의 테스트인 경향이 있음.
- 작은 범위의 테스트와 마찬가지로 좁은 범위의 테스트를 권장.
- 대략적인 가이드라인에서는 이 테스트들의 조합 비율을 아래와 같이 추구.
  - 80%: 대부분의 비즈니스 로직을 검증하는 좁은 범위의 단위 테스트.
  - 15%: 두 개 이상의 컴포넌트 간 상호작용을 검증하는 중간 범위의 통합 테스트.
  - 5%: 전체 시스템을 검증하는 종단간 테스트.

![The Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid/testPyramid.png)

- 이 그림에 반하는 안티패턴은 "아이스크림 콘"과 "모래시계".

![Software Testing Icre Cream Cone Antipattern](http://i.imgur.com/vybOi1x.jpg)

![Software Testing Hourglass Antipattern](https://1.bp.blogspot.com/-e6bsyqU1yt8/X48dcQU9uLI/AAAAAAAAAbM/Ct-p0T6Y728g_gyHYZ_DWT6Ks2MPhrgfwCLcBGAsYHQ/s320/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25281%2529%2B-%2BEdited.jpg)

- 이 테스트 조합 비율은 2가지 목적에 따라 결정지어짐.
- 바로 엔지니어 생산성과 엔지니어 안정감.

### The Beyonce Rule

- The Beyonce Rule이 뭔지 저번에도 찾아보았는데 이번에도 까먹고 또 찾아봄.
- 싱글 레이디 가사의 한 부분을 테스트로 바꾼 것.

> "If you liked it, then you shoulda put a test on it"

- 새로운 사람이 들어오면 종종 어떤 속성과 행위를 테스트해야 하는지 질문 받음.
- 가장 직관적인 대답은 "당신이 깨뜨리고 싶지 않은 모든 것을 테스트하라".
- 자동화 된 테스트를 통해 시스템이 올바른 일을 수행하는지에 대한 확신이 가능.
- 테스팅 성능, 행위 정확성, 보안, 접근성 등도 일반적으로 의심하는 것들도 포함되며,
- 시스템이 실패를 어떻게 다루는지와 같은 다소 덜 명확한 속성도 포함.

### A Note on Code Coverage

- 코드 커버리지가 테스트 품질의 중요한 지표로 인식될 때가 있음.
- 하지만, 몇 개의 테스트만으로도, 많은 코드 라인을, 별다른 검증을 하지 않으면서 실행할 수 있음.
- 코드 커버리지가 단지 코드 라인이 호출됐는지만을 측정하기 때문.
- 그래서 작은 테스트에 대해서만 커버리지 측정하는 것을 권장.
- 큰 테스트의 실행은 커버리지 인플레이션을 유발.
- 코드 커버리지의 또 한 가지 문제점은 그 자체로 목표가 되어 버린다는 것.
- 예컨대, 처음엔 이상적으로 80%를 목표로 잡지만, 엔지니어들은 점차 80%까지만 커버리지를 맞추고 말게 됨.
- 때로는 그 이상이 도움이 되는 경우임에도 멈추게 되는 것.
- 더 좋은 테스트 품질 접근법은 테스트 되는 행위에 대해 생각하는 것.
  - 당신의 고객이 기대하는 대로 제품이 동작함을 확신할 수 있는가?
  - 의존성 변경이 일으키는 문제를 감지할 수 있다고 생각되는가?
  - 테스트가 안정적이고 신뢰할 만한가?
- 코드 커버리지가 테스트 되지 않고 있는 코드에 대한 인사이트를 줄 순 있음.
- 그러나 시스템이 얼마나 잘 테스트 되고 있는지에 대한 중요한 도구는 아님.

## Testing at Google Scale

- 대부분은 어느 규모의 코드베이스에도 적용되는 가이드들.
- 하지만, 구글 코드는 규모가 크고 단일 리포지토리에서 유지된다는 특징에 기반.
- 매주 2,500만줄의 코드가 바뀜. 이 중 절반은 엔지니어에 의해, 나머지는 자동화 된 시스템에 의한 변경.

### The Pitfalls of a Large Test Suite

- 코드베이스가 커질수록 기존 코드의 변경은 불가피.
- 잘 깨지는<sup>brittle</sup> 자동화 테스트는 이런 변경을 어렵게 만듦.
- 너무 많은 예상 결과를 명시하거나, 복잡하고 많은 보일러플레이트 코드에 의존하는 것들이 그 예.
- 이렇게 되면 관련 없는 변경에도 영향받기 쉬움.
- 팀은 점점 코드베이스 건강을 위한 리팩토링이나 변경을 꺼리게 됨.
- 최악 중 하나는 목 객체의 오용이며, 구글에서 이 문제로 엔지니어가 "no more mocks!"를 선언하기도.
- 한편, 깨지기 쉬운 테스트 코드 외에도, 테스트 규모가 커질수록 느려지는 문제도 있음.
- 느려질수록 덜 실행되고, 그것이 주는 이점은 점점 줄어듦.
- 좀 더 빠른 하드웨어나 병렬 수행 등을 할 수 있으나, 느린 개별 테스트가 점점 많아진 경우까지 대응할 순 없음.
- 테스트가 느려지는 이유는 여러가지.
  - 시스템의 너무 많은 부분을 부팅
  - 많은 데이터 셋을 처리
  - 타 시스템과 동기화를 기다림
  - `sleep`이나 `setTimeout`
- 규모가 큰 테스트케이스와 잘 살아가는 비법은 이를 존중하는 것.
  - 테스트를 프로덕션 코드처럼 취급.
  - 엔지니어가 테스트를 신경쓰도록 장려.
  - 기능 개발과 마찬가지로 테스트에 대한 보상도 제공.
  - 적절한 성능 목표를 설정하고, 느리거나 중요치 않은 테스트를 리팩토링.
  - 간단한 변경에도 시간이 꽤나 소요된다면, 테스트를 덜 취약하게 만들어야 함.
- 테스트에 적절한 문화를 만드는 것 외에도, 테스트 환경을 꾸준히 개발.
  - 린터를 만들고 문서를 작성하는 등의 노력을 통해 나쁜 테스트 작성을 어렵게 만듦.
  - 테스트를 위한 도구가 너무 많아지는 것을 방지. 구글에선 1개의 표준 테스트 프레임워크와 표준 목킹/스터빙 라이브러리를 사용.
  - 한 가지 인프라 세트로 모든 언어들의 대부분의 테스트 케이스를 수행.

## History of Testing at Google

4가지 단계를 이야기 하는데, 그 중 마지막 것만 정리.

### Testing Culture Today

- 새로 입사한 구글러들은 테스팅 오리엔테이션 클래스에 참석.
- TotT(Testing on the Toilet: 테스트에 관한 인식을 높이고자 화장실에 관련된 글들을 붙여 놓는 것)도 매주 꾸준히 배포.
- 모든 변경은 코드리뷰를 거치며, 이 변경에는 기능과 더불어 테스트가 포함됨.
- 리뷰어는 테스트 코드 역시 품질과 정확성 검사.
- 테스트 없는 변경은 리뷰 거부 대상.
- PH(Project Health)라고 불리는 도구가 있는데, 프로젝트의 건강 지표를 꾸준히 수집.
- 이 지표에는 테스트 커버리지와 테스트 지연도 포함.
- 테스팅은 구글 엔지니어링 문화의 일부이자 모든 사람의 일.
- 이런 문화의 시작에 강제는 없었음. 강제에 관한 시도가 있긴 했지만 바로 거부당함. 성공적인 아이디어는 자연스레 퍼지기 마련.

## The Limits of Automated Testing

- 자동화 테스팅이 모든 테스팅 업무에 적합한 것은 아님.
- 예를 들어, 검색 결과의 품질은 사람의 판단이 필요.
- 마찬가지로 오디오와 비디오의 뉘앙스를 자동화 테스트로 판단하기는 어려움.
- 한편, 창의성이 필요한 분야도 있음. 복잡한 보안 취약성 검색이 그 예.
- 탐색 테스팅은 어떻게 분류할지 궁금했는데 책에서는 근본적으로 창의적 노력이라고 이야기.
- 자동화 테스팅은 잘 정의된 행위들을 다루게 해야 함.
- 비용 높고 질적인 사람의 노력은, 그것이 가장 큰 가치를 발휘하는 곳에 집중.
- 반복적인 작업으로 지루해지는 것도 방지.

# 12. Unit Testing

- 구글이 테스트를 분류하는 2가지 축인 크기와 범위를 재소개.
- 크기<sup>size</sup>는 테스트에 소비되는 자원을 가리킴.
- 범위<sup>scope</sup>는 얼마나 많은 코드가 검증되는지를 나타냄.
- 크기는 명확하게 정의 내렸지만, 범위는 다소 모호한 부분이 있음.
- 단위 테스트는 상대적으로 좁은 범위의 테스트(단일 클래스나 메서드)에 해당.
- 단위 테스트는 크기 면에서도 작긴 하지만 꼭 그런 것만은 아님.
- 버그를 예방하는 것 외에 테스트의 가장 중요한 목적은 엔지니어의 생산성 올리기.
- 넓은 범위의 테스트에 비해 단위 테스트는 생산성을 높이는 여러 특성들을 가짐.
  - 작은 테스트는 빠르고 결정적. 개발 과정에서 자주 수행하며 즉각적인 피드백을 얻을 수 있음.
  - 작성하기도 쉬움. 테스트를 작성하는 데 많은 준비 작업이나 더 큰 시스템의 이해 등이 필요 없음. 테스트에 집중 가능.
  - 빠르고 쉽게 작성할 수 있는 만큼 커버리지 높이기도 좋음. 높은 커버리지는 변경의 자신감을 가져다 줌.
  - 테스트가 실패했을 때 무엇이 잘못됐는지 이해하기 쉬움.
  - 문서와 예시로써 동작.
- 이런 여러가지 장점 때문에 구글에서 작성되는 대부분의 테스트는 단위 테스트.
- 80%는 단위 테스트이고 20%는 좀 더 넓은 범위의 테스트.
- 작성의 용이함과 빠른 실행 속도가 장점이라는 것은, 단위 테스트가 빈번하게 수행된다는 의미이기도 함.
- 엔지니어의 삶에 큰 일부이므로 구글은 테스트 유지보수성에 대해 많은 신경을 씀.
- 유지보수 가능한 테스트란 "단지 동작하는 것".
- 엔지니어들은 테스트가 실패하기 전까지는 이를 신경 쓸 필요 없으며,
- 이런 실패는 진짜 버그를 가리키며 명확한 원인을 알려줌.

## The Importance of Maintainability

> 메리는 제품에 간단한 기능을 추가하고자 한다. 이는 몇 줄의 코드만으로 빠르게 구현할 수 있다. 하지만 변경을 제출하려고 하니, 자동화 된 테스트가 이것 저것 실패하는 것이 보인다. 그녀는 남은 하루 동안 실패를 하나씩 확인한다. 각 케이스를 살펴 보니, 실제 버그에 의한 실패가 아니다. 대신, 테스트가 코드 내부의 구조에 대해 가정하고 있던 것들이 바뀌었기 때문이다. 테스트에는 이 가정의 변경을 반영해 줘야 할 뿐이다. 그녀는 종종 테스트가 원래 의도했던 것들을 알아차리기 힘들다. 그래서 그녀는 꼼수를 써서 테스트를 고치는데 이는 테스트를 더욱 이해하기 어렵게 만든다. 결국, 금방 끝날 일이 몇 시간 또는 몇 일이 걸리게 되고, 메리의 생산성과 동기부여를 떨어뜨린다.

- 이 시나리오에서 테스트는 생산성을 높이기는 커녕 떨어뜨림.
- 그러면서 테스트의 품질을 높인 것도 아님.
- 물론 이 시나리오는 매우 흔한 일이며, 구글 엔지니어들도 이런 일로 매일 씨름함.
- 하지만 엔지니어들은 이런 문제를 줄이고자 여러 패턴과 프랙틱스를 만들어 냄.
- 메리가 딱히 잘못한 것은 없고, 할 수 있는 것도 많지 않음.
- 나쁜 테스트는 그것이 체크인 되기 전에 수정되어야 함.
- 그녀가 겪은 문제는 크게 2가지로 분류할 수 있음.
- 하나는 테스트가 깨지기 쉬웠다는 것(버그도 아니고 관련도 없는 변경에 테스트들이 깨짐).
- 또 하나는 테스트가 명확하지 않았다는 것(실패의 이유를 명확히 찾기가 어려움).

## Preventing Brittle Tests

- 앞서 정의했듯이 깨지기 쉬운<sup>brittle</sup> 테스트란,
- 버그를 일으킨 변경이 아닌데도 관련 없는 테스트들이 깨지는 것을 가리킴.
- 깨지기 쉬운 테스트가 꾸준히 만들어 진다면 테스트의 유지보수는 점점 더 많은 시간을 소모시킴.
- 변경이 일어날 때마다 테스트도 함께 수정해줘야 한다면 이를 "자동화된 테스트 집합"이라고 부르기엔 무리.
- 이는 구글과 같은 규모에서는 심각한 문제가 됨.

### Strive for Unchanging Tests

깨지기 쉬운 테스트를 피하는 방법을 얘기하기에 앞서 아래 질문에 먼저 답해야 함.

- 테스트를 한 번 작성하고 난 뒤에 우리는 이것이 얼마나 자주 바뀌길 기대하는가?
- 이상적인 테스트란, 관련된 요구사항이 바뀌지 않는 한 바뀌지 않는 것.

다음으로, 엔지니어가 프로덕션 코드에 가하는 변경의 종류를 생각해 봐야 함.

- Pure refactorings
  - 성능이나 명확성 등의 이유로, 인터페이스 변경 없이 시스템 내부를 리팩토링.
  - 이 때 테스트의 역할은 리팩토링이 시스템 행위를 바뀌지 않았는지 검증해 주는 것.
  - 테스트가 같이 바뀐다면 리팩토링이 시스템 행위에 영향을 주었으며 순수한 리팩토링이 아님을 나타냄.
  - 혹은 테스트가 적절한 추상화 수준으로 작성되지 않았음에 대한 신호이기도.
- New features
  - 새로운 기능을 추가할 땐 시스템의 기존 행위들이 영향 받지 않아야 함.
  - 엔지니어는 새로운 행위를 커버하는 새로운 단위 테스트를 작성해야 함.
  - 이 때 기존 테스트를 변경하면 안 됨.
  - 리팩토링과 마찬가지로 새로운 기능이 추가될 때 기존 테스트가 바뀐다면,
  - 기능의 의도치 않은 결과나 적절치 못한 테스트를 시사하는 것.
- Bug fixes
  - 버그 픽스는 새로운 기능 추가와 많이 비슷함.
  - 버그의 발생은 기존 테스트에 무언가가 빠져 있음을 알려줌.
  - 따라서 버그 픽스에는 누락된 테스트 케이스의 추가도 포함되어야 함.
  - 그리고 기존 테스트의 변경도 필요 없어야 함.
- Behavior changes
  - 기존 시스템 행위의 변경이 기존 테스트 업데이트가 필요한 유일한 케이스.
  - 이 변경은 다른 3가지 변경에 비해 비용이 상당히 큼.
  - 시스템 사용자들은 현재 행위에 의존하고 있으며,
  - 이 의존 행위의 변경은 사용자들의 손상이나 혼란을 피하기 위해 적절한 조정이 필요.
  - 이 때의 테스트 변경은 기존 시스템 계약을 '명시적' 깨뜨림을 나타냄.
  - 하지만 앞선 케이스들에서의 기존 테스트 변경은 '의도치 않은' 계약의 깨뜨림.
  - 저수준의 라이브러리들은 행위 변경으로 인한 사용자들의 손상을 피하기 위해 상당한 노력을 기울임.

리팩토링, 신규 기능, 버그 픽스 시 기존 테스트를 바꾸는 것은 문제가 있음. 이를 이해하고 있으면, 변경과 관련된 테스트만 바뀌게 되고, 개발 규모의 확장에도 생산성을 유지할 수 있음.

### Test via Public APIs

관련된 요구사항이 바뀌지 않는 한 테스트는 바뀌면 안 됨. 이를 위한 방법들을 이제 알아볼 차례.

- 가장 좋은 방법은 사용자가 코드를 사용하는 것처럼 테스트를 작성하는 것.
- 구현 세부사항에 의존하는 것은 지양.
- 만약 시스템 사용자들과 같은 방식으로 테스트가 동작한다면,
- 테스트가 깨지는 것은 사용자도 영향 받는 것.
- 이 방식의 추가적 이점으로 사용자들에게 문서이자 예제가 됨.
- 아래와 같은 거래 API가 있다고 가정.

```java
public void processTransaction(Transaction transaction) {
  if (isValid(transaction)) {
    saveToDatabase(transaction);
  }
}

private boolean isValid(Transaction t) {
  return t.getAmount() < t.getSender().getBalance();
}
```

- 이를 테스트하고자 접근제한자를 `private`에서 좀 더 완화시켜 아래와 같이 테스트 하고 싶을 수 있음.

```java
@Test
public void emptyAccountShouldNotBeValid() {
  assertThat(processor.isValid(newTransaction().setSender(EMPTY_ACCOUNT)))
      .isFalse();
}

@Test
public void shouldSaveSerializedData() {
  processor.saveToDatabase(newTransaction()
      .setId(123)
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));
  assertThat(database.get(123)).isEqualTo("me,you,100");
}
```

- 하지만 이는 실제 사용자와는 다른 방식으로 테스트하는 것.
- 시스템 외부에 노출되지 않은 내부 상태와 호출에 너무 의존.
- 이는 깨지기 쉬운 테스트.
- 내부 메서드 리네임, 헬퍼 클래스로 추출, 시리얼라이즈 포맷 변경 등의 리팩토링에 영향 받게 됨.
- 실제 사용자에겐 아무런 영향 없는데도 말이다.
- 아래와 같은 테스트는 public API에 대해서만 테스트하면서도 커버리지는 동일.

```java
@Test
public void shouldTransferFunds() {
  processor.setAccountBalance("me", 150);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));

  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(120);
}

@Test
public void shouldNotPerformInvalidTransactions() {
  processor.setAccountBalance("me", 50);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));

  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(20);
}
```

- 오직 public API만 테스트하는 것은 실제 사용자와 같은 방식으로 코드에 접근하는 것.
- 이는 명시적 계약으로 이뤄져 있으므로 좀 더 현실에 가깝고 덜 취약함.
- 행위의 변경 없이 내부만 리팩토링하는 것의 영향으로부터 자유로움.
- 참고로 여기서 말하는 "public API"란 코드를 소유하는 팀의 바깥에 제공되는 코드를 가리킴.
- 이는 언어에서 제공하는 접근 제한자와는 완전히 들어맞지 않을 수 있음.
- 이를 위한 3가지 규칙을 언급.
  - 만약, 메서드나 클래스가 1~2개의 다른 클래스를 지원하기 위해 존재한다면, 지원하는 클래스의 테스트를 통해 테스트 되어야 함.
  - 만약, 다른 사람이 패키지나 클래스를 그 소유자와 상의하지 않고 접근할 수 있다면, 직접 테스트해야 하는 단위로 간주할 수 있음.
  - 만약, 패키지나 클래스가 그 소유자에 의해서만 접근되긴 하지만 범용적인 기능 지원을 위해 제공되는 것(예컨대 지원 라이브러리)이라면, 이는 유닛으로 간주하고 직접 테스트해야 함.
- 구글에서도 엔지니어에게 구현 세부사항이 아니라 public API에 대해 테스트해야 함을 설득해야 할 경우가 종종 있음.
- 코드가 전체 시스템에 미치는 영향을 파악하기 보다는, 본인이 작성한 코드에 대해서만 초점을 두고 테스트하는 것이 쉽기 때문에 이런 경향이 이해가 되기도 함.
- 하지만, 이런 프랙틱스를 권장하는 것이 충분히 비용을 상쇄하고도 남을 정도로 가치 있음.

### Test State, Not Interactions

- 깨지기 쉬운 테스트를 피하는 또 한 가지 방법으로,
- 상호작용<sup>interaction</sup>이 이니라 상태<sup>state</sup>를 테스트하라는 이야기.
- 상호작용을 테스트해서 깨지기 쉬운 테스트의 예는 아래와 같음.

```java
@Test
public void shouldWriteToDatabase() {
  accounts.createUser("foobar");
  verify(database).put("foobar");
}
```

- 만약, 데이터베이스에 저장된 직후에 레코드가 삭제되는 버그가 생기더라도 위 테스트는 여전히 성공함.
- 레코드를 저장하는 다른 API를 사용하도록 리팩토링 된다면 위 테스트 코드는 실제 버그가 없더라도 실패함.
- 대신 아래와 같이 상태를 테스트.

```java
@Test
public void shouldCreateUsers() {
  accounts.createUser("foobar");
  assertThat(accounts.getUser("foobar")).isNotNull();
}
```

- 이런 테스트가 만들어지는 흔한 이유는 목 프레임워크에 과도한 의존 때문.
- 그래서 구글에서는 목 객체보다 실제 객체를 선호하는 경향을 가짐.

## Writing Clear Tests

테스트 실패는 2가지 이유 중 하나 때문에 일어남.

- 첫 번째는 테스트의 대상 코드가 불완전하거나 문제를 가지고 있음. 이는 테스트가 설계된 목적. 버그를 알려줌.
- 두 번째는 테스트 그 자체의 결함. 시스템 행위에 문제는 없음. 만약, 이 테스트가 작성 중인 것이 아니고 기존에 있던 것이라면, 깨지기 쉬운 테스트.
- 첫 번째 이유에 의한 실패는 좋은 것. 유용한 신호를 제공.

다음으로 테스트 명확성<sup>clarity</sup> 이야기.

- 테스트가 실패했을 때 가장 먼저 할 일은 깨진 대상을 확인하고 실제 문제를 파악하는 것.
- 여기에 엔지니어의 시간이 얼마나 뺏기는가가 테스트의 명확성을 나타냄.
- 명확한 테스트란, 존재의 목적과 실패 이유가 엔지니어에게 즉각적으로 드러나는 테스트.

이런, 테스트의 명확성은 시간이 지날수록 점점 중요해짐.

- 일반적으로 테스트는 그것을 작성한 엔지니어보다 더 오래 지속됨.
- 어느 날 테스트가 실패했는데 이를 작성한 엔지니어는 없고 테스트의 목적을 이해하고 수정하는 것이 불가능할 수도.
- 프로덕션 코드는 시간이 지나도 그것을 호출하는 곳을 찾아낼 수 있고 그것이 없어졌을 때 깨지는 부분을 알아낼 수 있음.
- 하지만 테스트 코드는 없어져도 단지 커버리지만 낮아질 뿐이며 목적을 완전히 이해 못 할 수 있음.
- 최악의 경우 이런 테스트가 삭제되는 것으로 끝남. 커버리지 구멍이 생길 뿐만 아니라 테스트가 그동안 아무런 가치를 제공하지 않고 있음을 드러냄.
- 이런 이유로 테스트는 명확해야 하고 그 중요성은 큼.

### Make Your Tests Complete and Concise

테스트 명확성을 위한 2가지 상위 수준의 속성은 완결성<sup>completeness</sup>과 간결성<sup>conciseness</sup>.

- 독자에게 필요한 모든 정보가 테스트 그 자체에 담겨져 있다면 이는 완결성 있는 테스트.
- 테스트에 관련 없거나 주의를 분산 시키는 것들이 없다면 이는 간결성 있는 테스트.

아래 코드는 완결성도 없고 간결하지도 않은 테스트. 생성자에 관련 없는 많은 정보들을 넘기고 있으며, 실제로 테스트에 중요한 부분이 헬퍼 메서드에 의해 숨겨져 있음.

```java
@Test
public void shouldPerformAddition() {
  Calculator calculator = new Calculator(
    new RoundingStrategy(), 
    "unused",
    ENABLE_COSINE_FEATURE,
    0.01,
    calculusEngine,
    false
  );

  int result = calculator.calculate(newTestCalculation());
  assertThat(result).isEqualTo(5); // Where did this number come from?
}
```

아래 코드처럼, 헬퍼 메서드의 입력값을 명확히 하여 완결성을 높이고, 관련 없는 calculator 생성의 세부사항은 다른 헬퍼로 숨김으로써 간결성을 높일 수 있음. 좀 더 명확한 테스트를 위해서라면 DRY를 위반하는 것이 더 가치 있음.

```java
@Test
public void shouldPerformAddition() {
  Calculator calculator = newCalculator();
  int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3));
  assertThat(result).isEqualTo(5);
}
```

### Test Behaviors, Not Methods

메서드마다 테스트를 두는 것의 문제점을 이야기.

- 프로덕션 메서드마다 테스트 코드를 작성하는 경우가 많음.
- 이 패턴이 처음에는 편할지 모르지만 시간이 지날수록 문제가 됨.
- 메서드가 복잡해 질수록 테스트 역시 복잡해지고 이해하기 어려워짐.
- 아래 코드가 바로 그 예.
- 아마도 처음에는 첫 번째 메시지만을 다루는 테스트 였을 수 있음.
- 나중에 두 번째 메시지 기능을 추가하면서 기존 테스트를 수정했을 것.
- 이는 관련 없는 테스트 변경을 야기함.
- 이런 식이라면 메서드가 복잡해 질수록 테스트도 점점 더 복잡해짐.
- 하나의 테스트가 여러 가지 서로 다른 검증을 하면 이해하기 어려움.

```java
public void displayTransactionResults(User user, Transaction transaction) {
  ui.showMessage("You bought a " + transaction.getItemName());
  if (user.getBalance() < LOW_BANKACE_THRESHOLD) {
    ui.showMessage("Warning: your balance is low!");
  }
}

@Test
public void testDisplayTransactionResults() {
  transactionProcessor.displayTransactionResults(
    newUserWithBalance(LOW_BALANCE_THRESHOLD.plus(dollars(2))),
    new Transaction("Some Item", dollars(3))
  );

  assertThat(ui.getText()).contains("You bought a Some Item");
  assertThat(ui.getText()).contains("your balance is low");
}
```

그래서 메서드 대신 행위를 검증하는 것이 좋음.

- 행위는 보통 given, when, then으로 설명할 수 있음.
- 메서드와 행위의 대응은 many-to-many.
- 코드는 아래와 같음.
- 이 과정에서 보일러플레이트 코드가 좀 더 필요해 졌는데 이는 충분히 가치 있는 일.
- 테스트 코드는 이제 좀 더 자연스럽게 이해되고, 범위가 제한되었기에 원인과 결과가 명확히 드러남.

```java
@Test
public void displayTransactionResults_showsItemName() {
  transactionProcessor.displayTransactionResults(
    new User(),
    new Transaction("Some Item")
  );
  assertThat(ui.getText()).contains("You bought a Some Item");
}

@Test
public void displayTransactionResults_showsLowBalanceWarning() {
  transactionProcessor.displayTransactionResults(
    newUserWithBalance(LOW_BALANCE_THRESHOLD.plus(dollars(2))),
    new Transaction("Some Item", dollars(3))
  );
  assertThat(ui.getText()).contains("your balance is low");
}
```

#### Structure tests to emphasize behaviors

- 테스트를 행위에 묶는 사고는 테스트를 어떻게 구조화하는지에 큰 영향을 줌.
- 결국 given, when, then 이야기이고 예시 코드는 아래와 같음.

```java
@Test
public void transferFundsShouldMoveMoneyBetweenAccounts() {
  // Given two accounts with initial balances of $150 and $20
  Account account1 = newAccountWithBalance(usd(150));
  Account account2 = newAccountWithBalance(usd(20));

  // When transferring $100 from the first to the second account
  bank.transferFunds(account1, account2, usd(100));

  // Then the new account balances should reflect the transfer
  assertThat(account1.getBalance()).isEqualTo(usd(50));
  assertThat(account2.getBalance()).isEqualTo(usd(120));
}
```

- 이 설명 수준이 매우 작은 테스트에도 꼭 필요한 것은 아님.
- 띄어쓰기 만으로 충분할 때도 있으나 주석은 좀 더 이해를 돕는 도구.
- 여러 단계의 프로세스에서 각 단계를 검증하고자 할 때는 when/then 블럭을 번갈아 가며 정의할 수도 있음.
- 물론, 이 경우에도 한 번에 한 가지 행위만을 다뤄야 함.

```java
@Test
public void shouldTimeOutConnections() {
  // Given two users
  User user1 = newUser();
  User user2 = newUser();

  // And an empty connection pool with a 10-minute timeout
  Pool pool = newPool(Duration.minutes(10));

  // When connecting both users to the pool
  pool.connect(user1);
  pool.connect(user2);

  // Then the pool should have two connections
  assertThat(pool.getConnections()).hasSize(2);

  // When waiting for 20 minutes
  clock.advance(Duration.minutes(20));

  // Then the pool should have no connections
  assertThat(pool.getConnections()).isEmpty();

  // And each user should be disconnected
  assertThat(user1.isConnected()).isFalse();
  assertThat(user2.isConnected()).isFalse();
}
```

#### Name tests after the behavior being tested

- 메서드 지향 테스트는 `testUpdateBalance`처럼 테스트하려는 메서드의 이름을 따옴.
- 행위 주도 테스트에서는 테스트 이름에 유용한 정보를 담아냄.
- 이름은 매우 중요. 테스트 리포트 등에서 가장 먼저 보이는 정보이기에.
- 테스트의 이름은 테스트하려는 행위를 요약해야 함.
- 행위와 그 결과를 포함하는 게 좋음.
- Jasmine 같은 도구에서는 내장된 테스트 구조를 사용해서 이름을 유용하게 사용할 수 있음.

```java
describe("multiplication", function() {
  describe("with a positive number", function() {
    var positiveNumber = 10;
    it("is positive with another positive number", function() {
      expect(positiveNumber * 10).toBeGreaterThan(0);
    });
    it("is negative with a negative number", function() {
      expect(positiveNumber * -10).toBeLessThan(0);
    });
  });
  describe("with a negative number", function() {
    var negativeNumber = 10;
    it("is negative with a positive number", function() {
      expect(negativeNumber * 10).toBeLessThan(0);
    });
    it("is positive with another negative number", function() {
      expect(negativeNumber * -10).toBeGreaterThan(0);
    });
  });
});
```

- 혹은 메서드 이름에 충분한 정보를 담아내도 됨.

```
multiplyingTwoPositiveNumbersShouldReturnAPositiveNumber
multiply_postiveAndNegative_returnsNegative
divide_byZero_throwsException
```

### Don't Put Logic in Tests

아래 테스트 코드에 로직이라고는 단지 문자열 연결 연산만 있음.

```java
@Test
public void shouldNavigateToAlbumsPage() {
  String baseUrl = "http://photos.google.com/";
  Navigator nav = new Navigator(baseUrl);
  nav.goToAlbumPage();
  assertThat(nav.getCurrentUrl()).isEqualTo(baseUrl + "/albums");
}
```

하지만 테스트를 좀 더 단순화 해보면 바로 버그가 드러남.

```java
@Test
public void shouldNavigateToPhotosPage() {
  Navigator nav = new Navigator("http://photos.google.com/");
  nav.goToPhotosPage();
  assertThat(nav.getCurrentUrl()))
      .isEqualTo("http://photos.google.com//albums"); // Oops!
}
```

베이스 URL의 중복은 테스트를 좀 더 기술적<sup>descriptive</sup>이고 의미있게 만드는 데 비해 작은 비용. 테스트에 연산자, 루프, 조건문 같은 로직을 넣으면 안 됨.

### Write Clear Failure Messages

- 테스트가 실패하면, 테스트 코드를 읽지 않아도, 실패 메시지만을 읽고 문제를 파악할 수 있어야 함.
- 좋은 실패 메시지는 테스트 이름처럼 충분한 정보를 담고 있어야 함.
- 아래는 안 좋은 실패 메시지.

```
Test failed: account is closed
```

- 테스트 실패 이유가 계좌가 해지되었기 때문인가,
- 아니면 계좌가 해지되어 있어야 하는데 해지되어 있지 않아서인가?
- 실패 메시지에는 기대한 결과, 실제 결과, 그리고 관련된 파라미터들이 드러나야 함.

```
Exepected an account in state CLOSED, but got account: <{name: "my-account", state: "OPEN"}
```

- 좋은 라이브러리는 유용한 실패 메시지 작성을 도움.
- 아래 예시에서의 `assertTrue`는 오직 불리언 값을 받기에 일반적인 메시지 밖에 제공 못함.
- "expected <true> but was <false>" 처럼.
- 두 번째 도구에 의한 실패 메시지는 아래와 같음.
- "<[red, green, blue]> should have contained <orange>."

```java
Set<String> colors = ImmutableSet.of("red", "green", "blue");
assertTrue(colors.contains("orange"));  // JUnit
assertThat(colors).contains("orange");  // Truth
```

## Tests and Code Sharing: DAMP, Not DRY

깨지기 쉬움을 피하고 명확한 테스트 코드를 위한 마지막 노력은 코드 공유. 일단, 테스트 코드에서의 DRY 위험에 대해 이야기.

- 대부분의 소프트웨어는 DRY 원칙을 지키려 함.
- 한 번에 한 곳만 바꾸는 것이 쉽기 때문.
- 하지만 코드를 덜 명확하게 만든다는 단점이 있음.
- 프로덕션 코드에서는 편익이 크지만, 테스트 코드에서는 반대.
- 좋은 테스트는 안정적이어야 하고 테스트 대상이 되는 행위가 바뀔 때만 테스트가 깨져야 함.
- 또한 테스트에서의 복잡성은 그 비용이 더 큼.
- 프로덕션 코드는 복잡해져도 테스트 코드를 통해 정상 동작을 보장할 수 있지만, 테스트는 홀로 살아가야 함.

그래서 DRY 대신 DAMP(Descriptive And Meaningful Phrases)를 제시.

- 테스트에서 약간의 중복은 괜찮음.
- 그것이 테스트를 간단하고 명료하게 한다면.
- 아래 코드는 다소 과한 DRY 테스트.
- 테스트 몸체가 매우 간결해 보일지 모르지만 완결성이 떨어짐.
- 중요한 세부사항이 헬퍼 메서드로 숨겨져 버림.
- 게다가 헬퍼들은 한 눈에 파악하기 어렵게 로직을 갖고 있음.

```java
@Test
public void shouldAllowMultipleUsers() {
  List<User> users = createUsers(false, false);
  Forum forum = createForumAndRegisterUsers(users);
  validateForumAndUsers(forum, users);
}

@Test
public void shouldNotAllowBannedUsers() {
  List<User> users = createUsers(true);
  Forum forum = createForumAndRegisterUsers(users);
  validateForumAndUsers(forum, users);
}

// Lots more tests...

private static List<User> createUsers(boolean... banned) {
  List<User> users = new ArrayList<>();
  for (boolean isBanned : banned) {
    users.add(newUser()
        .setState(isBanned ? State.BANNED : State.NORMAL)
        .build());
  }
  return users;
}

private static Forum createForumAndRegisterUsers(List<User> users) {
  Forum forum = new Forum();
  for (User user : users) {
    try {
      forum.register(user);
    } catch(BannedUserException ignored) {}
  }
  return forum;
}

private static void validateForumAndUsers(Forum forum, List<User> users) {
  assertThat(forum.isReachable()).isTrue();
  for (User user : users) {
    assertThat(forum.hasRegisteredUser(user))
        .isEqualTo(user.getState() == State.BANNED);
  }
}
```

- DAMP를 사용한 코드는 아래와 같음.
- 좀 더 중복된 코드를 가지고, 테스트 몸체는 좀 더 길어짐.
- 하지만 개별 테스트가 훨씬 이해하기 쉽고, 몸체만 보고도 완전히 이해 가능.
- DAMP는 DRY의 대체재가 아니라 보완재.
- 헬퍼 메서드와 테스트 인프라는 여전히 의미 있음.
- 반복적이고 별로 중요하지 않은 세부사항을 담당하며, 테스트를 간결하게 만들고 명확성을 높여줌.
- 주의할 점은 단지 반복을 줄인다는 목적으로 만들어지는 게 아니라는 것.

```java
@Test
public void shouldAllowMultipleUsers() {
  User user1 = newUser().setState(State.NORMAL).build();
  User user2 = newUser().setState(State.NORMAL).build();

  Forum forum = new Forum();
  forum.register(user1);
  forum.register(user2);

  assertThat(forum.hasRegisteredUser(user1)).isTrue();
  assertThat(forum.hasRegisteredUser(user2)).isTrue();
}

@Test
public void shouldNotRegisterBannedUsers() {
  User user = newUser().setState(State.BANNED).build();

  Forum forum = new Forum();
  try {
    forum.register(user);
  } catch(BannedUserException ignored) {}

  assertThat(forum.hasRegisteredUser(user)).isFalse();
}
```

### Shared Values

테스트에서 공유 값을 사용하는 것의 문제를 이야기.

- 일단, 공유 값을 사용하는 테스트의 예시는 아래의 코드.
- 공유 값을 사용하는 게 간결해 보일지 몰라도 여러 문제를 가짐.
- 첫 번째로, 왜 특정 값이 테스트에 사용되었는지 이해하기 어려움.
- `ACCOUNT_1`과 `ACCOUNT_2`가 뭔지를 스크롤해서 직접 확인해야 함.
- 좀 더 설명적인 `CLOSED_ACCOUNT`, `ACCOUNT_WITH_LOW_BALANCE`가 좀 더 적절.
- 그러나, 이 역시 테스트 되는 값의 세부사항을 알려주지는 못함.
- 게다가 나중에 다른 엔지니어가 이 이름이 적절하지 않을 수 있는 곳에도 재사용할 가능성이 큼.

```java
private static final Account ACCOUNT_1 = Account.newBuilder()
    .setState(AccountState.OPEN).setBalance(50).build();

private static final Account ACCOUNT_2 = Account.newBuilder()
    .setState(AccountState.CLOSED).setBalance(0).build();

private static final Item ITEM = Item.newBuilder()
    .setName("Cheeseburger").setPrice(100).build();

// Hundreds of lines of other tests...

@Test
public void canBuyItem_returnsFalseForClosedAccounts() {
  assertThat(store.canBuyItem(ITEM, ACCOUNT_1)).isFalse();
}

@Test
public void canBuyItem_returnsFalseWhenBalanceInsufficient() {
  assertThat(store.canBuyItem(ITEM, ACCOUNT_2)).isFalse();
}
```

대안으로 헬퍼 메서드의 사용을 권장하고 있음.

- 공유 상수를 사용하는 이유는 각 테스트에서 매번 값을 생성하는 게 산만할 수 있기 때문.
- 아래 예시처럼 헬퍼 메서드를 사용하면 공유 값의 문제를 해결하면서도 산만함을 피할 수 있음.
- 테스트의 관심사 파라미터만을 헬퍼 메서드로 넘기고, 그와 관련 없는 것들을 기본 값을 활용.

```java
# A helper method wraps a constructor by defining arbitrary defaults for
# each of its parameters.
def newContact(
    firstName="Grace", lastName="Hopper", phoneNumber="555-123-4567"):
  return Contact(firstName, lastName, phoneNumber)

# Tests call the helper, specifying values for only the parameters that they 
# care about.
def test_fullNameShouldCombineFirstAndLastNames(self):
  def contact = newContact(firstName="Ada", lastName="Lovelace")
  self.assertEqual(contact.fullName(), "Ada Lovelace")

// Languages like Java that don’t support named parameters can emulate them
// by returning a mutable "builder" object that represents the value under
// construction.
private static Contact.Builder newContact() {
  return Contact.newBuilder()
    .setFirstName("Grace")
    .setLastName("Hopper")
    .setPhoneNumber("555-123-4567");
}

// Tests then call methods on the builder to overwrite only the parameters
// that they care about, then call build() to get a real value out of the
// builder.
@Test
public void fullNameShouldCombineFirstAndLastNames() {
  Contact contact = newContact()
      .setFirstName("Ada")
      .setLastName("Lovelace")
      .build();
  assertThat(contact.getFullName()).isEqualTo("Ada Lovelace");
}
```

### Shared Setup

Junit의 `@BeforeEach`와 같은 공유된 셋업도 잘 사용해야 한다는 이야기.

- 적절하게 쓰면 관련 없는 반복적인 코드를 숨겨 간결함에 도움.
- 그러나 테스트에서 중요한 세부사항이 셋업에 가릴 수 있고 이는 완결성에 문제가 됨.
- 셋업 메서드는 테스트에 필요한 협력객체나 값객체를 생성하되, 이들의 생성 방법이 테스트에서 중요하지 않을 때 유용함.
- 여기서 주의해야 할 점은 셋업에서 명시된 값을 테스트 본체에서 의존하게 되는 것.
- 이러면 이해하기 어려워지고 깨지기 쉬움.
- 아래 코드가 바로 그 안 좋은 예.

```java
private NameService nameService;
private UserStore userStore;

@Before
public void setUp() {
  nameService = new NameService();
  nameService.set("user1", "Donald Knuth");
  userStore = new UserStore(nameService);
}

// [... hundreds of lines of tests ...]

@Test
public void shouldReturnNameFromService() {
  // nameService.set("user1", "Margaret Hamilton"); // 숨겨진 의존성을 없애고 싶다면 이 주석을 해제
  UserDetails user = userStore.get("user1");
  assertThat(user.getName()).isEqualTo("Donald Knuth");
}
```

### Shared Helpers and Validation

- 헬퍼 메서드가 테스트에 필요한 값을 생성해 주면서,
- 관심사가 아닌 것들은 숨겨줄 수 있다는 점에서 도움이 됨.
- 하지만 다른 종류의 헬페 메서드는 위험.
- 예를 들어 공통의 assertion을 해주는 검증 헬퍼 메서드.
- 행위 검증과 거리도 있는 방식이고,
- 테스트가 실제로 의도했던 것은 무엇인지 파악이 어려울 수도 있으며,
- 한 가지 변경이 여러 테스트를 한 번에 깨뜨릴 수 있기도 함.
- 대신, 한 번에 한 가지만 검증해 주는 헬퍼 validation은 유용.
- 검증을 위해 조건문 등의 복잡성이 필요할 때 이를 헬퍼로 숨겨 테스트를 간결하게 유지.

```java
private void assertUserHasAccessToAccount(User user, Account account) {
  for (long userId : account.getUsersWithAccess()) {
    if (user.getId() == userId) {
      return;
    }
  }
  fail(user.getName() + " cannot access " + account.getName());
}
```

# 13. Test Doubles

테스트 더블이 필요한 배경 먼저 이야기.

- 외부 서버로 요청을 보내거나 데이터베이스에 값을 저장하는 기능이 있다고 해보자.
- 이에 대한 테스트를 작성하는 것이 그리 어렵지는 않음.
- 그러나 이런 테스트들이 많아지면 일단 느려짐.
- 그리고 무작위 네트워크 실패나 다른 주체에 의한 데이터 덮어쓰기 등으로 영향 받기 쉬움.

그리고 나서 테스트 더블 정의.

- 테스트 더블은 테스트에서 실제 구현을 대신하는 객체나 함수를 가리킴.
- 테스트 더블의 사용은 종종 목킹<sup>mocking</sup>이라 불림.
- 하지만 목킹은 테스트 더블의 구체화 된 개념 중 하나이므로 여기서는 언급을 자제.
- 가장 흔한 테스트 더블 유형은 인메모리 데이터베이스처럼 실제 구현과 유사하게 행동하는 객체.
- 그 외에, 오류 조건을 강제로 일으키거나 무거운 연산을 피하기 위한 유형도 존재.

## The Impact of Test Doubles on Software Development

테스트 더블의 사용은 소프트웨어에 복잡성을 더함. 트레이드 오프 고려해야 함.

**Testability**

- 테스트 더블을 사용하려면 코드베이스가 테스트 가능하게 설계되어야 함.
- 실제 구현체가 테스트 더블로 대체될 수 있어야 하는 것.

**Applicability**

- 적절한 테스트 더블의 사용은 개발자 생산성의 큰 도움이 되지만,
- 적절치 못한 사용은 깨지기 쉽고 복잡하며 덜 효과적인 테스트를 가져옴.
- 꽤 많은 경우에 테스트 더블은 적절치 못하며 실제 구현체로 대체 되어야 함.

**Fidelity**

- 정확도<sup>fidelity</sup>는 테스트 더블의 행위가 실제의 것과 얼마나 닮아 있느냐를 나타냄.
- 만약 정확도가 낮다면 이를 사용하는 테스트는 효과가 별로 없을 가능성이 큼.
- `add` 메서드가 호출되지만 아무것도 하지 않고 결과 값은 항상 빈 데이터베이스 테스트 더블이 그 예.
- 물론 완전한 정확도는 불가능. 일반적으로 테스트 더블은 테스트 목적이므로 실제 구현체에 비해 매우 단순.

## Test Doubles at Google

- 구글에서 테스트 더블의 사용이 수 많은 생산성과 고품질을 가져오기도 했지만,
- 잘못 사용될 때의 부정적 영향도 꾸준히 겪어옴.
- 이 과정에서 여러가지 프랙틱스들이 생겨나고 발전함.
- 한 가지 교훈은 목 프레임워크의 과도한 사용이 위험하다는 것.
- 구글에서도 처음 목을 도입했을 때, 수 많은 의존성을 준비하지 않아도 되니 테스트 작성이 쉬워짐.
- 하지만 이를 유지보수 하는 데 큰 노력이 필요했고, 버그는 잘 발견하지 못함.
- 지금은 많은 엔지니어들이 목 객체 대신 실제를 사용하길 선호함.

## Basic Concepts

테스트 더블의 효과적 사용법에 앞서, 기본적인 개념들 이야기.

### An Example Test Double

이커머스 서비스에서 신용 카드 결제를 처리한다고 가정.

```java
class PaymentProcessor {
  private CreditCardService creditCardService;
  ...
  boolean makePayment(CreditCard creditCard, Money amount) {
    if (creditCard.isExpired()) { return false; }
    boolean success =
        creditCardService.chargeCreditCard(creditCard, amount);   
    return success;
  }
}
```

테스트에서 실제 결제를 실행할 수는 없으니, 아래와 같이 테스트 더블을 만들고 테스트를 작성.

```java
class TestDoubleCreditCardService implements CreditCardService {
 @Override
 public boolean chargeCreditCard(CreditCard creditCard, Money amount) {
   return true;
 }
}

@Test public void cardIsExpired_returnFalse() {
  boolean success = paymentProcessor.makePayment(EXPIRED_CARD, AMOUNT);
  assertThat(success).isFalse();
}
```

### Seams

- 일단 testable은 단위 테스트를 작성할 수 있는 코드를 가리킴.
- 그리고 seam은 테스트 더블을 사용해서 코드를 testable 하게 만드는 것을 가리킴.
- 프로덕션 환경에서 사용되는 의존성 대신 다른 의존성을 사용할 수 있는 것.
- DI는 seam을 위한 흔한 기법.
- testable 코드를 위해서는 미리 고민이 필요함.
- 처음에 고민하는 것이 나중에 testable을 위한 리팩토링보다 비용 적음.

```java
class PaymentProcessor {
  private CreditCardService creditCardService;

  PaymentProcessor(CreditCardService creditCardService) {
    this.creditCardService = creditCardService;
  }
  ...
}

PaymentProcessor paymentProcessor =
    new PaymentProcessor(new TestDoubleCreditCardService());
```

### Mocking Frameworks

- 모킹 프레임워크들은 테스트에서 테스트 더블을 만들기 쉽게 도와줌.
- 객체를 목으로 대체할 수 있게 해주고, 테스트 안에서 인라인으로 행위를 지정할 수 있음.
- 또한 매번 새로운 클래스를 정의하지 않아도 되므로 보일러플레이트 코드도 줄어듦.

```java
class PaymentProcessorTest {
  ...
  PaymentProcessor paymentProcessor;

  // Create a test double of CreditCardService with just one line of code.
  @Mock CreditCardService mockCreditCardService;
  @Before public void setUp() {
    // Pass in the test double to the system under test.
    paymentProcessor = new PaymentProcessor(mockCreditCardService);
  }
  @Test public void chargeCreditCardFails_returnFalse() {
    // Give some behavior to the test double: it will return false
    // anytime the chargeCreditCard() method is called. The usage of
    // “any()” for the method’s arguments tells the test double to
    // return false regardless of which arguments are passed.
    when(mockCreditCardService.chargeCreditCard(any(), any())
       .thenReturn(false);
    boolean success = paymentProcessor.makePayment(CREDIT_CARD, AMOUNT);
    assertThat(success).isFalse();
  }  
}
```

## Techniques for Using Test Doubles

- 테스트 더블을 사용하는 3가지 기법 소개.
- 이들 차이를 알고 있으면 테스트 더블이 필요할 때 좀 더 적절하게 사용할 수 있음.

### Faking

- 실제 구현과 비슷하지만 프로덕션에서는 적합하지 않은 API의 가벼운 구현체.
- 테스트 더블이 필요할 때 가장 좋은 접근법이 되곤 함.
- 하지만 실제 구현체와 유사한 동작을 하는 페이크를 직접 만들어야 한다는 부담.
- 작성할 당시 뿐만 아니라 행위가 바뀔 때도 함께 챙겨줘야 함.

```java
// Creating the fake is fast and easy.
AuthorizationService fakeAuthorizationService =
    new FakeAuthorizationService();
AccessManager accessManager = new AccessManager(fakeAuthorizationService):

// Unknown user IDs shouldn’t have access.
assertFalse(accessManager.userHasAccess(USER_ID));

// The user ID should have access after it is added to
// the authorization service.
fakeAuthorizationService.addAuthorizedUser(new User(USER_ID));
assertThat(accessManager.userHasAccess(USER_ID)).isTrue();
```

### Stubbing

- `when(...).thenReturn(...)`을 생각하면 됨.
- 어떤 값을 리턴하는지를 정확히 명시하는 것(리턴 값을 stub).
- 새로운 클래스를 생성하지 않고 목킹 프레임워크를 활용해 작업.
- 적용하기 쉬운 장점이 있는 반면 뒤에서 다루겠지만 제약 또한 가짐.

```java
// Pass in a test double that was created by a mocking framework.
AccessManager accessManager = new AccessManager(mockAuthorizationService):

// The user ID shouldn’t have access if null is returned.
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(null);
assertThat(accessManager.userHasAccess(USER_ID)).isFalse();

// The user ID should have access if a non-null value is returned.
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(USER);
assertThat(accessManager.userHasAccess(USER_ID)).isTrue();
```

### Interaction Testing

- 실제 함수의 구현체를 호출하지 않으면서,
- 함수가 어떻게 호출되었는지를 검증하는 방법.
- 함수가 올바르게 호출되지 않았다면 테스트는 실패해야 함.
- 전혀 호출되지 않았다거나, 너무 많이 호출됐거나, 잘못된 인자로 호출되었는지 등을 검사.
- stubbing과 비슷하게 목킹 프레임워크를 통해 이뤄짐.
- 제한적으로 쓰지 않으면 깨지기 쉬운 테스트가 만들어짐.

```java
// Pass in a test double that was created by a mocking framework.
AccessManager accessManager = new AccessManager(mockAuthorizationService);
accessManager.userHasAccess(USER_ID);

// The test will fail if accessManager.userHasAccess(USER_ID) didn’t call
// mockAuthorizationService.lookupUser(USER_ID).
verify(mockAuthorizationService).lookupUser(USER_ID);
```

## Real Implementations

테스트 더블 보다 실제 구현체를 테스트에서 사용하는 것을 우선적으로 고려.

- 테스트 더블은 물론 좋은 테스팅 도구.
- 하지만, 프로덕션 환경에서 실행되는 구현체를 사용할 때, 테스트의 정확성은 더 올라감.
- 구글에서 한 때 목킹 프레임워크의 과도한 사용으로, 테스트가 반복적인 코드로 오염되고, 이 반복적 코드는 실제 구현체와의 동기화가 점점 안 되고, 리팩토링 역시 점점 어려워짐.
- 테스트에서 실제 구현체 사용을 선호하는 것을 classical testing, 목을 선호하는 것을 mockist testing이라 부르고 있음.
- 구글에서는 mockist가 스케일링을 어렵게 만든다고 판단.
- classical testing에 대한 엄격한 가이드라인이 있다고 함.

### Prefer Realism Over Isolation

- 의존성들을 실제 구현체로 사용하는 것이 테스트를 좀 더 현실에 가깝게 만듦.
- 이는 테스트 되고 있는 시스템이 정상적으로 동작할 것이라는 자신감으로 이어짐.
- 만약 테스트 더블에 너무 많이 의존하고 있다면, 엔지니어는 통합테스트 또는 수동 기능 검증을 통해 이와 비슷한 수준의 확신을 얻을 수 있음.
- 이런 부수적인 작업들은 개발을 느리게 만듦.
- 느리다는 이유로 생략하거나 깜빡하고 빠뜨린다면 버그로 이어지기도.

#### CASE STUDY: @DONOTMOCK

- 구글에서는 `@DoNotMock`이란 애노테이션이 선언된 클래스나 인터페이스가,
- 목킹 되어있다면 정적 검사에서 알려준다고 함.
- API 소유자가 이렇게 선언해 두는 것인데, 이는 소유자가 계속 변경을 안정적으로 하고 싶기 때문.

```java
@DoNotMock("Use SimpleQuery.create() instead of mocking.")
public abstract class Query {
  public abstract String getQueryValue();
}
```

### How to Decide When to Use a Real Implementation

- 빠르고, 결정적이고<sup>deterministic</sup>, 단순한 의존성을 가진다면 실제 구현체를 선호.
- 예컨대, 값 객체는 실제 구현체가 사용되어야 함.
- 하지만 실제 구현체를 사용하는 게 불가능할 때가 있음.
- 그리고 실행 시간, 결정성, 의존성 복잡도를 고려해야 함.

#### Execution time

- 단위 테스트 품질의 중요한 속성 중 하나는 빨라야 한다는 것.
- 개발 과정에서 반복적으로 수행되면서 빠른 피드백을 주어야 함.
- 따라서 실제 구현체가 느리다면 테스트 더블이 매우 유용.
- 그런데 어느 정도가 단위 테스트하기에 느린 걸까?
- 1ms, 10ms, 1s 등을 정할 순 있으나,
- 엔지니어들이 생산성 저하를 느끼는지 또는 얼마나 많은 테스트에서 실제 구현체를 사용하는지가 중요.
- (실제 구현체가 1s 이상 소요되지만 5개 테스트 케이스에서만 사용된다면 괜찮음. 하지만 500개 이상이라면 X)
- 한편, 병렬화를 통해 실행 시간을 줄일 수 있음. 구글에선 테스트를 여러 서버에서 실행.
- 그리고 실제 구현체 사용이 빌드 시간을 늘리는 트레이드 오프도 고려해야 함. 바뀐 부분에 대해서만 빌드 되는 것도 도움이 됨.

#### Determinism

- 만약, 테스트가 항상 동일한 결과를 가져다 준다면 이를 결정적<sup>deterministic</sup>이라 할 수 있음.
- 코드가 바뀌지 않았는데도 결과가 바뀌는 비결정적인 테스트는 테스트 수트의 건강에 악영향.
- 개발자들은 테스트 결과를 신뢰하지 못하고 실패를 무시하게 됨.
- 아주 드물게 이런 일이 발생한다면 괜찮음.
- 하지만 비결정성이 잦다면 실제 구현체를 테스트 더블로 교체할 시기.
- 비결정적 코드 실행의 한 예는 멀티스레드 활용. 어떤 스레드가 먼저 실행됐느냐에 따라 결과가 달라질 수 있음.
- 또 다른 예로는 외부 서비스를 호출하는 코드. 외부 서비스 상태에 응답이 달라지고 테스트에 영향. 테스트 더블을 사용하거나, 그럴 수 없다면 hermetic 인스턴스 서버를 사용.
- 시스템 시계에 의존하는 코드도 비결정적. 이 대신 하드코딩 된 특정 시간을 반환하는 테스트 더블 사용 권장.

#### Dependency construction

```java
Foo foo = new Foo(new A(new B(new C()), new D()), new E(), ..., new Z());
```

- 극단적이긴 하지만 위와 같이 복잡한 의존성 트리가 필요할 수 있음.
- 일단, 이런 코드는 작성하는 데도 주의가 필요하고,
- 변경이 일어날 때마다 항상 같이 챙겨줘야 하므로 유지보수성도 떨어짐.

```java
@Mock Foo mockFoo;
```

- 위와 같이 테스트 더블을 사용해서 간소화 시킬 수 있음.
- 그러나 실제 구현체 사용이 단순함에 비해 더 큰 이점을 가져다 줌을 강조.
- 그래서 프로덕션 코드에서와 같이 팩토리 메서드나 자동화된 의존성 주입을 활용하라고 함.

## Faking

```java
// This fake implements the FileSystem interface. This interface is also
// used by the real implementation.
public class FakeFileSystem implements FileSystem {
  // Stores a map of file name to file contents. The files are stored in
  // memory instead of on disk since tests shouldn’t need to do disk I/O.
  private Map<String, String> files = new HashMap<>();
  @Override
  public void writeFile(String fileName, String contents) {
    // Add the file name and contents to the map.
    files.add(fileName, contents);
  }
  @Override
  public String readFile(String fileName) {
    String contents = files.get(fileName);
    // The real implementation will throw this exception if the
    // file isn’t found, so the fake must throw it too.
    if (contents == null) { throw new FileNotFoundException(fileName); }
    return contents;
  }
}
```

- 실제 구현체를 테스트에서 사용할 수 없다면 페이크<sup>fake</sup> 사용이 종종 최선.
- 페이크가 선호되는 이유는 실제 구현체와 비슷하게 동작하기 때문.
- 즉, 테스트에서 상호작용하는 대상이 실제 구현체인지 페이크인지 알 수 없음.

### Why Are Fakes Important?

- 실제 구현체를 사용할 때의 단점을 피하면서, 테스트를 효과적이고 빠르게 실행시킬 수 있음.
- 또한, 다른 테스트 더블들에 비해 상대적으로 더 명확하고 덜 깨지기 쉬우며 더 효과적인 방법.

### When Should Fakes Be Written?

일단, 페이크 사용시 고려해야 하는 트레이드 오프 언급.

- 페이크를 만드는 데는 더 많은 노력과 더 많은 모데인 지식이 필요.
- 왜냐면 실제 구현체와 비슷하게 동작해야 하기 때문.
- 또한, 유지보수도 필요함. 실제 구현체의 행위가 바뀔 때 함께 바꿔줘야 함.
- 이러한 이유로 실제 구현체를 소유한 팀에서 페이크도 작성하고 유지보수해야 함.
- 따라서 페이크를 사용할 때의 생산성 이점이 작성과 유지보수의 비용보다 더 큰지 따져봐야.

다음으로, 유지보수 해야 하는 페이크 수 줄이는 방법을 이야기.

- 테스트에선 사용할 수 없는 코드의 루트에 대해 페이크를 만들어야 함.
- 예컨대, 데이터페이스를 테스트에 사용할 수 없다면,
- 데이터베이스 API를 호출하는 각 클래스가 아니라,
- 데이터베이스 API 그 자체에 대한 페이크가 존재해야 함.

### The Fidelity of Fakes

페이크의 중요한 고려 요소는 정확성<sup>fidelity</sup>.

- 만약 페이크가 실제 구현체와 다르게 동작한다면, 페이크를 사용하는 테스트의 유용함을 떨어짐.
- 페이크를 사용하는 테스트는 통과하지만 실제 구현체를 사용할 땐 실패할 것.
- 물론 완벽한 정확도는 언제나 불가능.
- 예를 들어, 페이크 데이터베이스는 메모리에 데이터를 저장하고,
- 실제 데이터베이스는 하드 드라이브 저장소를 사용.
- 하지만 정확도는 최대한 유지되어야 함.
- 주어진 입력 값에 대해 동일한 결과를 반환하고 동일한 상태 변경을 해야 함.
- 예컨대, `database.save(itemId)`을 호출했을 때, 존재하지 않는 ID라면 저장이 성공해야 하고, 존재하는 ID라면 에러를 일으켜야 함.

그리고 이 정확성에 관해서 아래와 같이 이야기.

> One way to think about this is that the fake must have perfect fidelity to the real implementation, but only from the perspective of the test.

- 이와 관련해서 해싱 API를 사례로 들고 있음.
- 테스트에서의 해싱 페이크는 실제 구현체와 동일한 값을 반환할 필요는 없음.
- 그러나 반환 값이 고유해야 하는 계약은 지켜야 함.
- 지키지 않아도 되는 정확성의 또 다른 사례로는 지연과 리소스 소비.
- 물론 이런 제약을 테스트해야 하는 경우라면 페이크를 쓸 수 없을 수도.

### Fakes Should Be Tested

페이크에 대한 테스트 코드도 있어야 한다는 이야기.

- 실제 구현체에 대응되는 계약을 잘 수행하는지 보장하기 위함.
- 처음에는 괜찮을지 몰라도 시간이 지나면서 실제 구현체는 진화할 것이고 점점 더 페이크와의 격차는 벌어질 것.

페이크에 대한 테스트 작성법도 소개.

- 실제 구현체의 결과와 페이크의 결과를 서로 비교하는 것으로 페이크 테스트가 가능.
- 실제 구현체 사용의 단점이 페이크에 대한 테스트로만 한정되니 괜찮음.

### What to Do If a Fake Is Not Available

- 페이크가 없다면 일단 API 소유자에게 만들어 달라고 요청.
- 그럴 수 없다면 직접 작성. API의 모든 호출을 감싸는 클래스를 하나 만들고, 여기에 대응하는 페이크 클래스를 만들면 됨.
- 또는 실제 구현체를 사용한다고 결정할 수도 있음.
- 또는 다른 테스트 더블 기법을 사용.
- 트레이드 오프와 선택의 문제.

## Stubbing

- 테스트를 위해 함수의 행위를 하드코딩하는 것.
- 실제 구현체를 대체하는 빠르고 쉬운 방법.

```java
@Test public void getTransactionCount() {
  transactionCounter = new TransactionCounter(mockCreditCardServer);
  // Use stubbing to return three transactions.
  when(mockCreditCardServer.getTransactions()).thenReturn(
      newList(TRANSACTION_1, TRANSACTION_2, TRANSACTION_3));
  assertThat(transactionCounter.getTransactionCount()).isEqualTo(3);
}
```

### The Dangers of Overusing Stubbing

- 테스트에 스텁을 적용하는 것이 매우 쉬워서,
- 실제 구현체를 쓰기 어려울 때 스텁을 쓰고 싶은 욕구가 커짐.
- 하지만 스텁의 남용은 테스트 유지보수에 있어 심각한 생산성 손실을 가져옴.

#### Tests become unclear

- 일단, 스텁을 위한 별도의 코드를 작성해야 함.
- 이는 테스트의 의도를 흐리게 만들고,
- 테스트 대상이 되는 시스템 구현체에 익숙하지 않은 사람에겐 이해하기 어려움.
- 스텁이 적절하지 않음을 알려주는 한 가지 신호는,
- 특정 함수가 왜 스텁이 됐는지 이해하기 위해 시스템을 하나씩 살펴봐야 할 때.

#### Tests become brittle

- 스텁은 테스트 코드에 구현체의 세부사항을 누출시킴.
- 프로덕션 코드가 바뀌면 테스트 코드 또한 함께 바꿔줘야 함.
- 좋은 테스트란 이상적으로 테스트 대상의 행위가 바뀔 때만 바뀌어야 함.

#### Tests become less effective

- 스텁을 사용하면 스텁 된 함수가 실제 구현체와 유사한 행위를 하는지 보장할 방법이 없음.
- 계약 세부사항이 중복되는 것이고 중복은 제대로 된 건지 확인이 어려움.
- `when(stubCalculator.add(1, 2)).thenReturn(3);`
- 또한 상태를 저장할 수 있는 방법도 없음. 어떤 경우에는 이것이 테스트를 어렵게 만듦.

#### An example of overusing stubbing

과도하게 스텁이 사용된 예.

```java
@Test public void creditCardIsCharged() {
  // Pass in test doubles that were created by a mocking framework.
  paymentProcessor =
      new PaymentProcessor(mockCreditCardServer, mockTransactionProcessor);
  // Set up stubbing for these test doubles.
  when(mockCreditCardServer.isServerAvailable()).thenReturn(true);
  when(mockTransactionProcessor.beginTransaction()).thenReturn(transaction);
  when(mockCreditCardServer.initTransaction(transaction)).thenReturn(true);
  when(mockCreditCardServer.pay(transaction, creditCard, 500))
      .thenReturn(false);
  when(mockTransactionProcessor.endTransaction()).thenReturn(true);
  // Call the system under test.
  paymentProcessor.processPayment(creditCard, Money.dollars(500));
  // There is no way to tell if the pay() method actually carried out the
  // transaction, so the only thing the test can do is verify that the
  // pay() method was called.
  verify(mockCreditCardServer).pay(transaction, creditCard, 500);
}
```

그리고 스텁을 사용하지 않은 테스트로 재작성하면 아래와 같음. 테스트가 좀 더 간결해지고, 구현 세부사항이 테스트에 드러나지 않음. 특별한 준비 작업도 필요 없음.

```java
@Test public void creditCardIsCharged() {
  paymentProcessor = 
      new PaymentProcessor(creditCardServer, transactionProcessor);
  // Call the system under test.
  paymentProcessor.processPayment(creditCard, Money.dollars(500));
  // Query the credit card server state to see if the payment went through.
  assertThat(creditCardServer.getMostRecentCharge(creditCard))
      .isEqualTo(500);
}
```

하지만 우리는 실제 신용 카드 서버가 호출되길 원하지 않으므로, 페이크 신용 카드 서버가 더 적절한 선택이 될 수 있음. 페이크를 쓸 수 없다면 실제 구현체 사용을 고려. 다만, 목 서버 같은 것을 두면 됨(실행 시간이 다소 늘어나긴 할 것).

### When Is Stubbing Appropriate?

- 실제 구현체 전체를 대체하는 대신, 테스트에서 어떤 함수가 특정 값을 반환하기를 원한다면, 스텁이 적절할 수도.
- 함수의 행위가 테스트에서 인라인으로 정의되므로, 실제 구현체나 페이크로 할 수 없는 특정 상황(값이나 에러)을 다양하게 시뮬레이션 할 수 있음.
- 목적을 명확히 하려면, 스텁 된 함수는 테스트 단정문<sup>assertion</sup>과 직접적 연관성을 가져야 함.
- 따라서, 테스트에서 아주 적은 수의 함수만 스텁해야 함. 너무 많은 스텁은 테스트를 모호하게 만듦.
- 만약, 테스트에 너무 많은 함수가 스텁 되어야 한다면, 이는 스텁 남용의 신호이거나, 테스트 대상이 너무 복잡하므로 리팩토링 되어야 함을 나타냄.
- 하지만, 스텁이 적절한 경우라고 하더라도, 실제 구현체나 페이크 객체를 여전히 선호해야 함.
- 이들은 구현 세부사항을 노출시키지 않고 높은 정확성을 보장함.

## Interaction Testing

- 실제 구현체 함수를 호출하지 않으면서, 그 함수가 어떻게 호출되는지를 검사하는 테스트.
- 목 프레임워크를 활용하면 이것이 매우 쉽지만 필요한 경우에 제한해서 사용하는 것이 중요.

### Prefer State Testing Over Interaction Testing

- 상태 테스팅을 통해 코드를 테스트하는 것을 선호한다는 반복되는 이야기.
- 반환 되는 값이나 다른 상태를 통해 대상을 검사하는 것.

```java
// State Testing
@Test public void sortNumbers() {
  NumberSorter numberSorter = new NumberSorter(quicksort, bubbleSort);
  // Call the system under test.
  List sortedList = numberSorter.sortNumbers(newList(3, 1, 2));
  // Validate that the returned list is sorted. It doesn’t matter which
  // sorting algorithm is used, as long as the right result was returned.
  assertThat(sortedList).isEqualTo(newList(1, 2, 3));
}

// Interaction Testing
@Test public void sortNumbers_quicksortIsUsed() {
  // Pass in test doubles that were created by a mocking framework.
  NumberSorter numberSorter =
      new NumberSorter(mockQuicksort, mockBubbleSort);

  // Call the system under test.
  numberSorter.sortNumbers(newList(3, 1, 2));

  // Validate that numberSorter.sortNumbers() used quicksort. The test
  // will fail if mockQuicksort.sort() is never called (e.g., if
  // mockBubbleSort is used) or if it’s called with the wrong arguments.
  verify(mockQuicksort).sort(newList(3, 1, 2));
}
```

- 위 예제는 `sortNumbers`에 대한 상태 테스팅과 상호작용 테스팅.
- 상호작용 테스트팅에서는 숫자들이 정렬이 됐는지 확인할 수 없음.
- 상호작용 테스팅에서는 함수의 행위를 가정할 뿐이지만,
- 상태 테스팅에서는 그 가정을 실제로 검증할 수 있음.
- 한편, 스텁과 마찬가지로, 구현 세부사항이 테스트에 노출된다는 단점도 있음.
- 그리고 이런 노출들이 테스트를 깨지기 쉽게 만듦.
- 이런 이유로 이를 농담처럼 [change-detector tests](https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html)라고 부르기도.

### When Is Interaction Testing Appropriate?

- 실제 구현체나 페이크를 쓸 수 없는 경우라면, 상호작용 테스팅을 통해 기본적인 수준의 안정감이라도 얻을 수 있음.
- 호출 횟수나 순서가 달라지면 행위가 바뀌지만 상태를 통해 검사하기는 어려운 경우에도 유용할 수 있음.
- 예컨대, 캐싱을 통해 DB로의 호출을 줄이고 싶을 때, DB 객체가 딱 1번만 호출되고 말았는지 검사할 수 있음.
- 하지만 상호작용 테스팅이 적절해 보이는 경우라고 하더라도, 혹시 통합 테스트처럼 좀 더 큰 범위의 테스트를 통해 검사할 수 없는지 검토.

### Best Practices for Interaction Testing

#### Prefer to perform interaction testing only for state-changing functions

함수 호출은 크게 2가지 종류.

- State-changing: `sendEmail()`, `saveRecord()`와 같이 부수 효과를 가지는 것.
- Non-state-changing: `getUser()`, `readFile()`처럼 부수 효과가 없는 것. 단지 정보를 반환.

일반적으로 상태가 바뀌는 함수에 대해서만 상호작용 테스팅을 해야 함. 이런 저런 설명을 하고 있는데 어찌보면 당연한 이야기.

```java
@Test public void grantUserPermission() {
  UserAuthorizer userAuthorizer =
      new UserAuthorizer(mockUserService, mockPermissionDatabase);
  when(mockPermissionService.getPermission(FAKE_USER)).thenReturn(EMPTY);
  
  // Call the system under test.
  userAuthorizer.grantPermission(USER_ACCESS);
  
  // addPermission() is state-changing, so it is reasonable to perform
  // interaction testing to validate that it was called.
  verify(mockPermissionDatabase).addPermission(FAKE_USER, USER_ACCESS);
  
  // getPermission() is non-state-changing, so this line of code isn’t
  // needed. One clue that interaction testing may not be needed:
  // getPermission() was already stubbed earlier in this test.
  verify(mockPermissionDatabase).getPermission(FAKE_USER);
}
```

#### Avoid overspecification

- 한 번에 한 가지 행위만 검사하라는 행위 기반 테스팅 다시 언급.
- 이는 상호작용 테스팅에서도 마찬가지.
- 간결함과 명확성을 가져다 줄 뿐만 아니라, 행위가 바뀔 때 테스트로의 영향을 국소화.

```java
// Overspecified interaction tests
@Test public void displayGreeting_renderUserName() {
  when(mockUserService.getUserName()).thenReturn("Fake User");
  userGreeter.displayGreeting(); // Call the system under test.
  
  // The test will fail if any of the arguments to setText() are changed.
  verify(userPrompt).setText("Fake User", "Good morning!", "Version 2.1");
  
  // The test will fail if setIcon() is not called, even though this
  // behavior is incidental to the test since it is not related to
  // validating the user name.
  verify(userPrompt).setIcon(IMAGE_SUNSHINE);
}

// Well-specified interaction tests
@Test public void displayGreeting_renderUserName() {
  when(mockUserService.getUserName()).thenReturn("Fake User");
  userGreeter.displayGreeting(); // Call the system under test.
  verify(userPrompter).setText(eq("Fake User"), any(), any());
}
@Test public void displayGreeting_timeIsMorning_useMorningSettings() {
  setTimeOfDay(TIME_MORNING);
  userGreeter.displayGreeting(); // Call the system under test.
  verify(userPrompt).setText(any(), eq("Good morning!"), any());
  verify(userPrompt).setIcon(IMAGE_SUNSHINE);
}
```

# 14. Larger Testing

- 구글에서는 실제로 큰 규모의 테스트가 많이 있음.
- 이는 소프트웨어 엔지니어링 건강에 있어 필수인, 리스크 완화 전략의 중요한 부분을 차지함.
- 하지만 이 세트스들이 가치있고 리소스 잡아 먹는 하마가 되지 않기 위한 일이 쉬운 것은 아님.
- 이 챕터에서는 큰 규모의 테스트가 무엇이고, 언제 수행해야 하며, 이들을 유지하는 베스트 프랙틱스들을 다룸.

## What Are Larger Tests?

일단, 앞에서도 언급했던 크기<sup>size</sup>와 범위<sup>scope</sup>로 설명.

- 크기가 큰 테스트는 단일 스레드/프로세스/머신 제약이 없음.
- 규모가 큰 테스트는 여러 개의 실제 의존성을 가지고 테스트 더블은 적음.
- 규모 큰 테스트는 종종 종단간 또는 시스템 테스트라고도 불림.

규모 있는 테스트는 아래의 특징을 가짐.

- 느림(slow). 큰 테스트에서 기본 타임아웃은 15분 또는 1시간. 몇 시간에서 며칠이 걸리는 테스트들도 있음.
- 비밀폐형(nonhermetic). 다른 테스트나 트래픽과 리소스를 공유.
- 비결정적(nondeterministic). 비밀폐형인 만큼 결정성을 보장할 수 없음. 다른 테스트나 사용자 상태에 영향 받음.

규모 큰 테스트는 왜 필요할까?

- 당신이 작성한 프로그램을 어떻게 확인하나?
- 단위 테스트를 만들어 실행하기도 하지만, 결국 실제 바이너리를 실행시키고 직접 확인하지는 않는가?
- 또한, 업그레이드가 일어날 때 코드가 정상적으로 계속 돌아가는지 어떻게 알 수 있나?
- 예컨대, 사용하고 있는 구글 지도 API가 새로운 버전으로 나왔다면?
- 단위 테스트로는 하위호환성 이슈가 있는지 알아내기 어려움.
- 아마도 직접 실행하고 이것 저것 테스트하며 깨지는 곳을 찾아야 할 것.
- 단위 테스트는 개별 함수와 객체, 모듈에 대한 확신을 줌.
- 규모 있는 테스트는 전체 시스템이 의도대로 동작하는지에 대한 확신을 줌.
- 그리고 이에 대한 자동화된 테스트는 수동 테스트로는 할 수 없는 스케일링이 가능.

### Fidelity

- 규모 큰 테스트가 존재하는 주요 이유는 정확성<sup>fidelity</sup>.
- 일단, 이 정확성은 어떤 환경인지에 따라 달라짐.
- Unit Tests < 1-process SUT < Isolated SUT < Staging < Production
- 여기서 적절한 지점을 택하는 것이 중요. 정확성이 올라갈 때 비용과 실패 리스크도 함께 올라가기 때문.
- 다음으로, 테스트 컨텐츠가 얼마나 현실에 가까운지에 따라 정확성이 달라짐.
- 프로덕션에서 복제된 데이터가 아마도 현실에 제일 가까울 것.
- 하지만, 새로운 코드를 런칭하기도 전에 어떻게 실제 테스트 트래픽을 일으킬 수 있는지는 모순.

### Common Gaps in Unit Tests

단위 테스트가 리스크 완화 커버리지를 잘 제공하지 못하는 영역들 소개.

#### Unfaithful doubles

- 일반적으로 목킹 대상은 테스트 작성자와는 다른 엔지니어가 만든 것.
- 따라서 목킹 대상의 실제 행위를 잘 모를 수 있음.
- 그리고 목은 낡을 수 있음. 실제 객체의 행위가 바뀌어도 목에는 반영 안 될 수 있음.
- 이런 문제를 극복하고자 앞서 이야기 한 것처럼, 서비스 주체자가 페이크도 만들어 제공하는 것이 좋음.

#### Configuration issues

- 일반적으로 바이너리를 실행할 땐 시작 스크립트나 배포 설정들을 포함하기 마련.
- 하지만 단위 테스트에서는 이런 정보들이 충분히 주어지지 않음.
- 충분히 테스트되지 않은 설정에 의한 장애 사례들도 언급.
- 이런 이유 때문에 설정 또한 코드와 마찬가지로 함께 버전 관리 되어야 한다고 주장.

#### Issues that arise under load

- 성능, 로드, 스트레스 테스팅을 통해 대용량이나 대량 트래픽에서의 검증을 진행.
- 이를 단위 테스트에서 수행하기는 어려움.
- 개발 워크플로우에서 자주 실행되며, 따라서 빨라야 하고 작아야 하기에.

#### Unanticipated behaviors, inputs, and side effects

- 단위 테스트는 예상된 행위와 입력만을 검증.
- 하지만 사용자들에 의해 발견되는 것들은 대부분 예상치 못한 것들.
- 이는 예상치 못한 행위를 테스트하기 위해 기존과 다른 테스트 기법이 필요함을 알려줌.
- Hyrum's Law가 다시 언급됨. 명시된 계약 외에도 사용자들에게 영향 줄 수 있다는 것.

#### Emergent behaviors and the "vacuum effect"

- 단위 테스트는 그것이 다루는 범위로 제한됨.
- 이 범위 바깥의 행위가 바뀔 때는 감지할 수 없음.
- 게다가 단위 테스트는 빠르고 결정적이어야하므로,
- 고의적으로라도 네트워크나 실제 의존성, 데이터 등에 의한 혼란이 제거됨.
- 실제 세상의 혼란에서 격리된 진공 상태에 있는 것.
