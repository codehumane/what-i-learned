# Software Engineering at Google

# Thesis

# 1. What is Software Engineering?

프로그래밍과 소프트웨어 엔지니어링의 3가지 중요한 차이.

1. 시간
   - 수명이 길어질수록 변경이 많음.
   - 비즈니스, OS, 하드웨어, 언어 버전 등.
   - 이에 대응할 수 있는 것이 중요해짐.
   - 수명이 짧은 코드는 단지 프로그래밍 문제에 가까움.
2. 스케일
   - 프로그래밍 작업은 보통 개인의 작업.
   - 소프트웨어 엔지니어링은 팀의 노력.
   - 팀 협업은 개인 프로그래밍에 없던 여러 가지 새로운 문제를 안겨줌.
   - 하지만 혼자할 때에 비해, 좋은 시스템을 만들 가능성이 큼.
   - 제품, 조직, 개발 워크플로우의 규모가 커짐에 따른 비용을 잘 유지하고 관리해야 함.
3. 트레이드 오프
   - 종종 부정확한 가치 메트릭을 기반으로,
   - 상위 수준의 이해관계 결과물을 고려하며,
   - 여러 길 사이의 트레이드 오프를 고려한 복잡한 결정을 내려야 함.

## Time and Change

- 모바일 앱이나 스타트업의 코드 수명은 비교적 짧음.
- 하지만 구글 검색이나 Apache HTTP 프로젝트의 수명은 예측할 수 없음.
- 내부적으로는 indefinitely로 간주한다고 함. 
- 이런 수명이 긴 프로젝트에서는 업그레이드 문제가 중요.
- 이런 업그레이드를 고려하지 않다가 한 번에 업그레이드 하려는 경우 그 비용은 상당.
- 이 비용을 겪고 나면 후속 업그레이드도 크다고 느껴, 코드를 재작성하거나 아예 업그레이드 자체를 피하기도.
- 하지만 첫 번째 큰 업그레이드 이후에도 지속적으로 나아가는 것이 프로젝트의 장기 유지가능성의 핵심.
- 물론, 업그레이드가 제공하는 가치와 비용, 그리고 프로젝트의 기대 수명을 같이 고려해야.

### Hyrum's Law

다른 엔지니어들에게 사용되는 프로젝트를 맡고 있다면, Hyrum's Law가 "it works"와 "it is maintainable"의 차이에 대한 중요한 교훈이 됨.

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.

### Why Not Just Aim for "Nothing Changes"?

- 새로운 기능을 지속적으로 제공해야 하고
- 보안 취약점이 새로 발견되고
- 버그도 계속 발견됨
- CPU 등의 변경에 따라 최적화도 계속 달라짐
- 수명이 긴 프로젝트라면 변경을 피하기 어려움

## Scale and Efficiency

- 조직과 개발/운영 프로세스 역시 유지 가능해야 한다는 이야기.
- 조직이 커질 때, 그 조직의 반복 작업을 돕는 컴퓨팅 리소스도 함께 스케일링 되어야 함.
- 그렇지 않으면 작업 시간은 점점 늘어나고, 이는 작업을 미루게 되는 배경이 되기도.
- 지속 가능성을 위한 노력의 예시로는 아래와 같은 것들이 있음.
    - 조직 규모에 맞게 테스트 클러스터도 함께 확장 되어야 함.
    - 전체 빌드에 걸리는 시간, 리포지토리를 pull 받는 데 걸리는 시간도 커지지 않도록.
    - 새로운 버전의 랭귀지로 업그레이드 하는 데 걸리는 시간들도 마찬가지.
- 이런 문제들은 서서히 자라나며 잘 인식하지 못할 수 있음.
- [bolied frog](https://en.wikipedia.org/wiki/Boiling_frog#As_metaphor)를) 언급하며 이런 특징을 가진 문제들의 위험성을 강조.

### Policies That Don't Scale

- 조직이 커지거나 코드 베이스가 커질 때 일의 양도 같이 늘어난다면 not scale.
- 그 일의 자동화나 최적화를 하는 메커니즘이 적절한 곳에 있어야 함.
- 일반적인 deprecation 접근법을 스케일 문제의 예로 들고 있음.
- 새로운 위젯을 만들었다고 가정.
- 그리고 기존 것의 사용을 중단하고 새로운 것의 사용을 강제.
- 작은 소프트웨어에서는 이것이 가능할 수도.
- 그러나 의존성 그래프가 깊고 넓은 경우엔 실패하기 쉬움.
- 회사의 성장 속도를 저해하는 요인이 되기도.
- 대신, 하위 호환성을 유지하는 방식을 권장.
- 의존 프로젝트들은 더 이상 따라잡기 위한 급진적 노력을 기울이지 않아도 됨.

### Policies That Scale Well

- 한 가지 사례는 인프라스트럭처 팀의 안전한 변경을 보호하는 정책.

> If a product experiences outages or other problems as a result of infrastructure changes, but the issue wasn't surfaced by tests in out CI system, it is not the fault of the infrastructure change.

- 공통 CI 시스템에서 실행되지 않는 맞춤형의 복잡한 테스트는 신경쓰지 않는다는 것.
- 그렇지 않으면 인프라 팀은 영향 받는 모든 팀의 코드를 추적하고 테스트는 어떻게 했는지 일일이 물어봐야 함.
- 100명의 엔지니어가 있을 때는 이것이 가능했으나 규모가 커진 지금은 불가능.
- 대신, 공유된 커뮤니케이션 포럼과 전문 지식이 조직의 규모 확장에 도움.
- 엔지니어들이 공유 포럼에서 토론하고 질문에 응답하면서 지식이 전파되고 전문가들이 생겨남.

### Shifting Left

- 개발 단계의 앞 쪽에서 버그나 보안 이슈를 발견하고 대응할 수록,
- 더 적은 비용을 감수한다는 일반적인 이야기가 갑자기 나옴.
- 일반적으로 보던 개발 단계가 뒤로 갈수록 비용이 지수적으로 늘어나는 그래프도 소개.

## Trade-offs and Costs

- 프로그램을 작성, 소프트웨어의 생명주기, 엔지니어 규모 확장 시에도 소프트웨어를 유지하는 것을 이해했다면, 남은 것은 올바른 결정 내리기.
- 구글 내에서는 "내가 그렇게 말했기 때문"에 대한 강한 혐오감이 있음.
- 모든 것에는 이유가 있어야.
- 그리고 어느 주제든 결정자가 있어야 함.
- 잘못된 것 같아 보이는 결정에 대해서는 이의 제기.
- 다만 목표는 만장일치가 아니라 합의.
- 이런 의사 결정시에는 여러 비용을 고려해야 하는데,
- 재정적, 리소스 측면 등과 같은 것 뿐만 아니라 사회적 비용이나 구성원들의 만족감 같은 비용도 포함.

### Example: Markers

- 구글을 데이터 중심 문화라고 불러주지만 너무 단순화 된 얘기.
- 데이터가 없는 경우에는 증거, 선례, 논쟁으로 결정.
- 모든 가능한 선택지를 두고 트레이드 오프를 고려하며 현명한 결정을 내리려 노력.
- 때때로 직감이나 베스트 프랙틱스에 기반한 결정이 이뤄지기도 하지만, 근본적이고 실제적인 비용을 측정하거나 추정하는 모든 방식을 다 사용한 이후에나 가능.

### Inputs to Decision Making

- CPU와 네트워크 간 트레이드 오프 측정과 같이,
- 결정을 내리기 위한 데이터가 측정할 수 있거나 적어도 추정이 가능한 것들이 있음.
- 한편, 측정하기 어렵거나 측정 방법조차 모를 때도.
- 잘 설계 되지 못한 API가 가져오는 비용 측정이 그 예.
- 후자의 것도 측정하기 위한 노력을 하긴 하지만, 측정이나 예측하기 어렵다는 것도 인정하면서, 우선순위를 낮추지 않고 계속 다루려 노력해야 함.

### Example: Distributed Builds

- 로컬 빌드가 오래 걸려서 점점 문제가 됐음.
- 빌드를 최대한 빠르게 하는 방법을 고민하기 시작.
- 고성능 개발 장비는 대부분 유휴 상태이기 때문에 좋은 선택은 아니라고 판단.
- 구글은 자신들만의 분산 빌드 시스템을 만들었음.
- 물론, 이를 만드는 비용도 발생했고, 개발자들의 습관/워크플로우을 바꾸는 데에도 많은 시간이 걸림. 컴퓨팅 리소스는 당연.
- 하지만 전체적으로 아낄 수 있는 시간이 컸음.
- 그래서 헤피 엔딩이냐. 꼭 그런 것만은 아님.
- 로컬에서는 커지지 않게 신경 쓰던 의존성이 마구 늘어남.
- 실행 환경이 빠르기 때문에 신경 쓰지 않아도 문제가 되지 않았던 것.
- Jevons 역설.

### Example: Deciding Between Time and Scale

- 문제 해결을 위해 라이브러리 등의 의존성을 추가할 수도 있음.
- 또는 좀 더 요구에 들어맞도록 이를 포크/재개발을 할 수도 있음.
- 맞춤형은 새로운 기능을 추가하기도 쉽고, 최적화에도 유리. 의존성의 변경으로부터 자유롭기도.
- 하지만 모든 것을 직접하게 되면, 확장성과 더불어 지속가능성이 떨어짐.
- 보안 이슈를 단지 의존성 업데이트 만으로 해결할 수 없는 것이 그 예.

# 2. How to Work Well on Teams

- 구글 소프트웨어 엔지니어링의 문화적, 사회적 측면을 다루는 부분.
- 통제 가능한 변수인 우리 자신에 초점을 맞추는 것으로 시작.
- 소프트웨어 개발은 팀의 노력.
- 엔지니어링 팀의 성공을 위해 겸손, 존중, 신뢰 기반의 행동이 필요.

## Help Me Hide My Code

- 사람들은 자신이 작업 중인 것을, 다른 사람이 보고 판단하는 것을 두려워 하는 경향이 있다는 이야기.
- 이런 불안함은 더 큰 문제의 징후라는 얘기도 함.

## The Genius Myth

- 사람들은 우상을 찾고 숭배하려는 성향이 있음.
- 리누스 토발즈의 리눅스도 분명 그의 초기 작업이 훌륭하긴 했지만,
- 그 이후의 수 많은 똑똑한 사람들의 노력 없이는 불가능한 결과물.
- 그리고 많은 엔지니어들이 천재처럼 보이길 원한다고 함(하지만 대부분 천재는 아님).
- 이런 천재 신화는 위에서 말한 불안함의 또 다른 징후.
- 그래서 작업 중인 것을 공유하길 꺼려함.
- 천재 신화를 떠나, 단지 좋은 모습만을 보여주고자 하는 마음에, 이런 경향은 더 만연하다고 생각 됨.

## Hiding Considered Harmful

- 만약 모든 시간을 혼자 일하는 데 쓰고 있다면,
- 불필요한 실패의 위험을 키우고 성장의 기회를 날리는 것.
- 물론, 소프트웨어 개발이 깊은 집중력과 개인 시간을 어느 정도 필요로 하는 지적 작업이긴 하지만,
- 협업과 리뷰 역시 매우 중요한 요소.
- 무엇보다도 당신이 올바른 길을 가고 있는지를 어떻게 알 수 있겠는가?

### Early Detection

- 뭔가 완성되기 전까지 공개하는 것을 꺼리는 건 도박.
- 초반일수록 실수하기 쉬움.
- 제대로 하고 있는지를 다른 사람에게 피드백 받으며 반복 확인하고 수정해야 함.
- 처음이 갖는 리스크를 줄이는 일.
- "Fail early, fail fast, fail often"

### The Bus Factor

> the number of people that need to get hit by a bus before your project is completely doomed.

- 프로젝트의 지식과 노하우가 프로젝트에 얼마나 잘 분산되어 있는가?
- 만약, 당신이 프로토타입 코드가 동작하는 원리를 이해하는 유일한 사람이라면,
- 당신이 버스에 치이게 되었을 때 프로젝트는 위험.
- 두 명이서 같이 만들고 있다면 버스 팩터는 2배가 됨.
- 여러 명으로 된 팀으로 일한다면 더 나아짐.
- 영역 별로 2명 이상의 소유자를 갖는 것 외에도 좋은 문서를 두는 것이 프로젝트의 성공을 도움.

### Pace of Progress

- 컴파일하고 일할 때를 생각해보자.
- 한 번에 10,000 라인의 코드를 작성하고 컴파일 버튼을 누르는가?
- 결과는 재앙일 것.
- 프로그래머의 작업은 빽빽한 피드백 루프가 함께 할 때 제일 좋음.
- get feedback as early as possible, test as early as possible, and think about security and production environments as early as possible.
- 모두 "shifting left" 아이디어.
- 이는 코드 레벨 뿐만아니라 전체 프로젝트 레벨에서 필요한 이야기.
- 잘 되는 프로젝트는 빠르게 진화하며 시간이 지남에 따라 바뀌는 환경에 적응해야 함.
- 예상치 못한 설계 장애물이나 정치적 위험을 마주치거나, 단지 계획한 것이 제대로 되지 않기도.
- 요구사항은 계속 변경.
- 이렇게 계획이나 설계가 바로 바로 바뀌어야 한다는 피드백 루프를 어떻게 구성할 수 있을까?
- 답은 팀으로 일하는 것.
- "Many eyes make sure your project stays relevant and on track"

## It's All About the Team

> software engineering is a team endeavor

- 숨어서 비밀 발명품을 준비하는 것으로 세상을 바꾸는 것이 아님.
- 다른 사람들과 함께 일해야 함.
- 비전을 공유하고, 일을 나누고, 서로를 배우며, 훌륭한 팀을 만들어야 함.
- 혼자 만든 소프트웨어 중에 널리 사용되며 성공한 것은 없음.

### The Three Pillars of Social Interaction

- 협업을 잘하기 위해 "세가지 기둥<sup>three pillars</sup>"이라 부르는 사회적 기술을 익히라고 이야기.
- Pillar 1: Humility
  - 당신은 우주의 중심이 아님.
  - 당연히 코드의 중심도 아님.
  - 절대적으로 옳은 사람도 아니고 박식하지도 X.
  - 자기 발전에 열려 있어야.
- Pillar 2: Respect
  - 진심으로 같이 일하는 동료를 대해야 함.
  - 친절하게 대하고 그들의 능력과 성과에 감사해야 함.
- Pillar 3: Trust
  - 다른 사람이 뛰어나며 올바른 일을 할 것임을 믿어야 함.
  - 그리고 적절한 때에는 그들이 드라이빙 하도록 해 주어야.

### Why Do These Pillars Matter?

- 사회적 측면이 갖는 힘이 생각보다 큼.
- 일이 되게 하기 위해 관계를 맺는 것에 관함.
- 관계는 프로젝트보다 오래 지속됨.

### Humility, Respect, and Trust in Practice

- 구체적인 행동과 예시들을 다룸.
- 이 내용들을 보면 당연해 보일지도 모르나, 잘 안지켜지는 부분들일 것.

#### LOSE THE EGO

- 자신이 가장 중요한 인물이라고 생각하는 사람과는 같이 일하고 싶지 않음.
- 모든 이야기의 시작이나 끝맺음 말을 하고 싶어 한다거나,
- 모든 제안이나 토론의 세부 사항에 코멘트를 달아야 한다고 느끼는 등이 그 예.
- 물론 겸손이 중요하다고 해도 동네 북이 되라는 것은 아님.
- 자신감은 중요. 단지 다 아는 척 하려고 하지 말아야.
- 대신 "집단적" 에고를 가져야 함.
- 개인이 멋지게 보이는 것보다 팀의 성취.
- 에고는 여러 방식으로 그리고 여러 번 드러남.
- 이는 생산성을 방해하고 속도를 늦춤.

#### LEARN TO GIVE AND TAKE CRITICISM

- 개인적 비난이 아닌 프로젝트가 더 나아지게 하는 건설적 비판을 강조.
- 여기서 가장 중요한 건 존중. 상대방이나 그들의 작업이 개선되길 원하는 마음으로 진정성 있는 비판이 되어야.
- 한편, 비판을 잘 받아들일 수도 있어야 함.
- 이는 기술적 역량에 대해 겸손해 하는 것은 물론,
- 다른 사람이 당신의 이익을 중요시 여기며 당신을 바보로 생각하지 않는다고 믿는 것을 의미.
- 이를 위해 코드와 당신을 너무 동일시 여기지 않는 노력도 필요.
- "you are not your code"

#### FAIL FAST AND ITERATE

> if you're not failing now and then, you're not being innovative enough or taking enough risks.

#### Blameless Post-Mortem Culture

- 실수로부터 배우는 주요한 방법으로,
- 근본 원인<sup>root-cause</sup> 분석을 통해 실패를 문서화하고,
- 포스트모텀을 작성하는 것을 제시.
- 여기에는 무엇을 배웠고 그 결과로 어떤 행동의 변화를 취할지를 기술.
- 그리고 포스트모텀을 누구나 볼 수 있어야 하고,
- 제안된 변경이 이후에도 제대로 수행하는지 확인할 수 있어야 함.
- 다른 사람들도 이를 보고 문제를 반복하지 않을 수 있음.
- 좋은 포스트모텀은 아래의 7가지를 포함.
  1. 사건의 간단 설명
  2. 이벤트 타임라인(문제의 발견부터 해결까지)
  3. 이벤트의 근본 원인
  4. 영향/손실 측정
  5. 문제를 당장 고치기 위한 액션 아이템
  6. 문제 재발을 막기 위한 액션 아이템
  7. 배운 교훈

#### LEARN PATIENCE

- CSV가 가진 이상한 버그를 수정하고자,
- CSV에 바삭하며 오랜 동료인 Karl과 함께 작업을 시작.
- 하지만 저자는 bottom-up 방식이고 이것 저것 빠르게 시도해 보는 타입.
- 반면 동료는 top-down 엔지니어이고 전체를 살핀 뒤 세부로 들어가는 타입.
- 이로 인해 서로 많이 부딪히게 됨.
- 하지만 인내심을 가지고(?) 다른 협업 방식을 찾아냄.
- 같이 컴퓨터 앞에 앉아서 버그를 먼저 찾고, 문제를 쪼갠 뒤, 각자의 방식으로 서로 반대 방향으로 접근한 뒤, 서로 발견한 내용을 모음.

#### BE OPEN TO INFLUENCE

- 다른 사람들의 영향에 더 열려 있을 수록 당신의 영향력이 높아지고,
- 당신이 좀 더 취약할수록 더 강해질 수 있음.
- 주변에 고집 센 동료들을 생각해보면, 그들을 설득하려 할수록 자신의 길을 더 고수하고, 결국엔 사람들이 그들의 의견을 듣지 않고 장애물처럼 여기며 돌아가게 됨.
- 환경도 변하지 않고 지식도 완벽하지 않는 한, 모든 것에 당신이 올바르긴 어려움.
- 새로운 증거들이 보이면 마음을 바꿀 수 있어야.
- 결정을 확고히 내리기에 앞서 경청해야 하고, 제대로 전달하려면 제대로 들어야 함. 전투에는 신중할 것.
- 취약함을 드러내면 오히려 신뢰할 수 없는 사람이 될 걱정은 X.
- 이는 겸손, 책임을 지려는 의지, 다른 사람의 의견을 신뢰한다는 신호를 드러내는 한 가지 방식.
- 때로는 "모른다"고 말하는 게 최고.

### Being Googley

- 모호한 "Googley" 정의는 채용 인터뷰 등에서 문제가 됨.
- 그래서 아래와 같이 정의를 내렸다고 함.
- Thrives in ambiguity
  - 끊임없이 변화하는 환경 속에서도,
  - 방향이나 메시지의 충돌을 다루고,
  - 동의를 이끌어 내며,
  - 문제를 해결해 나갈 수 있음.
- Values feedback
  - 겸손하게 피드백을 주고 받을 수 있고,
  - 피드백이 개인과 팀의 발전에 얼마나 가치있는지를 이해.
- Challenges status quo
  - 도전적인 목표를 설정하고,
  - 다른 사람들의 저항이나 관습에도 그들을 설득할 수 있는 것.
- Puts the user first
  - 제품 사용자에 대한 존경과 공감을 갖고,
  - 사용자에게 가장 이익이 되는 행동을 추구.
- Cares about the team
  - 동료들에 대한 존경과 공감을 갖고,
  - 그들이 요청하는 것을 적극 돕고,
  - 팀의 응집력을 높임.
- Does the right thing
  - 자신이 하는 것에 윤리의식을 갖기.
  - 팀과 제품의 도덕성을 보호하기 위해 어렵거나 불편한 결정도 내리기.

# 5. How to Lead a Team

- 리더 없이는 어떤 팀도 제대로 동작 X.
- 특히 구글처럼 엔지니어링이 팀 노력인 곳에서는 더더욱.
- 구글에서는 리더십이 2가지.
- 관리자는 사람들의 리더, 테크 리드는 기술적 노력을 이끔.
- 선장이 없는 배는 목적 없이 표류하게 됨.
- 엔지니어 팀을 조종하는 사람이 없다면, 소중한 시간들을 날리게 되고, 그저 무슨 일이 일어나기를 기다릴 뿐(혹은 더 나쁜 상황은 필요하지도 않을 코드를 작성하는 것).

## Managers and Tech Leads (and Both)

- 엔지니어 팀마다 서로 다른 리더를 필요로 함.
- 초창기 팀에서는 TLM(Tech Lead Manager)가 두 가지 역할을 모두 수행.
- 좀 더 큰 팀에서는 경험 많은 인력 관리자가 관리 역할을 맡고,
- 경험이 풍부한 시니어 엔지니어는 테크 리드 역할을 수행.
- 두 역할 모두 팀의 성장과 생산성의 중요한 부분이지만,
- 이 둘에 필요로 하는 역량은 꽤나 다름.

### The Engineering Manager

- 구글에선 관리자가 엔지니어링 백그라운드를 가져야 한다고.
- 엔지니어링 관리자는 성능, 생산성, 팀원들의 행복감에 책임을 가짐.
- 이와 동시에 제품이 비즈니스 요구 사항을 충족하는지를 확인.
- 비즈니스의 요구와 개별 팀원들의 요구가 항상 일치하는 건 아님.
- 이는 종종 관리자를 어렵게 만드는 요인.

### The Tech Lead

- 제품의 기술적 측면을 책임짐.
- 기술적 의사결정, 아키텍처, 우선순위, 속도, 일반적인 관리들이 여기에 해당.
- TL은 엔지니어링 관리자와 협력하여, 팀 인력이 제품을 위해 적절히 배치 되었는지, 팀이 스킬 셋/수준에 부합하는 일을 맡고 있는지 등을 확인.
- TL은 본인이 직접 빠르게 일을 처리하거나 조금 느리더라도 팀원에게 위임하는 것 사이를 왔다 갔다 함.
- 보통은 후자가 팀의 규모나 역량을 키운다는 점에서 더 적합한 선택.

### The Tech Lead Manager

- 작은 팀 또는 초기 팀은 TLM을 두는 것을 기본으로 함.
- 사람과 기술 요구를 모두 다루는 역할.
- 좀 더 규모가 크고 잘 정립된 팀에서는 TL과 엔지니어링 관리자를 각각 두는데,
- 이는 번아웃 되지 않고서는 두 가지 일을 모두 잘 하기 어렵기 때문.
- 그래서 둘로 나누고 각자의 역할에 집중하게 함.
- TLM은 까다로운 직업이며 개인의 일과 위임, 그리고 인력 관리 사이의 균형을 잡을 수 있어야 함.

## Moving from an Individual Contributor Role to a Leadership Role

- 공식적이든 아니든 누군가는 운전자석에 앉아야 함.
- 만약, 당신이 동기부여 되어 있고 참을성 부족한 유형이라면 당신이 그 자리에 앉아 있을 것.
- 팀의 충돌 해결을 돕고 의사결정을 내리며 사람들을 조직화하고 있는 자신을 발견.
- 리더가 절대로 되지 않기로 다짐했더라도 어떻게든 이런 일은 일어남.
- 이런 고통을 "관리염"이라 부르는 사람도 있음.
- 이런 일이 일어났을 때 어떻게 하는 것이 좋을지를 다루는 부분.

### The Only Thing to Fear Is...Well, Everything

- 대부분의 사람들이 관리자가 되고 싶지 않아 하는 이유는 여러가지.
- 가장 큰 이유는 주로 코드 작성에 시간을 보냈기 때문.
- 코드를 작성할 때는 하루가 지나면 코드든 설계 문서든 한 줌의 버그든 결과물이 보임.
- 하지만 관리를 할 때는 하루가 지나도 특별한 것을 했다는 생각이 안 듦.
- 코드를 작성하는 것은 매일 매일 사과를 따는 것과 유사.
- 반면 관리를 하는 것은 바나나를 키우는 것에 가까움.
- 몇 개의 위젯을 만들어 냈느냐가 아닌, 팀이 행복감을 느끼고 생산성 있게 만들고 있느냐가 중요.
- 바나나를 키울 땐 몇 개의 사과를 땄는지 세지 말 것.
- 관리자가 되지 않으려는 또 다른 이유는 "[피터의 법칙](https://ko.wikipedia.org/wiki/피터의_법칙)".
- 구글에선 이를 방지하고자 승진을 앞두고 있는 직원이 지금보다 높은 수준의 일을 일정 기간 동안 수행하게 함.
- 대부분의 사람들이 역량 부족한 관리자 밑에서 일해본 경험이 있음.
- 이런 부정적 인식이 관리자가 되지 않으려는 경향을 만든다는 이야기인 듯.
- 하지만 TL 또는 관리자가 되길 고려해 볼 만한 중요한 이유들이 있음.
- 코드 작성에 뛰어나다고 하더라도 여전히 당신이 만들어 낼 수 있는 상한선은 있음.
- 대신, 당신의 리더십과 함께 팀이 얼마나 훌륭한 많은 코드를 만들어 낼 수 있는지 상상해 볼 것.
- 다음으로, 당신은 리더십에 재능이 있을 수도 있음.

### Servant Leadership

- 관리자에게 찾아오는 일종의 병이 있음.
- 그들의 관리자가 했던 안 좋은 일들을 잊어버리고 어느샌가 따라 하고 있는 것.
- 마이크로매니징, 저성과자 무시, 밀린 채용 등.
- 저자가 처음 관리자가 됐을 때 들었던 이야기는 "무엇보다, 관리하려는 충동에 저항하라"였음.
- 관리 병은 "섬기는 리더십"으로 치료.
- 섬기는 리더로써 겸속, 존경, 신뢰의 분위기를 만들어햐 함.
- 여기에는 아래와 같은 것들이 포함.
  - 팀원들 스스로 제거할 수 없는 관료적 장애물을 제거.
  - 팀이 합의를 이끌어내는 데 도움.
  - 늦게까지 일할 때 저녁 식사를 사줄 수도.
- 팀이 잘 나아갈 수 있게 틈을 메우고, 필요하면 조언도 하며, 직접 손을 더럽히는 것도 주저 X.
- 섬기는 리더가 하는 유일한 매니징은 팀의 기술적 그리고 사회적 건강 관리.
- 종종 기술적 건강에 집중하고자 하는 유혹에 빠질 수도 있으나 사회적 건강 역시 매우 중요.

## The Engineering Manager

- 현대 소프트웨어 회사에서 관리자에게 기대하는 것은 무엇인가?

### Manager is a Four-Letter Word

- 관리자의 역사는 군대 계층에서 비롯되어 산업 혁명에 적용됨. 백 년도 더 된 이야기.
- 공장들이 이곳저곳에 생겨났고, 기계가 계속 돌아가게 하기 위한 작업자들을 필요로 함.
- 이들을 관리하기 위한 감독관이 필요했는데, 작업자들은 언제든 대체 될 수 있으므로, 노동자들을 잘 대우하고 그들의 환경을 개선하는 일에 동기부여 되지 못함.
- 노동자들은 한 번 외운 작업을 반복하면 됐으므로, 이 방식은 꽤 오랫동안 잘 작동함.
- 때로 관리자들은 말로 수레를 끌 때의 당근과 채찍 방법으로 노동자들을 대하기도.
- 이 방식은 공장에서 현대 오피스로의 전환에도 살아 남음.
- 여전히 일부 산업에서는 이것이 지속되고 있음.
- 하지만 창의적 문제 해결이나 사고가 필요한 곳에서는 비효율.

### Today's Engineering Manager

> 전통적 관리자들은 일을 어떻게 끝낼지에 관심을 두는 반면, 훌륭한 관리자들은 무엇을 끝낼지(그리고 팀원들이 해결할 방법을 알아낼 것임을 신뢰)에 관심을 둠.

## Positive Patterns

책은 안티패턴부터 나오는데 정리는 긍정패턴부터 시작.

### Lose the Ego

- "자아를 내려놓는 것"은 사람들로부터 이용 당하라는 것으로 오해되곤 함.
- 겸손을 통해 자기 중심에서 벗어나되 자신감과 의견은 필요.
- 개인의 자아가 너무 크면, 특히 팀 리더의 것이면 더더욱 문제가 됨.
- 자아 분리를 위한 첫 번째로 필요한 것은 팀에 대한 신뢰.
- 이는 팀원들의 역량과 성취를 존중함을 의미.
- 팀을 마이크로매니징 하고 있지 않다면,
- 최전선의 동료가 당신보다 일의 세부사항을 더 잘 알고 있다고 믿는 것.
- 비록 팀의 동의를 이끌어내고 방향을 잡도록 돕는 사람이라고 하더라도,
- 당신의 목표가 어떻게 달성될 수 있는지는 함께 제품을 만들어가는 사람이 가장 잘 결정할 수 있음.
- 이는 팀원들이 제품 성공/실패에 대한 주도성과 책임감을 갖는데 도움.
- 좋은 팀이 있고 품질과 속도에 대한 기준을 설정할 수 있다면 더 많은 것을 달성할 수 있음.
- 처음 리더십 역할을 맡게 되면 모든 것이 올바르게 동작하고 모든 것을 알아야 하고 모든 대답을 할 수 있어야 한다는 강박을 갖곤 함.
- 하지만 불가능. 질문과 비평에 열려 있어야 함.
- 자아 분리에 필요한 마지막은 실수 했을 때 사과하기.
- 남발하라는 것이 아님. 진심이어야 함.
- 사과하는 것이 당신을 약하게 한다는 것은 오해.
- 실수를 인정하면 오히려 존중 받을 수도.
- 상황을 냉정하게 인식할 수 있으며 상식적이고 겸손하다는 것을 드러내기 때문.

### Be a Zen Master

- 엔지니어로써 회의와 냉소 감각을 잘 키워왔을 것.
- 하지만 팀을 이끌 때는 이것이 장애가 될 수 있음.
- 모든 일에 낙관하라는 것은 아님.
- 일의 장애물을 인식하고 있음을 알리면서도 덜 회의적이어야 한다는 것.
- 반응을 잘 조절하고 평정심을 유지해야 함.
- 동료들이 당신의 반응을 보며 어떤 행위를 해야 하는지에 대한 단서를 찾기 때문.
- 아래 내용이 좋아서 그대로 가져와 적음.
- 말이나 행동 하나에도 책임감 있어야 함을 다시금 반성하는 중 @.@

> Another way of thinking about this is the maxim that the leader is always on stage. This means that if you’re in an overt leadership position, you are always being watched: not just when you run a meeting or give a talk, but even when you’re just sitting at your desk answering emails. Your peers are watching you for subtle clues in your body language, your reactions to small talk, and your signals as you eat lunch. Do they read confidence or fear? As a leader, your job is to inspire, but inspiration is a 24/7 job. Your visible attitude about absolutely everything—no matter how trivial—is unconsciously noticed and spreads infectiously to your team.

- 간혹 팀원들이 조언을 구하러 올 수도 있음.
- 해결책을 제시해 주는 것은 도움이 X. 오히려 역효과일 수도.
- 겸손, 존중, 신뢰를 갖고 그들 스스로 문제를 해결하도록 문제를 같이 재정의하고 탐색.
- 결국 문제를 해결할 가능성도 높고, 업무의 주도성을 유지하는 데도 도움.

### Be a Catalyst

- 사람들을 더 가까이 모이게 해서 긍정적 상호작용을 일으키기.
- 팀의 동의를 이끌어내는 것이 대표적인 예.
- 처음부터 끝까지 절차를 이끌어 갈 수도 있고,
- 올바른 방향으로 속도 내어 가도록 부드럽게 밀어줄 수도.
- 여기에 권위는 없어도 됨.
- 권위가 있다면 명령하고 지시할 수 있으나 덜 효과적.
- 물론 가끔 팀이 빠르게 나아가야 한다면, 자발적으로 권위를 쥐어주고 이끌게 할 수도.
- 하지만 이 또한 동의의 한 형태.

### Remove Roadblocks

- 이미 동의가 되어 있더라도 장애물에 막히기도 함.
- 기술적 또는 조직적 장애물 모두를 일컬음.
- 팀원들은 뚫고 지나가기 어려운 장애물이 당신에게는 다루기 쉬운 것일 수도.
- 당신이 이런 장애물이 있을 때 도움을 줄 수 있고, 기꺼이 한다는 것을 팀원들에게 알리는 것도 중요.
- 팀원들이 한참 고민하고도 해결이 안 되어 관리자를 찾아갔을 때 관리자가 문제를 해결할 수 있는 다른 사람을 연결해 주는 사례들을 언급.
- 해결책을 제시하지 말라는 Be a Zen Master의 내용과 장애물을 제거하는 것과는 조금 다른 이야기임에 유의.

### Be a Teacher and a Mentor

- TL로써 가장 힘든 점 중에 하나는 당신이 20분 만에 해결할 수 있는 것을 주니어가 3시간 사용하는 걸 지켜보기.
- 알려주고 배울 기회를 주는 것이 어렵긴 하나 팀을 스케일링 하는 데 중요한 요소.
- 좋은 멘토는 멘티들이 배우는 데 드는 시간과 제품에 기여하는 시간 사이의 트레이드 오프를 잘 고려.
- 멘토가 되는 데는 3가지만 있으면 됨.
  - 팀 프로세스와 시스템에 대한 경험.
  - 남에게 무언가를 설명할 수 있음.
  - 멘티가 얼만큼의 도움을 필요로 하는지 아는 것.
- 특히 마지막이 제일 중요. 지나치게 설명하거나 끊없이 말한다면 멘티는 잘 듣지 않을 것.

### Set Clear Goals

- 명백하지만 많은 리더들이 챙기지 못하는 패턴 중 하나.
- 방향을 설정하고, 우선순위를 정하고, 트레이드 오프를 결정하도록 도와야 함.
- 방향 설정을 위한 한 가지 쉬운 방법은 간결한 미션 문장을 만드는 것.
- 방향을 설정했다면 한 발 물러서서 자율성을 준 뒤 주기적으로 올바르게 가고 있는지 확인.
- 이는 리더의 시간을 확보하여 또 다른 중요한 일에 쓸 수 있게 해주기도 하지만,
- 서로 다른 방향으로 제품을 당기느라 나아가지 못하는 낭비를 예방해 주는 효율을 가져다 주기도.

### Be Honest

- 당신이 팀에 거짓말을 하고 있다는 얘기가 아님.
- 리더 위치에 있을 땐, 무언가 말할 수 없는 경우도 있고, 팀원들이 듣기 싫은 말을 해야 하는 경우도 있음.
- 공유 불가한 것을 질문할 땐 대답할 수 없음을 얘기 해도 괜찮음.
- 모르는 것을 물을 땐 모른다고 답변. 모르는 것이 자신을 약하게 한다는 두려움은 버려야.
- 부정적 피드백을 전달하는 것은 어려움.
- 그러나 칭찬 샌드위치를 사용하는 것은 위험.
- 사람들은 변화가 필요한 비판적 메시지를 잘 수용하지 않으려 하기 때문.
- 대신, 친절하고 공감하는 태도로 간결하게 피드백을 전달.
- 듣는 사람을 덜 방어적이게 할 수 있음.
- 직접적 피드백이나 비판을 제공할 때 '전달이 되는지'가 중요.
- 상대방이 방어적으로 되면 어떻게 바뀌어야 할지가 아니라 어떻게 논쟁할지를 생각.

### Track Happiness

- 리더로써 장기적으로 팀을 좀 더 생산적으로 만들 수 있는 한 가지 방법은,
- 구성원들의 행복을 측정하는 데 시간을 들이는 것.
- 함께 일했던 좋은 리더들은 모두 아마추어 심리학자들이었음.
- 종종 팀원들의 복지를 살피고,
- 자신들이 하는 일에 대해 인정 받고 있는지 확인하고,
- 일에 만족하는지도 확인하려 노력.
- 한 TLM은 해야하지만 맡기 싫어하는 일들이 잘 분배되도록 스프레드시트를 만들어 관리.
- 어떤 TLM은 팀이 일하는 시간을 지켜보며, 번아웃을 피하기 위해 보상 휴가나 가벼운 외출 등을 활용.
- 또 어떤 이는 1:1 세션을 마련해서, 지금 겪는 기술적 이슈를 얘기하는 것으로 가볍게 시작하여, 엔지니어들이 일을 잘 끝내기 위해 부족한 것은 없는지를 같이 이야기. 더불어, 일을 어떻게 즐기고 있는지, 향후엔 무엇을 기대하는 지를 대화.
- 팀의 행복을 측정하는 가장 쉬운 방법은 1:1 대화.
- "필요한 게 무엇인가요?"라는 간단한 질문이 좋은 질문이 될 수도.
- 하지만 필요에 따라 좀 더 세부사항을 조심스럽게 물어봐야 할 수도.

## The Unexpected Question

- 구글 입사 후 CEO 에릭 슈미트와의 만남 마지막에 받은 질문.
- "Is there anything you need?"
- 리더로써 오피스 바깥에서의 팀 행복에 대해서도 관심을 갖는 것은 가치 있는 일.
- 사생활을 캐라는 것이 아니라, 바깥에서의 일이 일의 생산성에도 영향을 주는 것을 이해하라는 것.
- 예컨대, 개인적으로 힘든 일을 겪고 있는 팀원에게는 좀 더 넉넉한 마감 기한을 줄 수도.
- 상식적이지 않은 수준의 시간을 오피스 내에 쏟길 바라는 것도 경계할 수 있음.
- 팀원의 행복을 추적하는 데 중요한 부분은 그들의 경력을 추적하는 것.
- (추적이라는 단어 말고 다른 번역 용어가 있으면 좋을 듯)
- 말로 표현되든 아니든, 보통은 5년 내에 하고 싶은 것들이 있을 것.
- 이를 위해 도울 수 있는 건 없을지 생각하고, 또 생각하고 있음을 알리는 것이 필요.
- 이런 암묵적이 목표들을 이끌어 내고 명시화하면, 경력 조언 시 지금의 상황이나 기회를 평가 할 지표가 될 수 있음.
- 경력 모니터링 외에도, 그들이 성장할 수 있게 하고, 인정 받게 하고, 약간의 재미를 얻게 하는 것도 필요.

## Other Tips and Tricks

- Delegate, but get your hands dirty
  - 직접 하는 것 보다 오래 걸리더라도 위임.
  - 팀이 배울 기회이며 당신이 제정신(?)을 유지하게 해 줌.
  - 팀의 존경을 얻고 다른 이들의 생산성을 올려주는 한 가지 방법은,
  - 아무도 하고 싶어하지 않는 일들을 직접 처리하는 것.
  - 아무리 화려한 이력이 있더라도 직접 하는 것이 역량과 헌신을 보여주는 유일한 방법.
- Seek to replace yourself
- Know when to make waves
- Shield your team from chaos
  - 처음 리더 역할을 맡았을 때 이전엔 없었던 혼란과 불확실들이 닥치기 시작.
  - 하지만 이는 원래부터 있던 회사의 일상적 일들.
  - 그 동안 이전 관리자가 보호해 주고 있던 것.
- Give your team air cover
  - 팀 외부의 불확실성과 경솔한 요구사항으로부터의 보호만큼이나,
  - 회사 내의 팀 바깥에서 일어나는 일들을 알려주는 것이 중요.
  - 가능한 많은 정보들을 공유.
  - 하지만 팀원들에게 실제로는 영향을 줄 가능성이 극도로 낮은 조직의 미침(?)들로 주의 분산 X.
- Let your team know when they're doing well
- It's easy to say "yes" to something that's easy to undo

## People Are Like Plants

- 저자의 부인은 서로 너무나 다른 6형제 중 막내.
- 장모님은 각각을 서로 다르게 대해 주었다고 함.
- 이는 식물 키우기와 비슷.
- 서로 다른 종류의 식물에 똑같은 햇빛과 물을 준다면 모두 죽게 될 지도.
- 팀원들도 마찬가지.
- 매너리즘에 빠질 수 있는 동료에겐 동기부여를,
- 뭘 해야할지 모르는 동료에겐 명확한 방향 제시를 해 주는 것이 좋음.
- 물론 지나친 수준으로 하는 것은 동료에게 괴로움.
- 방향 제시는 간단. 무엇을 해야 하는지에 대한 기본적 이해, 간단한 조직 기술, 관리 가능한 수준으로 작업 쪼개기 정도.
- 동기부여는 이보다 어려움.

### Intrinsic Versus Extrinsic Motivation

- 동기부여는 크게 2가지 종류.
- 금전적 보상과 같은 외재적<sup>extrinsic</sup> 동기.
- 내재적<sup>intrinsic</sup> 동기.
- 마이크로매니징 없이도 스스로 해결할 수 있는 역량을 가진 사람들은 자율성이 있음.
- 이런 동료들에겐 전반적인 방향만을 제공하고, 어떻게 달성할지에 대해선 맡기는 것이 좋음.
- 이런 사람들은 어쩌면 당신보다 제품을 더 잘 알아서 그렇기도 하지만, 제품에 대한 주인의식을 느끼게 해 주기도. 결국 동기부여에 도움.
- 제품의 성공에 대한 지분이 클수록 제품의 성공에 대한 관심도 커짐.
- 숙달을 위해 충분한 기회를 제공하면, 동기부여 뿐만 아니라 성장을 통해 더 나은 팀이 될 수 있음.
- 물론 목적 없이 일한다면, 자율과 숙달이 동기부여를 줄 수 없음.
- 팀원들의 일에 목적(why)을 설명하는 것이 중요한 이유.
- 생각보다 많은 이들이 큰 영향력을 가진 제품을 위해 일하고 있음.
- 그리고 그렇지 않더라도 그들의 노력의 이유를 찾고 알려줄 수 있음.

## Antipatterns

안티 패턴에 대해서는 간단히 기록.

### Antipattern: Hire Pushovers

- 자신의 위치/역할을 잃을 불안감에 자신보다 부족한 사람들을 뽑는 것.

### Antipattern: Ignore Low Performers

- "Hope is not a strategy"
- 저 성과자를 다룰 때 특히 이런 오용이 많이 일어남.
- 저 성과자는 고 성과자를 합류하지 못하게 할 뿐만 아니라,
- 기존의 고 성과자들을 떠나게 하기도 함.
- 결국엔 자유의지로 떠날 수 없는 사람들만 남아 저 성과자 팀이 됨.
- 가능한 빨리 조치를 취해야 함.
- 단지 약간의 격려나 지시만으로 더 높은 생산성을 발휘할 수도 있음.
- 이런 사람들에겐 일시적인 마이크로 매니징이 필요할 수도.
- 그리고 여전히 많은 겸손, 존중, 신뢰 그 중에서도 존중이 필요.
- 특정 기간과 그 기간 동안 그들이 달성하기를 원하는 매우 구체적인 목표를 설정.
- 목표는 작고 점진적으로, 그리고 측정 가능하도록 설정.
- 매 주 팀원을 만나 전진하고 있는지 확인.
- 매우 명시적인 기대를 설정해야 다음 마일스톤에서 성공과 실패를 판단하기 쉬움.
- 효과가 나타난다면 계속 향상을 위해 노력하고 그렇지 않으면 멈출 수 있어야 함.

### Antipattern: Ignore Human Issues

- 관리자는 팀의 사회적 + 기술적 영역 모두에 집중해야 함.
- 구글에선 관리자들이 기술적 부분에서 더 강점을 드러내는 게 일반적이며,
- 이들은 사람 이슈를 소홀히 하는 경향이 있음.

### Antipattern: Be Everyone's Friend

- 보통 자기가 팀원으로 속해 있던 곳에서 리더를 시작하곤 함.
- 그리고 그 동안 쌓아온 우정을 잃지 않고 싶어 함.
- 그래서 더 열심히 일하곤 함.
- 부드러운 터치와 함께 리딩하는 것과 우정을 혼동 X.
- 다른 사람의 경력에 대한 힘이 생기면, 우정의 제스처도 보답해야 하는 무언가로 느껴서 압박이 되기도.
- 가까운 친구 관계가 아니더라도 동의를 이끌어 내고 팀을 이끌 수 있음을 기억.
- 팀원들과 함께 하는 점심이 그들을 불편하게 하지 않으면서도 사회적으로 연결된 상태를 유지하게 도움.
- 업무적 환경에서 벗어나 비공식적 대화를 할 수 있는 기회.

### Antipattern: Compromise the Hiring Bar

- "A people hire other A people; B people hire C people."
- 구글 바깥에서 흔히 봤던 방법은 5명의 엔지니어를 뽑을 때 4-50명의 지원자를 받고 최고의 후보 5명을 선택하는 것.
- 하지만 이는 평범한 팀을 만드는 가장 빠른 방법 중 하나.
- 고용하지 말았어야 할 팀원을 계속 대하는 것에 비하면 적절한 사람을 찾는 데 들이는 비용은 적음.

### Antipattern: Treat Your Team Like Children

- 팀원들을 신뢰하지 않음을 보여주는 가장 좋은 방법은 팀원들을 아이처럼 대하는 것.
- 마이크로매니징, 존경 없이 그들을 대하기, 책임감을 가질 기회를 제공하지 않는 등이 그 예.
- 신뢰할 만한 사람을 고용해야 하고 또 신뢰를 보여줘야 함.

# 6. Leading at Scale

- 앞서 "개인 기여자"에서 "팀 리더"가 되어 가는 것에 대해 얘기.
- 이 역할이 커지더라도 모든 프랙틱스는 여전히 적용됨.
- 여전히 "섬기는 리더"이며, 단지 더 큰 그룹을 섬기는 것.
- 다만, 해결해야 하는 문제의 범위가 좀 더 커지고 좀 더 추상적이 됨.
- "깊게" 가는 대신 "넓게" 가게 됨.
- 세부적인 것들에 멀어지는 것을 애석해 할지도 모름.
- 이전의 엔지니어링 전문 지식이 점점 더 현재 일과 관련이 적어짐.
- 대신에 일반적인 기술적 직감과 엔지니어들이 올바른 방향으로 나아가게 하는 능력들이 중요해짐.
- 이런 상황에서 필요한 "the three Always of leadership"에 대해 이야기.
  - Always Be Deciding
  - Always Be Leaving
  - Always Be Scaling

## Always Be Deciding

- 팀들의 팀을 관리하는 것은 더 상위 수준의 결정을 더 많이 내리게 되는 것을 의미.
- 구체적인 엔지니어링 문제 해결 대신 상위 수준이 전략들을 다룸.
- 대부분의 결정들은 올바른 트레이드 오프 집합을 찾는 것.

### The Parable of the Airplane

- 리더로써 팀이 매주 해야 하는 일들을 결정해야 함.
- 이 때 고려해야 하는 트레이드 오프는 예측 가능하기도 하지만,
- 어떤 것들은 예측 불가한 결과를 가져오기도 함.
- 이와 관련하여 비행기 출발 지연 사례가 소개됨.
- 가장 최상위 수준에서, 리더의 역할은 사람들이 어렵고 모호한 문제들을 잘 해결해 나가도록 안내하는 것.
- 여기서 모호하다는 것은 명확한 해결책이 없거나 해결되지 않을 수도 있음을 의미.
- 그럼에도 불구하고, 문제는 탐색되어야 하고, 통제 가능한 상태가 되도록 애써야 함.
- 코드 작성이 나무를 베는 것이라면, 리더의 역할은 나무들을 통해 숲을 보는 것.
- 이 프로세스에는 세 가지 주요 단계가 있음.
  - 눈가리개<sup>blinder</sup>를 식별
  - 트레이드 오프 식별
  - 해결책을 결정하고 계속 반복

### Identify the Blinders

- 문제에 처음 접근해 보면, 이미 담당자들이 오랜시간 동안 그 문제와 씨름해 왔음을 발견.
- 하지만 이들은 문제에 너무 푹 빠져 있어 "눈가리개"를 하고 있는 것과 같음.
- 더 이상 숲을 보지 못한다는 것.
- 문제에 대한 많은 가정을 만들어 둠.
- 항상 해왔던 방식이라고 이야기,
- 현재 상태를 비판적으로 바라보는 능력을 상실.
- 때로는 현 상태를 정당화하기 위해 꾸준히 진화해 온 기이한 대응기제나 합리화들이 존재.
- 이 상황에서는 신선한 눈을 가진 것이 도움이 됨.
- 질문을 던지고 새로운 전략을 고려하게 할 수 있음.

### Identify the Key Trade-Offs

- 중요하고 모호한 문제들에는 "은총알" 해결책이 없음.
- 그 순간에 맞는 방법이 있을 뿐이고, 각 선택지에는 트레이드 오프가 존재.
- 당신의 역할은 트레이드 오프들을 이끌어내고, 모두에게 설명하고, 균형 잡힌 결정을 하도록 돕는 것.

### Decide, Then Iterate

- 트레이드 오프를 이끌어냈다면 이를 이용해 최선의 결정을 내리면 됨.
- 다만, 다음 달이 되면 다시 트레이드 오프를 평가하고 리밸런싱 해야 함.
- 이는 반복적 프로세스.
- Always Be Deciding이라고 제목 지은 이유.
- 만약, 지속적인 프로세스로 바라보지 않는다면,
- 완벽한 해결책을 찾으려는 함정에 빠지게 될 수도 있고,
- 이는 [분석 마비](https://en.wikipedia.org/wiki/Analysis_paralysis)<sup>analysis paralysis</sup>로 이어질 수 있음.
- 아래와 같은 설명을 통해 팀이 이런 반복에 익숙해지게 해야 함.

> 우리는 이 결정을 한 번 시도해 보고 어떻게 되어가는지 볼 것입니다. 다음 달에는, 이 변경을 다시 원복할 수도 있고, 다른 결정을 다시 내릴 수도 있어요."

## Always Be Leaving

- 얼핏 보기에 이상한 조언으로 들림.
- 왜 좋은 리더는 항상 떠날 준비가 되어 있어야 하나?
- 모호한 문제를 푸는 건 당신의 역할이 아님.
- 스스로 문제를 푸는 조직을 만드는 것이 해야 할 일.
- 이게 되면 당신은 새로운 문제나 조직으로 갈 수 있는 상태가 됨.
- 이에 대한 안티패턴은 당신이 SPOF가 되는 것.
- 책 앞 부분에서 버스 팩터 언급한 것도 같은 맥락.

### Your Mission: Build a "Self-Driving" Team

- 어려운 문제를 스스로 해결하는 조직을 만들어야 함.
- 이에는 3가지가 필요.
  - 문제 영역을 나누기.
  - 나눈 문제들을 위임.
  - 필요한 만큼 반복.

### Dividing the Problem Space

- 도전적인 문제들을 보통 어려운 하위 문제들로 이뤄져 있음.
- 팀들의 팀을 이끌고 있다면, 각 팀에 각 하위 문제들을 할당할 수 있음.
- 하지만 리스크가 있음. 하위 문제들이 계속 바뀐다는 것. 고정된 팀 경계는 이 사실을 알아차리거나 적응하기 어려움.
- 따라서 좀 더 느슨한 조직 구조를 고려. 하위 팀들은 크기를 조정할 수 있고, 하위 팀들 간에 개인 이동이 가능하며, 할당된 문제가 계속 바뀔 수 있는 구조.
- 물론 확고함과 느슨함 사이의 균형이 필요.
- 문제와 목적을 명확히 인식하고 꾸준히 성과를 내는 확고함.
- 그리고 변화하는 환경에 대응하여 새로운 것을 시도하고 방향을 바꿀 수 있는 자유로움.

#### Example: Subdividing the "latency problem" of Google Search

- 검색 지연 문제의 경우, 적어도 2가지 문제로 나눌 수 있었음.
- 하나는 지연의 증상을 다루는 것이고, 다른 하나는 지연의 원인을 다루는 것.
- 속도를 빠르게 하는 것에 많은 인력이 필요했지만 이것 만으로는 충분치 않았음.
- 여전히 많은 엔지니어들이 검색 결과의 복잡도와 품질을 높이면서 속도를 저하시키고 있었음.
- 따라서 우리는 지연을 예방하는 일도 함께 해결해야 했음.
- 이렇게 원인과 증상 모두에 팀을 할당함으로써 지연을 장기적 관점에서 통제할 수 있었음.

#### Delegating subproblems to leaders

- 위임은 배우기 어려움.
- 효율성과 성취에 대한 우리의 직관과 반대됨.
- 일을 제대로 끝내려면 직접하라는 속담도 있음.
- 만약 자기 주도적 조직을 만드는 게 목표라면, 위임은 효과적인 코칭 메커니즘.
- 자족적 리더들도 키워내는 데에도 위임이 절대적으로 효과적인 훈련 방법.
- 일을 맡기고, 실패하게 두며, 반복적으로 시도할 수 있게 해야 함.
- "failing fast and iterating"
- 엔지니어링 설계뿐만 아니라 인간의 배움에도 역시 적용됨.
- 쌓여 있는 수 많은 일들을 처리하기에 앞서 중요한 질문을 먼저 던지기.
- "Am I really the only one who can do this work?"
- 그리고 "What can I do that nobody else on my team can do?"를 질문.
- 조직 정책으로부터 팀을 보호하고, 동료에게 용기를 복돋아주고, 서로를 잘 대해주게 돕고, 겸손/신뢰/존중의 문화를 만드는 것들이 이에 해당.
- "manage up" 또한 중요. 조직이 무엇을 하는지 관리 체계에 이해시키고 회사와 연결된 상태를 유지시키는 것.
- 그 중에서 가장 흔하고 또 중요한 대답은 "I can see the forest through the trees".
- 전체적인 기술적 방향뿐만 아니라 조직 전략 또한 다루어야 함.
- 상위 수준의 전략을 정의하는 것.
- 지속적으로 숲과 대응시키고 각 구성원에게 나무 베는 일을 잘 나누기.

#### Adjusting and iterating

- 자립하는 기계를 만드는 지점에 다다랐고, 당신은 더 이상 SPOF가 아니다. 이제 뭘 해야 하나?
- 일단 대답에 앞서, "Always Be Leaving" 말대로 새로운 문제나 조직을 찾아서 떠날 수 있음.
- 이는 개인의 번아웃을 방지하는 훌륭한 방법 중 하나.
- 무엇을 해야 할지에 대한 간단한 대답은 아래와 같음.
- 자율적으로 움직이는 기계가 올바른 방향으로 가고 있는지 관찰하고,
- 반복적인 방향 지시를 하되 사려 깊고 최소한으로 이뤄져야 하며,
- 코스를 조정하기 위해 최소한의 조정만 행해야 함.
- 마이크로 매니지먼트로 회귀한다면 다시금 SPOF가 되는 것.

#### Take care in anchoring a team's identity

- 팀을 일반적인 문제가 아닌 특정 제품을 담당하게 하는 것은 흔히 일어나는 실수.
- 제품 = 어떤 문제의 한 가지 해결책
- 해결책의 기대 수명은 짧을 수 있음.
- 제품은 더 나은 해결책으로 대체될 수 있음.
- 예를 들어, "우리는 깃 리포지토리를 관리하는 팀이다"라며 팀에 특정 해결책을 맡김.
- 하지만 만약 대부분의 엔지니어가 새로운 버전 관리 시스템으로 교체하길 원한다면?
- 아마 팀은 조직 차원에서 최선이 아니라고 하더라도 기존의 방식을 고수하며 변화를 거부할지도.
- 해결책 자체가 팀의 정체성 일부이며 스스로의 가치라고 여기기 때문.
- 이렇게 하는 일반화 된 문제를 팀이 담당하게 해야 함.
- "우리는 회사에 버전 관리를 제공하는 팀이다"
- 시간이 지나면서 다른 해결책들도 실험할 수 있도록 해방시켜 주는 것.

## Always Be Scaling

- 리더로써 가장 중요한 자원은 제한된 시간 풀, 집중력, 에너지.
- 이들에 대한 보호 없는 공격적 스케일링은 실패하고 말 것.
- 어떻게 하면 효율적인 스케일링을 이룰 수 있을지에 대한 이야기.

### The Cycle of Success

- 팀이 어려운 문제와 맞붙었을 때 반복적으로 나타나는 싸이클이 있음.
- Analysis
  - 문제를 처음 받고 씨름하기 시작.
  - 눈가리개를 찾아내고, 트레이드 오프를 찾아냄.
  - 어떻게 할지에 대한 동의를 구함.
- Struggle
  - 작업을 시작.
  - 팀에서 아직 준비가 안 됐다고 생각하는지 여부와 관계 없이.
  - 실패와 재시도, 반복을 준비.
  - 주로 이뤄지는 작업은 의견을 한데 모으는 일.
  - 리더와 전문가들이 의견을 내고 주의 깊게 듣고 전체적인 전략을 강구하도록 격려.
- Traction
  - 당신의 팀이 마침내 상황을 이해함.
  - 당신은 좀 더 현명한 결정을 내림.
  - 진도도 실제로 나아가기 시작.
  - 당신은 트레이드 오프를 반복적으로 찾아내고 재평가.
  - 담당 조직은 스스로 문제를 주도하기 시작.
- Reward
  - 결과를 이뤄냄. 보상도 이뤄짐.
  - 하지만 보상은 더 많은 책임과 역할의 시작을 의미하기도.
- 이제 새로운 문제가 추가됨.
- 하지만 인력은 그대로.
- 절반의 인력은 원래의 문제를 계속 다루고,
- 나머지 인력은 새로운 문제와 부딪히기 시작.
- 이 마지막 단계를 일컬어 compression stage라고 부름.
- 지금까지 했던 일들의 크기를 절반으로 압축하는 것.
- 이런 식으로 성공의 싸이클은 나선형으로 확대되는 모습.
- 시간이 지날수록 새로운 문제들을 다루며 스케일링 하는 것.
- 물론 새로운 사람을 채용하면 좋지만 이는 보통 스케일링 속도를 따라가지 못함.
- 결국 압축 단계와 더불어 병행이 필요한 이유.

### Important Versus Urgent

- 리더가 아닌 엔지니어였을 때, 당신의 삶은 혼란보다는 평온함에 가까웠을 것.
- 하지만 리더로써 해야 하는 일들은 예측하기 어렵고 소방에 가까운 것들.
- 예방형<sup>proactive</sup>보다는 반응형<sup>reactive</sup>에 가까움.
- 수 많은 연락과 요청의 연속들.
- 긴 코드 블럭의 마지막 `finally` 절에 비유.
- 주의하지 않으면 반응형 모드로 100% 시간을 보내게 됨.
- 그리고 중요한 것과 급한 것의 구별 이야기.
- 리더로써 중요한 것은 숲을 관통하는 길을 매핑하는 것처럼, 리더만이 해 줄 수 있는 일들.
- 중요한 일에 대부분의 시간을 쏟는 방법으로 아래의 것들을 언급.
- Delegate
  - 긴급한 많은 일들은 당신 조직의 다른 리더에게 위임 가능한 것들.
  - 사소한 일이라면 죄책감을 느낄 수도 있고,
  - 다른 리더에게 주는 것이 더 오래 걸리기에 비효율이라 느낄 수도 있음.
  - 하지만 훈련의 좋은 방법이며 당신을 중요한 일을 하도록 보호해 줌.
- Schedule dedicated time
  - 2시간 이상을 주기적으로 잡고 조용히 앉아서,
  - 긴급치 않지만 중요한 것들에 시간을 보낼 것.
- Find a tracking system that works
  - GTD 같은 도구를 쓰라는 이야기.
  - 일을 계속 추적하고 우선순위를 조정하기 위함.

### Learn to Drop Balls

- 엔지니어일 때와 다르게 리더에겐 끊임없이 공(요청, 질문, ...)이 날라옴.
- 이 공들 중 일부를 떨어뜨리는 것을 필수불가결.
- 그렇다면 의도치 않게 떨어뜨리는 것보다는 의도적으로 떨어뜨리는 것이 좋지 않을까?
- 이를 위한 방법으로 마리아 콘도의 방식을 소개.
- 바닥의 20%는 중요하지도 않고 긴급하지도 않은 것으로, 무시하거나 지우기 쉬움.
- 중간의 60%는 약간의 긴급함이나 중요성을 가지긴 함.
- 상위 20%는 매우 중요한 것들.
- 상위 80%를 다 해결하려 애쓰지 말고,
- 상위 20%에 속하는 것들을 식별하고 이들에 집중.
- 처음에는 이것이 기분 안 좋게 느껴질 수도 있으나, 2가지 놀라운 사실을 발견하게 될 지도.
- 하나는, 60% 작업을 위임하지 않더라도, 서브 리더들이 이를 인지하고 알아서 가져간다는 것.
- 다른 하나는, 60%의 것 중 정말로 중요한 것이 있다면, 20%의 것으로 이동하여 결국엔 다시 돌아온다는 것.

### Protecting Your Engergy

- 시간과 집중 외에 에너지 또한 보호해야 하는 자원.
- 스케일링 시 어떻게 충전된 상태와 낙관을 유지할 수 있을까?
- 일단 한 가지 대답은 시간이 지남에 따라 나이가 들어감에 따라 전체적인 체력이 향상한다는 것.
- 또 한 가지 대답은 리더는 점점 에너지를 똑똑하게 관리하는 법을 배운다는 것.
- 이는 상황에 맞게 얼마나 많은 에너지를 쓸지 알고, 의도적으로 재충전 시간을 가질 줄도 앎을 의미.
- 아래는 에너지를 잘 관리하는 몇 가지 사례들.
- Take real vacation
  - 주말은 방학이 아님.
  - 최소 3일은 일에 대해 잊을 수 있어야 함.
- Make it trivial to disconnect
  - 쉴 때는 오피스에 일하는 랩탑을 두고 가기.
  - 핸드폰에 업무 커뮤니케이션이 있다면 제거.
- Take real weekends, too
  - 방학 만큼 효과적이진 않지만 여전히 활기를 되찾아주는 도구.
  - 이런 충전이 업무 커뮤니케이션으로부터 차단됐을 때 가능한 것도 다시 언급.
- Take breaks during the day
  - 일어나서 사무실 근처를 걸어다니기.
  - 작은 휴식은 작은 충전을 가져다주긴 하지만 큰 차이를 만들어 냄.
- Give yourself permission to take a mental health day
  - 정신적으로 힘든 날이 있을 수 있음.
  - 기분이 쳐져 있는 상태로 출근하는 것은 리더로써 주변에 안 좋은 영향.
  - 이럴 땐 집으로 가서 휴식.

# 7. Measuring Engineering Productivity

- 구글은 데이터 주도 회사.
- 대부분의 제품과 설계 결정들을 하드 데이터에 저장.
- 적절한 메트릭을 사용한 데이터 주도 의사 결정 문화는 물론 단점이 있긴 해도,
- 객관적 결정을 돕는다는 점에서 일반적으로는 좋은 도구.
- 하지만 인간 측면의 데이터를 모으고 분석하는 것에 어려움은 있음.
- 구글은 엔지니어의 생산성에 집중하는 전문가 팀을 갖는 것이,
- 조직을 키우고 인사이트를 활용하는 데 있어 매우 가치있고 중요함을 알게 됨.

## Why Should We Measure Engineering Productivity?

- 사업 확장을 위해 엔지니어 조직의 규모도 함께 키워야 한다고 생각하기 마련.
- 하지만 조직이 선형적으로 커질 때 커뮤니케이션 비용은 n^2으로 늘어남.
- 결국 사업의 규모는 조직의 규모가 커지는 속도를 따라잡지 못함.
- 확장 문제 해결의 또 한 가지 방법은 개인의 생산성을 높이는 것.
- 구글은 빠르게 성장해야 했고 이로 인해 엔지니어의 생산성을 높이는 방법을 알게 됨.
- 하지만 이런 방법들은 인적 자원의 소모를 동반했으며, 따라서 소프트웨어 엔지니어의 생산성을 높이는 일의 효율도 중요.
- 이 효율성 때문에 엔지니어 생산성을 전담하는 팀을 만들기도.

## Triage: Is It Even Worth Measuring?

- 생산성 측정하는 방법을 알기에 앞서, 언제 지표가 의미 있는지를 알아야 함.
- 측정은 비용이 큼. 사람이 프로세스를 측정해야 하고, 결과를 분석해야 하며, 회사에 전파해야 함.
- 또한 부담스럽기도 하고 조직을 느리게 만들 수 있음.
- 느리지 않다고 하더라도, 프로세스 트랙킹은 엔지니어의 행동을 바꿀 수도.
- 예컨대 잠재적 이슈를 숨기는 것.
- 똑똑하게 측정하고 추정해야 함.
- 생산성 측정이 가치가 있을지를 결정하기 위한 질문들을 제시하곤 함.
  - 어떤 결과를 기대하며, 왜 그런가?
  - 데이터가 당신의 예상 결과를 뒷받침 한다면, 어떤 조치를 취할 것인가?
  - 부정적 결과를 얻는다면 당신은 어떤 조치를 취할 것인가?
  - 결과가 나온다면 이 조치를 취할지는 누가 언제 결정하는가?
- 이 질문들을 통해 대부분은 측정이 의미 없음을 알게 됨.

## Selecting Meaningful Metrics with Goals and Signals

- 구글에선 Goals/Signals/Metrics (GSCM) 프레임워크를 메트릭 생성 가이드로 사용.
- goal: 원하는 최종 결과. 상위 수준에서 이해되길 기대하고, 측정 방법에 대한 언급이 포함되어 있으면 안 됨.
- signal: 목표를 달성했는지 알 수 있는 방법. 측정하고 싶지만, 측정이 어려움.
- metric: 시그널을 위한 프록시. 우리가 실제로 측정할 수 있는 것. 이상적인 측정은 아니겠지만 충분히 가까운 수준.

## Goals

- 원하는 속성에 관해 작성되어야 하고, 메트릭에 대한 어떠한 참조도 없어야 함.
- 좋은 목표는 시그널과 메트릭을 진행하기에 앞서 모두가 동의할 수 있는 것이어야 함.
- 그리고 이것이 제대로 동작하려면 가장 먼저 올바른 목표 집합을 식별해야 함.
- 간단해 보일지 모르지만 모든 트레이드 오프를 고려하지 못하고 빠뜨리기도 한다고.
- 가독성을 예로 들면, 프로세스가 얼마나 빠르고 쉬워야 하는지에 집중하느라, 코드 퀄리티 자체를 놓치기도.
- 가독성의 올바른 목표 집합은 아래 5가지로 잡았다고 함.
  - Quality of the code
  - Attention from engineers
  - Intellectual complexity
  - Tempo and velocity
  - Satisfaction

## Signals

- 시그널은 목표를 달성했는지를 알게 해 줌.
- 모든 시그널이 측정 가능하지는 않음.
- 하지만 이 단계에서는 괜찮음.
- 가독성을 예로 들며 각 목표에 대한 시그널 사례를 들고 있음.
- 썩 와닿지는 않음.

## Metrics

- 시그널을 위한 측정 가능한 프록시.
- 프록시이기 때문에 완벽한 측정 지표가 아닐 수도.
- 이를 보완하고자 시그널은 여러 메트릭을 갖기도 함.
- 예를 들어, 가독성 프로세스가 적용된 코드는 좀 더 빠른 리뷰 시간을 갖는지 측정하고자, 설문과 로그 데이터 모두를 활용.
- 이 두 가지 메트릭은 각각 불완전하지만, 이 둘이 서로 다른 결과를 보여준다면, 한 가지가 거짓이며 좀 더 탐구가 필요함을 알 수 있음.
- 일부 시그널들은 현재로써는 측정이 불가하여 메트릭을 가지지 못할 수 있음.
- 코드 품질의 경우 여러 학술들에서 제안하는 프록시들이 있지만, 어떤 것도 실제로 활용하긴 어려움.
- 이 경우 어떤 정량적 측정도 하지 않기로 결정. 엔지니어들에게 코드 품질에 대한 자체 평가를 요구하는 정도.

## Using Data to Validate Metrics

- 엔지니어의 빌드 시간을 측정하려고 자동화 된 도구를 넣어 두었는데,
- 실제로는 엔지니어가 시작하지 않은 빌드도 측정하고 있었고,
- 이를 발견 후 이런 빌드들은 측정에서 제외시켰다고 함.
- 정량적 메트릭이 매우 유용하긴 하지만, 문맥이나 내러티브를 제공하지는 못함.
- 질적 연구를 통해 프로세스를 개선하기 위한 인사이트를 얻어야 함.
- 가독성이 생산성에 미치는 영향을 평가할 때는, 3가지 메트릭을 혼합.
- 첫 번째는 가독성 프로세스가 끝난 직후에 이뤄진, 가독성에 특화된 설문. 이는 기억편향을 피했지만, 최신편향과 샘플편향을 수반.
- 두 번째는 분기 별로 이뤄진 가독성에 특화되지는 않은 대규모 설문(대신, 가독성이 영향을 주기를 기대했던 메트릭에 관한 것들).
- 마지막은 엔지니어들이 도구들을 사용할 때 측정되는 매우 세분화 된 로그 메트릭.

# 8. Style Guides and Rules

- 대부분의 엔지니어링 조직에서는 코드베이스를 관리하는 규칙을 가짐.
- 소스 파일의 저장소, 코드 포매팅, 네이밍, 패턴, 예외, 스레드, ...
- 규칙은 곧 법. 단지 제안이나 추천이 아닌, 강한 의무를 가진 법.
- 한편, 가이드는 추천과 베스트 프랙틱스의 제공.
- 가이드는 룰과 다르게 변이의 여지가 있음.
- 구글에서 스타일 가이드는 언어 마다 다양.
- Dart, R, Shell 같은 언어에서는 간결(네이밍과 포매팅 같은 주요 원칙 대해서만 집중).
- C++, Python, Java 같은 곳에서는 더 많은 디테일을 포함.
- 이런 스타일 가이드들은 코드베이스를 유지보수 가능한 상태로 유지하기 위한 목적들에서 하나씩 비롯됨.

## Why Have Rules?

- "좋은" 행동은 장려하고 "나쁜" 것은 억제하기 위함.
- 여기서 "좋은"과 "나쁜"은 조직이 무엇을 중요하게 여기느냐에 따라 달라짐.
- 조직의 가치를 먼저 생각해야 하는 이유임.
- 잘 정착된 규칙과 가이드는 코딩의 공통 어휘 모습을 갖춰나감.
- 이는 엔지니어로 하여금 그들이 말하고 싶은 것 대신 코드가 말해야 하는 것에 집중하게 도와줌.

## Creating the Rules

- "What rules should we have?"는 핵심 질문이 아님.
- "What goal are we trying to advance?"가 핵심.
- 목적에 초점을 두면 어떤 규칙이 유용한지 판별하기 쉬움.

### Guiding Principles

- 구글에는 3만명의 엔지니어들이 있음.
- 그만큼 다양한 기술과 배경들이 함께 존재.
- 각 조직에 맞게 가치를 다르게 산정하긴 하지만,
- 시간과 규모의 확장에도 엔지니어링 환경을 지속시키는 것이 공통된 목표.
- 이런 맥락에서 규칙의 목적은, 개발 환경의 복잡성을 다루고, 코드베이스를 관리 가능한 상태로 유지시키며, 개발자의 생산성을 보호하는 것.
- 여기서 트레이드 오프가 발생.
- 규칙이 많으면 선택의 제약이 많아짐.
- 하지만 충돌을 줄이고 일관성을 얻을 수 있음.
- 이런 것들을 고려할 때, 아래 5가지가 규칙 개발에 도움이 됨을 발견.
  - Pull their weight
  - Optimize for the reader
  - Be consistent
  - Avoid error-prone and surprising constructs
  - Concede to practicalities when necessary

#### Rules must pull their weight

- 스타일 가이드로 추가되는 모든 것에는 비용이 따름.
- 새로 배워야 하고 적응해야 하며 기억해야 함.
- 따라서, 자명한 것들은 규칙에서 제외시키려 노력.
- 예를 들어 C++의 `goto` 사용 금지를 규칙으로 삼지는 않음.
- 이미 개발자들은 이를 피하려는 경향이 있는데, 굳이 규칙으로 넣는 것은 오버헤드.
- 한 두명의 잘못으로 만드는 규칙은 전체의 정신적 부담으로 이어짐. 이는 스케일링에 걸림돌.

#### Optimize for the reader

- 규칙의 또 다른 원칙은 코드의 저자가 아닌 독자에 최적화하라는 것.
- 코드는 작성되는 시간보다 읽히는 시간이 더 김.
- 예를 들어, 파이썬에서 조건문<sup>conditional expression</sup>이 `if` 문장보다 짧음.
- 하지만 읽기에는 더 어려움. 따라서 조건문의 사용을 금하고 있음.
- 같은 맥락으로 엔지니어들은 각자의 코드에 의도한 행위의 증거를 명시적으로 남겨야 함.
- 예컨대, Java, JavaScript, C++ 스타일 가이드에서는 슈퍼클래스 메서드를 오버라이드 할 때 override 애노테이션이나 키워드를 사용하도록 강제.
- API에는 상호작용을 충분히 추론할 수 있는 명확한 도큐먼트를 남김.
- 사용하려는 함수의 구현을 보지 않고도 알 수 있게 하는 것이 목적.
- 도큐먼트 주석(파일, 클래스, 함수 블럭 앞에 작성하는)는 코드의 설계나 의도를 담음.
- 구현 주석은 불명확한 선택을 강조하거나 정당화하고, 까다로운 부분을 설명하며, 코드의 중요한 부분을 드러냄.

#### Be consistent

- 구글에서는 어느 회의실에서도 화상 회의 설정은 동일한 인터페이스를 가짐.
- 새로운 설정을 배우느라 시간을 낭비하지 않아도 됨.
- 이는 소스 코드에 대해서도 마찬가지.
- 일관성은 어느 엔지니어든지 코드베이스의 익숙하지 않은 부분에 뛰어들게 하고 빠르게 일할 수 있게 도움.
- 각 프로젝트는 고유한 성격을 갖지만, 도구와 기술과 라이브러리는 모두 동일.

#### Advantages of consistency

- 일관성으로 인한 제약은 분명히 발생. 하지만 편익은 큼.
- 코드를 다룰 때도 일관성이 자유를 제한하는 것 같지만, 더 적은 노력으로 더 많은 일을 할 수 있게 도와줌.
- 일단, 코드를 작성하거나 읽을 때, 코드가 어떻게 표현되느냐보다 코드가 무엇을 하는지에 집중할 수 있음.
- 일관성은 스케일링을 돕기도 함. tooling이 조직 스케일링의 핵심인데, 일관성이 있으면 코드를 만들고 수정하고 이해하는 도구 작성이 쉬움.
- 엔지니어의 팀 간 이동에도 도움. 좀 더 빠르고 쉽게 코드에 적응.
- 시간이 흐름(엔지니어가 프로젝트를 떠나고, 새로운 사람이 들어오고, 오너십이 바뀌고, 프로젝트가 병합되거나 쪼개지고, ...)에도 탄력성을 유지.

#### Avoid error-prone and surprising constructs

- 구글 스타일 가이드는 언어에서 다소 놀랍거나 일반적이지 않거나 교모한 문법 사용을 제한함.
- 복잡한 피처는 종종 한 눈에 파악하기 어려운 함정을 가지고 있음.
- 이를 깊이 생각하지 않고 작성하는 것은 버그를 만들어 낼 수도.
- 작성 시에는 잘 고려가 되었더라도 이후에 이를 다루는 엔지니어에게도 문제.
- 파이썬 스타일 가이드의 경우 리플렉션 같은 [power features](https://google.github.io/styleguide/pyguide.html#219-power-features)를 금지.
- 파이썬에서의 `hasattr()`과 `getattr()`은 문자열로 객체의 속성에 접근할 수 있게 함.

```py
// some_file.py:
A_CONSTANT = [
'foo',
'bar',
'baz',
]

// other_file.py:
values = []
for field in some_file.A_CONSTANT:
values.append(getattr(my_object, field))
```

- `foo`, `bar`, `baz` 필드에 접근한다는 사실을 어떻게 알 수 있겠는가?
- 독자를 위한 어떠한 명확한 증거도 없음. 따라서 검증도 어려움.

#### Concede to practicalities

- 가끔 필요하다면 최적화나 실용성에 규칙을 포기하기도.
- C++ 스타일 가이드가 익셉션 사용을 금하고 있지만, 컴파일러 최적화를 위해 `noexcept`의 사용을 허용하기도.
- 성능 외에도 상호호환성 케이스도 존재.

### The Style Guides

- 언어 스타일 가이드에는 크게 3가지 범주가 있음.
- Rules to avoid dangers
- Rules to enforce best practices
- Rules to ensure consistency

#### Avoiding danger

- 스타일 가이드에는 언어 특징에 관련하여 기술적 이유로 해야 하는 것과 하지 말아야 할 것을 명시.
- 정적 멤버나 변수 사용, 람다 표현식 사용, 예외 처리, 스레딩 생성, 접근 제어, 클래스 상속 등.
- 사용하기 어렵거나 제대로 사용하기 어려운 것에 대한 규칙들도 포함.
- 각각의 규칙에는 장단점과 함께 결론에 이르기까지의 설명도 포함.

#### Enforcing best practices

- 소스 코드 작성의 베스트 프랙틱스들도 담고 있음.
- 이는 코드 베이스를 건강하고 유지보수 가능하게 도와줌.
- 예컨대, 코드 저자가 주석을 어디에 어떻게 남겨야 하는지를 가이드.
- 일반적인 주석 컨벤션을 기본으로 하고, 이를 좀 더 확장하여 의도가 불분명할 수 있는 곳에도 주석을 작성해야 함.
- switch 문이 완료되지 못하는 경우, 빈 예외 캐치 블럭, 템플릿 메타프로그래밍 등이 이에 해당.
- 그 외에도 소스 파일을 구조화하는 방법, 네이밍, 가독성을 위한 포맷팅 등 다양.
- 새롭거나 아직 잘 이해되어지지 않은 언어 피처는 제한을 둠.
- 만약 엔지니어가 이를 사용하고 싶다면 스타일 가이드 소유자에게 예시와 함께 토론하며 포함시킬 수도.

#### Building in consistency

- 사소한 것들도 스타일 가이드에 많이 포함되어 있음.
- 이들은 기술적으로 큰 영향을 가지는 것들이 아님.
- 네이밍 컨벤션, 들여쓰기 스페이싱, 임포트 순서 등.
- 무엇을 선택하든 다른 선택에 비해 큰 이점을 가지는 것도 아님.
- 하지만 하나를 선택함으로써 끝없는 논쟁 순환을 줄이고 앞으로 나아갈 수 있음.

## Changing the Rules

- 시간이 지나면서 스타일 가이드를 결정했던 배경 등이 계속 바뀜. 언어의 버전도 계속 올라감.
- 규칙이 다른 모습으로 바뀔 때가 되었는지를 알아차리는 것이 스타일 가이드를 계속 최신화해 나가는 중요한 프로세스의 일부.
- 주어진 결정의 추론을 문서화 해 두는 것은 무언가 바뀌어야 할 때를 인지하는 데 큰 도움이 됨.
- 과거의 좋은 결정이 지금은 그렇지 않을 수 있음.
- 그 외 내용은 기록 생략.

## Guidance

- 규칙<sup>rule</sup>에 더해 프로그래밍 안내<sup>guidance</sup>도 다양한 형태로 제공.
- 엔지니어링 경험의 지혜 모음이며, 그 동안 배운 교훈으로부터 추출한 베스트 프랙틱스를 문서화한 것.
- 규칙은 "must"이고 안내는 "should".
- 지침 풀의 한 예시는 자주 사용하는 랭기지들의 지침서.
- 스타일 가이드는 규범적이고 무엇을 해야 하고 하지 말아야 하는지를 강제하는 반면,
- 이 지침서는 피처들을 안내하고 설명함.
- 한 사례로, 새로운 코드베이스에서 사용해야 하는 언어에 익숙하지 않다면 "<Language>@Google 101" 코스 등을 밟는다고 함.

## Applying the Rules

- 규칙은 잘 시행되기만 하면 큰 가치를 가져다 줌.
- 규칙은 사회적으로(교육과 훈련을 통한) 또는 기술적으로(도구를 통한) 시행될 수 있음.
- 구글에선 규칙이 필요로 하는 베스트 프랙틱스들을 훈련시킬 여러 공식적 코스들이 존재.
- 또한 문서들을 정확하고 최신 상태로 유지할 수 있는 리소스를 꾸준히 투자.
- 코드 리뷰가 가이드나 규칙 학습에 중요한 역할을 수행.
- 물론 도구에 의한 자동 검증도 매우 중요.
- 자동화 된 도구는 또한 규칙이 해석되고 적용되는 방식의 편차를 최소화 시켜줌.
- 그리고 스케일링에도 도움.
- 하지만 모든 것을 도구로 해결할 수는 없음.
- 일부 기술적 규칙들은 확실히 살마의 판단을 필요로 함.
- 어떤 규칙들은 기술적이라기보다 사회적.
- 잘 정의하기 어렵고 도구로 해결하기에는 복잡하며 비싸질 수 있는 것들.
- 예를 들어, 한 번에 변경이 일어나는 크기를 작게 유지하는 것이 있음.
- 크기가 작으면 리뷰하기 쉽고 빠르며 더 통찰력 있께 살펴볼 수 있음.
- 버그를 만들어 낼 가능성도 적어짐.
- 하지만 작은 것의 명확한 정의는 어려움.
- 한 줄의 변경이 때로는 수백 줄의 변경보다 더 어려울 수 있음.
- 이런 것들은 도구로 자동화 하는 대신 사회적 해결을 통해 극복.

### Error Checkers

- 랭귀지 용법을 다루는 많은 규칙들이 정적 분석 도구로 시행 가능.
- C++의 경우 대략 90%까지 자동 도구로 검증할 수 있었다고 함.
- 자동화된 검증은 코드 저자가 많은 규칙을 기억해야 하는 부담을 덜어줌.
- 규칙 준수의 비용을 낮게 유지하면 엔지니어들이 좀 더 행복하게 이를 따라갈 수 있음.

### Code Formatters

- 일반적으로 스타일 체커와 포매터를 이용해서 코드의 일관된 포매팅을 수행.
- 한 가지 흥미로운 건 라인 길이에 대한 질문이 멈췄다는 것.
- 엔지니어들은 단지 스타일 체커를 실행하고 다음 단계로 넘어감.
- 코드 리뷰도 더 적은 비용으로 이뤄짐.
- 가장 규모가 큰 코드베이스를 매니징할 때, 사람이 수행한 포매팅과 자동화 된 도구를 이용한 결과를 비교한 적이 있음.
- 평균적으로 로봇이 더 나은 결과를 보였음.
- 때로는 매트릭스 포매팅 같이 도메인 지식이 중요할 때가 있으며 이 때는 사람이 더 나은 결과를 보임.
- 구글에선 이런 포매팅을 제출 전 체크에서 수행한다고 함.

# 9. Code Review

- 코드 리뷰의 정의는 단순하나, 코드 리뷰 프로세스의 구현은 매우 다양.
- 구글에서는 모든 변경이 커밋 전 리뷰를 받아야 하며, 모든 엔지니어는 리뷰를 시작하고 변경을 리뷰해야 하는 책임이 있음.
- 코드 리뷰는 일반적으로 프로세스와 도구의 지원 모두 필요.
- 구글에서는 Critique라는 도구를 사용하긴 하나,
- 이 챕터에서는 특정 도구보다는 프로세스를 집중적으로 다룸.
- 버그를 탐지하는 등의 코드 리뷰 이점은 잘 정립되어 있고 명확함.
- 그러나 감지하기 힘든 다른 이점들(심리적 효과를 비롯한)도 존재.

## Code Review Flow

- 코드 리뷰는 소프트웨어 개발의 많은 단계에서 일어남.
- 구글에서는 커밋 전에 변경을 리뷰하며, 이를 precommit review라고 부름.
- 코드 리뷰의 최종 목적은 다른 엔지니어에게 변경에 대한 동의를 얻는 것.
- 동의를 표현할 때 "looks good to me"(LGTM) 라고 태깅.
- 구글에서의 코드 리뷰는 아래의 단계로 이뤄짐.
  1. 저자가 코드베이스에 변경을 작성하고 리뷰 도구를 활용해 리뷰를 시작.
  2. 그리고 저자가 먼저 셀프 리뷰를 하거나 자동화 된 리뷰 코멘트를 확인. 저자가 만족했다면 1명 이상의 리뷰어에게 변경사항을 메일로 보냄.
  3. 리뷰어는 도구를 활용해 변경을 확인하고 코멘트를 남김. 일부 코멘트는 명시적인 해결을 요구. 어떤 것은 단지 정보 전달.
  4. 저자는 피드백을 반영하여 변경을 수정하고 다시 스냅샷을 업로드. 그리고 리뷰어에게 답장. 3~4단계는 계속 반복될 수 있음.
  5. 리뷰어가 만족한다면 LGTM과 함께 변경을 수락. 기본적으로는 1개의 LGTM만 받아도 통과.
  6. 변경이 LGTM으로 표기되면 저자는 변경을 코드베이스로 커밋.

## How Code Review Works at Google

- 코드리뷰의 대략적인 프로세스를 알아보았음.
- 하지만 디테일이 중요.
- 구글에서는 변경에 대해 "승인"을 필요로 하는 리뷰의 3가지 측면이 있음.
- 먼저, 정확성과 표현력에 대한 검사.
  - 코드가 적절한지, 저자가 주장한 동작을 하는지.
  - 종종 팀 멤버가 진행하지만 꼭 그래야 하는 것은 아님.
  - 승인 시 LGTM 권한 "비트"에 반영됨.
- 다음으로, 코드 소유자로부터의 적절성 여부 검사.
  - 구글에서는 코드베이스가 계층을 가진 트리 구조로 되어 있고,
  - 각 부분마다 소유자가 있음.
  - 보통 테크 리드나 특정 영역의 전문가.
  - 소유 권한을 얼마나 넓게 또는 얇게 가져가는지는 팀 마다 다름.
- 마지막은 언어의 "가독성"을 검사.
  - 스타일 가이드나 베스트 프랙틱스를 잘 따르고 있는지 확인.
- 이런 통제 레벨이 부담스럽게 여겨질 수도 있고 때로는 정말 그러기도 함.
- 그러나 보통은 한 사람이 이 3가지 역할을 수행하여 속도를 높임.
- 그리고 저자가 마지막 2개의 역할을 수행하기도.
- 보통은 2가지 단계를 거침. 동료 엔지니어로부터 1개의 LGTM을 얻고, 코드 소유자나 가독성 리뷰어에게 승인을 얻는 것.
- 이렇게 하면 코드리뷰를 2가지 관점에서 살펴볼 수 있게 하면서도 시간을 절약해 줌.

## Code Review Benefits

- 구글에서 코드 리뷰는 아무리 작은 변경이라고 하더라도 필수.
- 코드리뷰가 코드 변경의 속도를 늦추기도 하지만 그래도 필수.
- 장기적으로 더 큰 이점을 가져다 준다고 생각하기 때문.
- 아래의 6가지.
  - Checks code correctness
  - Ensures the code change is comprehensible to other engineers
  - Enforces consistency across the codebase
  - Psychologically promotes team ownership
  - Enables knowledge sharing
  - Provides a historical record of the code review itself

### Code Correctness

- 다른 내용은 일반적인 것들이었고 아래 내용이 기억에 남음.
- 정확성 평가가 주관적이 되는 것을 막기 위해, 저자의 접근 방식을 존중해야 함.
- 리뷰어는 개인적 의견 때문에 대안을 제시할 수 없음.
- 대안은 표현력(덜 복잡하게 하는 등)나 기능성(더 효율적이게 하는 등)을 향상시킬 수 있는 경우에만 제시.
- 일반적으로 엔지니어들은 완벽한 해결책에 대한 동의를 기다리기보다, 코드베이스를 향상시키는 변경에 대해 승인하도록 권장됨.
- 이는 코드 리뷰의 속도를 높임.

### Comprehension of Code

- 코드리뷰는 일반적으로 저자가 아닌 다른 사람이 변경을 검사하는 첫 번째 기회.
- 뛰어난 엔지니어라도 저자의 관점에 치우치느라 발견하지 못한 것을 리뷰어가 피드백 해 줄 수 있음.
- 코드리뷰는 변경이 더 많은 청중들에게 이해가능한지를 검사하는 첫 번째 테스트.
- 이는 코드가 작성보다 읽히는 데 더 많이 사용되기 때문에 매우 중요.
- 따라서 저자와는 다른 관점을 지닌 리뷰어를 찾는 게 도움이 됨.
- 리뷰어가 설계와 관련하여 저자에 대해 존중을 가져야 하는 것과 별개로,
- 저자는 "고객은 항상 옳다"는 마인드로 코드 표현력에 관한 리뷰어의 질문을 바라보아야 함.
- 지금 받은 질문들은 시간이 지나면서 다른 사람들에 의해서도 계속 반복될 것.
- 접근법이나 로직을 바꾸라는 것이 아님. 하지만 좀 더 명확하게 설명할 필요는 있음.
- 코드 정확성과 함께 코드 표현력은 LGTM의 주요 요소.

### Code Consistency

- 규모가 확장 됨에 따라 당신이 작성한 코드는 의존성을 가지며 유지보수도 이뤄짐.
- 많은 사람들이 당신의 코드를 읽고 이해해야 함.
- 따라서 코드는 일관성 표준을 따라야 하고, 과도하게 복잡한 것도 피해야 함.
- 리뷰어들은 이 코드가 코드베이스의 표준에 따라 얼마나 잘 살아갈 수 있는지(코드의 건강) 평가해야 함.
- 정확성과 표현력을 나타내는 LGTM과 별개로 코드 가독성은 유지보수를 위한 것.
- 특정 프로그래밍 언어를 위한 베스트 프랙틱스를 잘 따랐는지, 구글 코드 리포지토리의 언어들과 일관성을 갖췄는지 등을 평가.

### Psychological and Cultural Benefits

- 코드리뷰는 중요한 문화적 이점도 가짐.
- 신입 때 느꼈던 코드리뷰의 가장 큰 이점.
- 소프트웨어 엔지니어들에게 코드가 "그들의 것"이 아님을 인지하게 함.
- 자신의 결과물을 자랑스럽게 여기고 비판을 꺼리는 것은 인간의 본성.
- 코드리뷰는 이런 비판의 감정적 완충 작용을 하기도.
- 좀 더 정제되고 중립적인 비판을 주고 받도록 돕기 때문.
- 코드리뷰의 또 다른 심리적 이점은 "validation".
- 자신에게 너무 비판적인 경우 이 validation은 안정감을 제공.
- 마지막으로 코드리뷰를 시작하기 전 한 번 더 변경에 대해 신경쓰게 됨.
- 나중으로 미룰 수도 있었던 단위 테스트를 마무리 하고 코드리뷰를 올리는 등.

# 16. Version Control and Branch Management

- VCS는 필수라고 생각.
- 하지만 VCS 전략은 각 상황을 고려하여 선택해야.
- 여러가지 전략과 각각의 장단점을 소개할 예정.
- 그 중에서도 "trunk-based development"가 경험적으로 확장 가능했다고 언급.
- one repository, no dev branches의 의미.

## What is Version Control?

- 시간의 흐름에 따른 파일의 변경(버전)을 추적.
- 이런 파일들의 집합과 메타데이터를 리포지토리라고 부르며 VCS의 관리 대상.
- 여러 개발자가 동시에 작업할 수 있게 해줌.
- 파일을 한 번에 한 사람만 수정할 수 있게 하는 방식으로 이를 지원.
- 이전의 변경이 의도치 않게 덮어 쓰여지는 것을 방지하는 것.

### Why Is Version Control Important?

- 버저닝과 이를 활용한 취소.
- 여러 개발자들 간 또는 여러 시점 간 협업이 가능.
- 커밋은 부수적으로 행위의 변화를 가져오기도 함.
- 커밋 로그를 남기며 변경에 설명을 더하고, 커밋에 앞서 정적 분석이나 체크리스트를 확인하는 등의 행위를 유발시킴.
- VCS를 설치하고 설정하는 등의 단점도 있지만 상대적으로 매우 값싼 비용.

### Centralized VCS Versus Distributed VCS

생략

## Branch Management

- 대비되는 단어는 단일 "trunk"

### Work in Progress Is Akin to a Branch

- 진행 중인 작업은 모두 브랜치에 대응.
- 중앙집중형 VCS에서도 마찬가지.
- 커밋되지 않은 로컬 변경과 브랜치에 커밋된 것은 개념적으로 크게 다르지 않음.

### Dev Branches

- 지속적 단위 테스트가 없던 시절, 변경은 시스템에 대한 regression 위험을 가졌음.
- 이 때는 trunk를 특별한 것으로 간주하는 것이 이치에 맞았음.
- "우리 팀은 피처 개발 브랜치를 사용하고, 트렁크에 커밋하지 않는다"
- "새로운 변경이 모든 검증을 끝내고 난 뒤에야 트렁크로"
- 이것이 제품의 불안정성을 해결하기 위한 적절한 방법이기도 하지만,
- CI나 철저한 코드 리뷰 등의 품질 관리 노력이 더 나은 해결책이라고 주장.
- (이 품질 관리 노력이 어느 정도 수준인지가 중요할 듯. 좋은 해결책이 되기 어려운 수준일 수도)
- 광범위한 개발 브랜치의 사용이 제품 안정성을 위한 수단이 되는 것은 본질적으로 잘못된 것.
- 동일한 커밋들이 결국 트렁크에 병합됨.
- 작은 병합이 더 쉬움.
- 엔지니어는 자신이 작성한 변경을 병합하는 것이 쉬움.
- 관련 없는 변경들의 병합, 그리고 나중에 병합하는 것은 어려움.
- 병합에 대한 회귀 테스트의 실패 책임자가 누구인지 찾는 것도 쉬움.
- 대규모 병합은 문제의 격리를 더 어렵게 함.
- 수정은 더더욱 어려움.
- 규모 확장에도 심각한 위험.
- 병합 자체도 더욱 어려워지고 오래 걸리기 때문.

#### HOW DID WE BECOME ADDICTED TO DEV BRANCHES?

- 오래된 개발 브랜치를 병합하는 것은 안정성을 낮춘다고 판단.
- 그래서 브랜치 병합은 위험하다고 결론.
- 브랜치 기반 개발 전략을 버리고 테스팅으로 문제를 해결하지는 않음.
- 대신, 속도를 낮추고 증상을 조율하는 데 시간을 보냄.
- 조직이 커지면서 브랜치는 늘어나고, 브랜치 병합 전략을 조율하는 데 더 많은 노력이 들어감.
- 일부 개발자는 빌드 마스터/머지 코디네이터/컨텐츠 관리 엔지니어가 됨.
- 대규모 병합이 되면 다른 개발 중인 브랜치들은 이를 또한 반영해야 하며 다시 테스트 해야 함.
- 이런 병합과 반복 테스트는 pure overhead.
- 패러다임의 전환이 필요.
- CI와 테스팅에 크게 의존하며, 빌드를 항상 그린으로 유지하고, 런타임에는 불완전하고/테스트되지 않은 피처는 비활성화 하는, 트렁크 기반의 개발을 권장.
- 하나의 Source of Truth만 있어야 함.
- 릴리즈를 위한 하나의 리비전만 있게 됨.
- 이는 1장에서 소개했던 "shift left"(이제서야 나오는 구나) 접근법.

### Release Branches

- 릴리즈 간격이 몇 시간 보다 길다면 릴리즈 브랜치를 만드는 게 합리적일 수도.
- 그리고 만약 릴리즈 사이에 큰 결함이 발견되면 트렁크에서 릴리즈 브랜치로 수정 사항을 cherry-pick.
- 개발 브랜치와 비교하면 릴리즈 브랜치는 일반적으로 무해함.
- 개발 브랜치와 릴리즈 브랜치의 주요 차이는 종료 상태.
- 릴리즈 브랜치는 결국엔 제거됨(abandoned).
- 하지만 개발 브랜치는 계속 트렁크로 병합되고, 다른 팀에 의해 추가적으로 분기되기도.
- 높은 수준의 조직에서는 릴리즈 브랜치가 거의 없다고 함.
- 지속적 배포(하루에도 여러 번 릴리즈)를 달성하는 곳은 릴리즈 브랜치를 생략하는 경향.
- 단순하게 수정을 반영하고 재배포 하는 것이 더 쉬움.
- cherry-pick과 브랜치는 불필요한 오버헤드.
- 물론, 고객에게 명시적인 릴리즈 결과물을 제공하는 곳에서는, 고객에게 정확히 무엇이 전달되었는지가 중요하기에, 이 방식의 적용은 어려울 수도.
- 복잡한 브랜치와 머지 전략은 생산성의 장애물.
- 트렁크를 안정된 상태로 유지하는 다른 방법들이 있음.

## Version Control at Google

- 구글에선 50,000명의 엔지니어가 공유하는 하나의 리포지토리를 사용(monorepo).
- 구글에서 진행하는 대부분의 프로젝트가 여기에 모여 있음. 오픈소스만 제외.
- Gmail 등의 공개 제품 외에 제품 개발을 지원하는 데 필요한 내부 인프라까지도 포함.
- Piper라고 불리는 중앙화된 인하우스 VCS를 사용.
- 하루에 보통 60,000 ~ 70,000개의 커밋이 일어남.
- 트렁크에 새로운 클라이언트를 생성하고, 파일을 추가하고, 리뷰되지 않은 변경을 커밋하는 것은 15초 정도 소요.
- 참고로, Piper는 사내에서 만들어 졌기에 커스터마이징도 쉬움.
- 리포지토리 하위 트리의 커밋들을 승인할 수 있는 엔지니어 이름이 적힌 OWNERS라는 파일들이 있음.
- 이를 활용해서 Piper가 소유/승인이 좀 더 잘 이뤄질 수 있게 하고 있음.

### One Version

- Piper 도구가 강력하긴 하지만, 그것만으로는 지금과 같은 협업은 어려움.
- "One Version"이라고 불리는 버전 컨트롤 '정책'이 필요.
- 이 정책은 "Single Source of Truth" 개념의 확장이며 아래와 같음.

> Developers must never have a choice of "What version of this component should I depend upon?

- 개인에겐 이런 선택의 제한이 장애물로 보일 수도.
- 그러나 조직 차원에서 이는 효율적인 스케일링의 매우 중요한 요소.

### (Nearly) No Long-Lived Branches

- One Version Rule에는 좀 더 깊은 생각과 정책들이 내포되어 있음.
- 그 중 가장 중요한 것은 아래와 같음.

> development branches should be minimal, or at best be very short lived

- Phoenix Project의 "reducing work-in-progress" 교훈은 개발 브랜치에 적용한 것.
- 트렁크에 작은 증분만이 이뤄져야 하고, 정기적으로 커밋 되어야 함.
- 그리고 준비 되기 전까지는 런타임에 비활성화 되어야 함.
- 더불어, 가능하다면 가시성을 통해 다른 개발자에게 숨겨져야.
- 혹은 두 의존성이 하나의 프로그램 내에서 공존할 수 있도록 설계되어야(패키지/클래스 명 등의 충돌이 없어야 한다는 의미로 들림).
- 구글에서는 1,000개 팀에서 이런 개발 브랜치를 가진 곳은 2군데.
- 흔한 일이 아니며 매우 특수한 이유를 가짐.

### What About Release Branches?

- 많은 구글팀에서 릴리즈 브랜치를 사용(제한된 체리 픽과 함께).
- 월간 릴리즈를 준비를 하면서 다음 릴리즈를 작업하는 경우에 이상적.
- 체리 픽을 최소화하고, 트렁크와의 재병합 계획은 금지.
- 아마도 여기서의 릴리즈 브랜치는, 트렁크에서 릴리즈 브랜치를 따고 그 릴리즈 브랜치로 배포가 나가는 형태인 것으로 보임.

## Monorepos

- One Version 유지를 쉽게 만들어 줌.
- 어떤 버전이 오피셜인지 결정하는 프로세스도 없고,
- 어떤 리포지토리를 봐야 하는지 고민할 필요도 없음.
- 빌드 도구 입장에서도 리포지토리를 고르는 절차 없음.
- 이런 일관성은 새로운 도구나 최적화 도입 등의 스케일링을 쉽게 도와줌.
- 엔지니어들의 코드나 시스템 디자인 결정을 공유하기도 쉬움.
- 다만, monorepo 방식이 결국엔 One Version을 위한 수단.
- 이 목적을 달성하기 쉽다면 다른 수단들도 충분한 대안이 될 수 있음.
