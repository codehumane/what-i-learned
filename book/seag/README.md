# Software Engineering at Google

# Thesis

# 1. What is Software Engineering?

프로그래밍과 소프트웨어 엔지니어링의 3가지 중요한 차이.

1. 시간
   - 수명이 길어질수록 변경이 많음.
   - 비즈니스, OS, 하드웨어, 언어 버전 등.
   - 이에 대응할 수 있는 것이 중요해짐.
   - 수명이 짧은 코드는 단지 프로그래밍 문제에 가까움.
2. 스케일
   - 프로그래밍 작업은 보통 개인의 작업.
   - 소프트웨어 엔지니어링은 팀의 노력.
   - 팀 협업은 개인 프로그래밍에 없던 여러 가지 새로운 문제를 안겨줌.
   - 하지만 혼자할 때에 비해, 좋은 시스템을 만들 가능성이 큼.
   - 제품, 조직, 개발 워크플로우의 규모가 커짐에 따른 비용을 잘 유지하고 관리해야 함.
3. 트레이드 오프
   - 종종 부정확한 가치 메트릭을 기반으로,
   - 상위 수준의 이해관계 결과물을 고려하며,
   - 여러 길 사이의 트레이드 오프를 고려한 복잡한 결정을 내려야 함.

## Time and Change

- 모바일 앱이나 스타트업의 코드 수명은 비교적 짧음.
- 하지만 구글 검색이나 Apache HTTP 프로젝트의 수명은 예측할 수 없음.
- 내부적으로는 indefinitely로 간주한다고 함. 
- 이런 수명이 긴 프로젝트에서는 업그레이드 문제가 중요.
- 이런 업그레이드를 고려하지 않다가 한 번에 업그레이드 하려는 경우 그 비용은 상당.
- 이 비용을 겪고 나면 후속 업그레이드도 크다고 느껴, 코드를 재작성하거나 아예 업그레이드 자체를 피하기도.
- 하지만 첫 번째 큰 업그레이드 이후에도 지속적으로 나아가는 것이 프로젝트의 장기 유지가능성의 핵심.
- 물론, 업그레이드가 제공하는 가치와 비용, 그리고 프로젝트의 기대 수명을 같이 고려해야.

### Hyrum's Law

다른 엔지니어들에게 사용되는 프로젝트를 맡고 있다면, Hyrum's Law가 "it works"와 "it is maintainable"의 차이에 대한 중요한 교훈이 됨.

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.

### Why Not Just Aim for "Nothing Changes"?

- 새로운 기능을 지속적으로 제공해야 하고
- 보안 취약점이 새로 발견되고
- 버그도 계속 발견됨
- CPU 등의 변경에 따라 최적화도 계속 달라짐
- 수명이 긴 프로젝트라면 변경을 피하기 어려움

## Scale and Efficiency

- 조직과 개발/운영 프로세스 역시 유지 가능해야 한다는 이야기.
- 조직이 커질 때, 그 조직의 반복 작업을 돕는 컴퓨팅 리소스도 함께 스케일링 되어야 함.
- 그렇지 않으면 작업 시간은 점점 늘어나고, 이는 작업을 미루게 되는 배경이 되기도.
- 지속 가능성을 위한 노력의 예시로는 아래와 같은 것들이 있음.
    - 조직 규모에 맞게 테스트 클러스터도 함께 확장 되어야 함.
    - 전체 빌드에 걸리는 시간, 리포지토리를 pull 받는 데 걸리는 시간도 커지지 않도록.
    - 새로운 버전의 랭귀지로 업그레이드 하는 데 걸리는 시간들도 마찬가지.
- 이런 문제들은 서서히 자라나며 잘 인식하지 못할 수 있음.
- [bolied frog](https://en.wikipedia.org/wiki/Boiling_frog#As_metaphor)를) 언급하며 이런 특징을 가진 문제들의 위험성을 강조.

### Policies That Don't Scale

- 조직이 커지거나 코드 베이스가 커질 때 일의 양도 같이 늘어난다면 not scale.
- 그 일의 자동화나 최적화를 하는 메커니즘이 적절한 곳에 있어야 함.
- 일반적인 deprecation 접근법을 스케일 문제의 예로 들고 있음.
- 새로운 위젯을 만들었다고 가정.
- 그리고 기존 것의 사용을 중단하고 새로운 것의 사용을 강제.
- 작은 소프트웨어에서는 이것이 가능할 수도.
- 그러나 의존성 그래프가 깊고 넓은 경우엔 실패하기 쉬움.
- 회사의 성장 속도를 저해하는 요인이 되기도.
- 대신, 하위 호환성을 유지하는 방식을 권장.
- 의존 프로젝트들은 더 이상 따라잡기 위한 급진적 노력을 기울이지 않아도 됨.

### Policies That Scale Well

- 한 가지 사례는 인프라스트럭처 팀의 안전한 변경을 보호하는 정책.

> If a product experiences outages or other problems as a result of infrastructure changes, but the issue wasn't surfaced by tests in out CI system, it is not the fault of the infrastructure change.

- 공통 CI 시스템에서 실행되지 않는 맞춤형의 복잡한 테스트는 신경쓰지 않는다는 것.
- 그렇지 않으면 인프라 팀은 영향 받는 모든 팀의 코드를 추적하고 테스트는 어떻게 했는지 일일이 물어봐야 함.
- 100명의 엔지니어가 있을 때는 이것이 가능했으나 규모가 커진 지금은 불가능.
- 대신, 공유된 커뮤니케이션 포럼과 전문 지식이 조직의 규모 확장에 도움.
- 엔지니어들이 공유 포럼에서 토론하고 질문에 응답하면서 지식이 전파되고 전문가들이 생겨남.

### Shifting Left

- 개발 단계의 앞 쪽에서 버그나 보안 이슈를 발견하고 대응할 수록,
- 더 적은 비용을 감수한다는 일반적인 이야기가 갑자기 나옴.
- 일반적으로 보던 개발 단계가 뒤로 갈수록 비용이 지수적으로 늘어나는 그래프도 소개.

## Trade-offs and Costs

- 프로그램을 작성, 소프트웨어의 생명주기, 엔지니어 규모 확장 시에도 소프트웨어를 유지하는 것을 이해했다면, 남은 것은 올바른 결정 내리기.
- 구글 내에서는 "내가 그렇게 말했기 때문"에 대한 강한 혐오감이 있음.
- 모든 것에는 이유가 있어야.
- 그리고 어느 주제든 결정자가 있어야 함.
- 잘못된 것 같아 보이는 결정에 대해서는 이의 제기.
- 다만 목표는 만장일치가 아니라 합의.
- 이런 의사 결정시에는 여러 비용을 고려해야 하는데,
- 재정적, 리소스 측면 등과 같은 것 뿐만 아니라 사회적 비용이나 구성원들의 만족감 같은 비용도 포함.

### Example: Markers

- 구글을 데이터 중심 문화라고 불러주지만 너무 단순화 된 얘기.
- 데이터가 없는 경우에는 증거, 선례, 논쟁으로 결정.
- 모든 가능한 선택지를 두고 트레이드 오프를 고려하며 현명한 결정을 내리려 노력.
- 때때로 직감이나 베스트 프랙틱스에 기반한 결정이 이뤄지기도 하지만, 근본적이고 실제적인 비용을 측정하거나 추정하는 모든 방식을 다 사용한 이후에나 가능.

### Inputs to Decision Making

- CPU와 네트워크 간 트레이드 오프 측정과 같이,
- 결정을 내리기 위한 데이터가 측정할 수 있거나 적어도 추정이 가능한 것들이 있음.
- 한편, 측정하기 어렵거나 측정 방법조차 모를 때도.
- 잘 설계 되지 못한 API가 가져오는 비용 측정이 그 예.
- 후자의 것도 측정하기 위한 노력을 하긴 하지만, 측정이나 예측하기 어렵다는 것도 인정하면서, 우선순위를 낮추지 않고 계속 다루려 노력해야 함.

### Example: Distributed Builds

- 로컬 빌드가 오래 걸려서 점점 문제가 됐음.
- 빌드를 최대한 빠르게 하는 방법을 고민하기 시작.
- 고성능 개발 장비는 대부분 유휴 상태이기 때문에 좋은 선택은 아니라고 판단.
- 구글은 자신들만의 분산 빌드 시스템을 만들었음.
- 물론, 이를 만드는 비용도 발생했고, 개발자들의 습관/워크플로우을 바꾸는 데에도 많은 시간이 걸림. 컴퓨팅 리소스는 당연.
- 하지만 전체적으로 아낄 수 있는 시간이 컸음.
- 그래서 헤피 엔딩이냐. 꼭 그런 것만은 아님.
- 로컬에서는 커지지 않게 신경 쓰던 의존성이 마구 늘어남.
- 실행 환경이 빠르기 때문에 신경 쓰지 않아도 문제가 되지 않았던 것.
- Jevons 역설.

### Example: Deciding Between Time and Scale

- 문제 해결을 위해 라이브러리 등의 의존성을 추가할 수도 있음.
- 또는 좀 더 요구에 들어맞도록 이를 포크/재개발을 할 수도 있음.
- 맞춤형은 새로운 기능을 추가하기도 쉽고, 최적화에도 유리. 의존성의 변경으로부터 자유롭기도.
- 하지만 모든 것을 직접하게 되면, 확장성과 더불어 지속가능성이 떨어짐.
- 보안 이슈를 단지 의존성 업데이트 만으로 해결할 수 없는 것이 그 예.
