# Software Engineering at Google

# Thesis

# 1. What is Software Engineering?

프로그래밍과 소프트웨어 엔지니어링의 3가지 중요한 차이.

1. 시간
   - 수명이 길어질수록 변경이 많음.
   - 비즈니스, OS, 하드웨어, 언어 버전 등.
   - 이에 대응할 수 있는 것이 중요해짐.
   - 수명이 짧은 코드는 단지 프로그래밍 문제에 가까움.
2. 스케일
   - 프로그래밍 작업은 보통 개인의 작업.
   - 소프트웨어 엔지니어링은 팀의 노력.
   - 팀 협업은 개인 프로그래밍에 없던 여러 가지 새로운 문제를 안겨줌.
   - 하지만 혼자할 때에 비해, 좋은 시스템을 만들 가능성이 큼.
   - 제품, 조직, 개발 워크플로우의 규모가 커짐에 따른 비용을 잘 유지하고 관리해야 함.
3. 트레이드 오프
   - 종종 부정확한 가치 메트릭을 기반으로,
   - 상위 수준의 이해관계 결과물을 고려하며,
   - 여러 길 사이의 트레이드 오프를 고려한 복잡한 결정을 내려야 함.

## Time and Change

- 모바일 앱이나 스타트업의 코드 수명은 비교적 짧음.
- 하지만 구글 검색이나 Apache HTTP 프로젝트의 수명은 예측할 수 없음.
- 내부적으로는 indefinitely로 간주한다고 함. 
- 이런 수명이 긴 프로젝트에서는 업그레이드 문제가 중요.
- 이런 업그레이드를 고려하지 않다가 한 번에 업그레이드 하려는 경우 그 비용은 상당.
- 이 비용을 겪고 나면 후속 업그레이드도 크다고 느껴, 코드를 재작성하거나 아예 업그레이드 자체를 피하기도.
- 하지만 첫 번째 큰 업그레이드 이후에도 지속적으로 나아가는 것이 프로젝트의 장기 유지가능성의 핵심.
- 물론, 업그레이드가 제공하는 가치와 비용, 그리고 프로젝트의 기대 수명을 같이 고려해야.

### Hyrum's Law

다른 엔지니어들에게 사용되는 프로젝트를 맡고 있다면, Hyrum's Law가 "it works"와 "it is maintainable"의 차이에 대한 중요한 교훈이 됨.

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.

### Why Not Just Aim for "Nothing Changes"?

- 새로운 기능을 지속적으로 제공해야 하고
- 보안 취약점이 새로 발견되고
- 버그도 계속 발견됨
- CPU 등의 변경에 따라 최적화도 계속 달라짐
- 수명이 긴 프로젝트라면 변경을 피하기 어려움

## Scale and Efficiency

- 조직과 개발/운영 프로세스 역시 유지 가능해야 한다는 이야기.
- 조직이 커질 때, 그 조직의 반복 작업을 돕는 컴퓨팅 리소스도 함께 스케일링 되어야 함.
- 그렇지 않으면 작업 시간은 점점 늘어나고, 이는 작업을 미루게 되는 배경이 되기도.
- 지속 가능성을 위한 노력의 예시로는 아래와 같은 것들이 있음.
    - 조직 규모에 맞게 테스트 클러스터도 함께 확장 되어야 함.
    - 전체 빌드에 걸리는 시간, 리포지토리를 pull 받는 데 걸리는 시간도 커지지 않도록.
    - 새로운 버전의 랭귀지로 업그레이드 하는 데 걸리는 시간들도 마찬가지.
- 이런 문제들은 서서히 자라나며 잘 인식하지 못할 수 있음.
- [bolied frog](https://en.wikipedia.org/wiki/Boiling_frog#As_metaphor)를) 언급하며 이런 특징을 가진 문제들의 위험성을 강조.

### Policies That Don't Scale

- 조직이 커지거나 코드 베이스가 커질 때 일의 양도 같이 늘어난다면 not scale.
- 그 일의 자동화나 최적화를 하는 메커니즘이 적절한 곳에 있어야 함.
- 일반적인 deprecation 접근법을 스케일 문제의 예로 들고 있음.
- 새로운 위젯을 만들었다고 가정.
- 그리고 기존 것의 사용을 중단하고 새로운 것의 사용을 강제.
- 작은 소프트웨어에서는 이것이 가능할 수도.
- 그러나 의존성 그래프가 깊고 넓은 경우엔 실패하기 쉬움.
- 회사의 성장 속도를 저해하는 요인이 되기도.
- 대신, 하위 호환성을 유지하는 방식을 권장.
- 의존 프로젝트들은 더 이상 따라잡기 위한 급진적 노력을 기울이지 않아도 됨.

### Policies That Scale Well

- 한 가지 사례는 인프라스트럭처 팀의 안전한 변경을 보호하는 정책.

> If a product experiences outages or other problems as a result of infrastructure changes, but the issue wasn't surfaced by tests in out CI system, it is not the fault of the infrastructure change.

- 공통 CI 시스템에서 실행되지 않는 맞춤형의 복잡한 테스트는 신경쓰지 않는다는 것.
- 그렇지 않으면 인프라 팀은 영향 받는 모든 팀의 코드를 추적하고 테스트는 어떻게 했는지 일일이 물어봐야 함.
- 100명의 엔지니어가 있을 때는 이것이 가능했으나 규모가 커진 지금은 불가능.
- 대신, 공유된 커뮤니케이션 포럼과 전문 지식이 조직의 규모 확장에 도움.
- 엔지니어들이 공유 포럼에서 토론하고 질문에 응답하면서 지식이 전파되고 전문가들이 생겨남.

### Shifting Left

- 개발 단계의 앞 쪽에서 버그나 보안 이슈를 발견하고 대응할 수록,
- 더 적은 비용을 감수한다는 일반적인 이야기가 갑자기 나옴.
- 일반적으로 보던 개발 단계가 뒤로 갈수록 비용이 지수적으로 늘어나는 그래프도 소개.

## Trade-offs and Costs

- 프로그램을 작성, 소프트웨어의 생명주기, 엔지니어 규모 확장 시에도 소프트웨어를 유지하는 것을 이해했다면, 남은 것은 올바른 결정 내리기.
- 구글 내에서는 "내가 그렇게 말했기 때문"에 대한 강한 혐오감이 있음.
- 모든 것에는 이유가 있어야.
- 그리고 어느 주제든 결정자가 있어야 함.
- 잘못된 것 같아 보이는 결정에 대해서는 이의 제기.
- 다만 목표는 만장일치가 아니라 합의.
- 이런 의사 결정시에는 여러 비용을 고려해야 하는데,
- 재정적, 리소스 측면 등과 같은 것 뿐만 아니라 사회적 비용이나 구성원들의 만족감 같은 비용도 포함.

### Example: Markers

- 구글을 데이터 중심 문화라고 불러주지만 너무 단순화 된 얘기.
- 데이터가 없는 경우에는 증거, 선례, 논쟁으로 결정.
- 모든 가능한 선택지를 두고 트레이드 오프를 고려하며 현명한 결정을 내리려 노력.
- 때때로 직감이나 베스트 프랙틱스에 기반한 결정이 이뤄지기도 하지만, 근본적이고 실제적인 비용을 측정하거나 추정하는 모든 방식을 다 사용한 이후에나 가능.

### Inputs to Decision Making

- CPU와 네트워크 간 트레이드 오프 측정과 같이,
- 결정을 내리기 위한 데이터가 측정할 수 있거나 적어도 추정이 가능한 것들이 있음.
- 한편, 측정하기 어렵거나 측정 방법조차 모를 때도.
- 잘 설계 되지 못한 API가 가져오는 비용 측정이 그 예.
- 후자의 것도 측정하기 위한 노력을 하긴 하지만, 측정이나 예측하기 어렵다는 것도 인정하면서, 우선순위를 낮추지 않고 계속 다루려 노력해야 함.

### Example: Distributed Builds

- 로컬 빌드가 오래 걸려서 점점 문제가 됐음.
- 빌드를 최대한 빠르게 하는 방법을 고민하기 시작.
- 고성능 개발 장비는 대부분 유휴 상태이기 때문에 좋은 선택은 아니라고 판단.
- 구글은 자신들만의 분산 빌드 시스템을 만들었음.
- 물론, 이를 만드는 비용도 발생했고, 개발자들의 습관/워크플로우을 바꾸는 데에도 많은 시간이 걸림. 컴퓨팅 리소스는 당연.
- 하지만 전체적으로 아낄 수 있는 시간이 컸음.
- 그래서 헤피 엔딩이냐. 꼭 그런 것만은 아님.
- 로컬에서는 커지지 않게 신경 쓰던 의존성이 마구 늘어남.
- 실행 환경이 빠르기 때문에 신경 쓰지 않아도 문제가 되지 않았던 것.
- Jevons 역설.

### Example: Deciding Between Time and Scale

- 문제 해결을 위해 라이브러리 등의 의존성을 추가할 수도 있음.
- 또는 좀 더 요구에 들어맞도록 이를 포크/재개발을 할 수도 있음.
- 맞춤형은 새로운 기능을 추가하기도 쉽고, 최적화에도 유리. 의존성의 변경으로부터 자유롭기도.
- 하지만 모든 것을 직접하게 되면, 확장성과 더불어 지속가능성이 떨어짐.
- 보안 이슈를 단지 의존성 업데이트 만으로 해결할 수 없는 것이 그 예.

# 2. How to Work Well on Teams

- 구글 소프트웨어 엔지니어링의 문화적, 사회적 측면을 다루는 부분.
- 통제 가능한 변수인 우리 자신에 초점을 맞추는 것으로 시작.
- 소프트웨어 개발은 팀의 노력.
- 엔지니어링 팀의 성공을 위해 겸손, 존중, 신뢰 기반의 행동이 필요.

## Help Me Hide My Code

- 사람들은 자신이 작업 중인 것을, 다른 사람이 보고 판단하는 것을 두려워 하는 경향이 있다는 이야기.
- 이런 불안함은 더 큰 문제의 징후라는 얘기도 함.

## The Genius Myth

- 사람들은 우상을 찾고 숭배하려는 성향이 있음.
- 리누스 토발즈의 리눅스도 분명 그의 초기 작업이 훌륭하긴 했지만,
- 그 이후의 수 많은 똑똑한 사람들의 노력 없이는 불가능한 결과물.
- 그리고 많은 엔지니어들이 천재처럼 보이길 원한다고 함(하지만 대부분 천재는 아님).
- 이런 천재 신화는 위에서 말한 불안함의 또 다른 징후.
- 그래서 작업 중인 것을 공유하길 꺼려함.
- 천재 신화를 떠나, 단지 좋은 모습만을 보여주고자 하는 마음에, 이런 경향은 더 만연하다고 생각 됨.

## Hiding Considered Harmful

- 만약 모든 시간을 혼자 일하는 데 쓰고 있다면,
- 불필요한 실패의 위험을 키우고 성장의 기회를 날리는 것.
- 물론, 소프트웨어 개발이 깊은 집중력과 개인 시간을 어느 정도 필요로 하는 지적 작업이긴 하지만,
- 협업과 리뷰 역시 매우 중요한 요소.
- 무엇보다도 당신이 올바른 길을 가고 있는지를 어떻게 알 수 있겠는가?

### Early Detection

- 뭔가 완성되기 전까지 공개하는 것을 꺼리는 건 도박.
- 초반일수록 실수하기 쉬움.
- 제대로 하고 있는지를 다른 사람에게 피드백 받으며 반복 확인하고 수정해야 함.
- 처음이 갖는 리스크를 줄이는 일.
- "Fail early, fail fast, fail often"

### The Bus Factor

> the number of people that need to get hit by a bus before your project is completely doomed.

- 프로젝트의 지식과 노하우가 프로젝트에 얼마나 잘 분산되어 있는가?
- 만약, 당신이 프로토타입 코드가 동작하는 원리를 이해하는 유일한 사람이라면,
- 당신이 버스에 치이게 되었을 때 프로젝트는 위험.
- 두 명이서 같이 만들고 있다면 버스 팩터는 2배가 됨.
- 여러 명으로 된 팀으로 일한다면 더 나아짐.
- 영역 별로 2명 이상의 소유자를 갖는 것 외에도 좋은 문서를 두는 것이 프로젝트의 성공을 도움.

### Pace of Progress

- 컴파일하고 일할 때를 생각해보자.
- 한 번에 10,000 라인의 코드를 작성하고 컴파일 버튼을 누르는가?
- 결과는 재앙일 것.
- 프로그래머의 작업은 빽빽한 피드백 루프가 함께 할 때 제일 좋음.
- get feedback as early as possible, test as early as possible, and think about security and production environments as early as possible.
- 모두 "shifting left" 아이디어.
- 이는 코드 레벨 뿐만아니라 전체 프로젝트 레벨에서 필요한 이야기.
- 잘 되는 프로젝트는 빠르게 진화하며 시간이 지남에 따라 바뀌는 환경에 적응해야 함.
- 예상치 못한 설계 장애물이나 정치적 위험을 마주치거나, 단지 계획한 것이 제대로 되지 않기도.
- 요구사항은 계속 변경.
- 이렇게 계획이나 설계가 바로 바로 바뀌어야 한다는 피드백 루프를 어떻게 구성할 수 있을까?
- 답은 팀으로 일하는 것.
- "Many eyes make sure your project stays relevant and on track"

## It's All About the Team

> software engineering is a team endeavor

- 숨어서 비밀 발명품을 준비하는 것으로 세상을 바꾸는 것이 아님.
- 다른 사람들과 함께 일해야 함.
- 비전을 공유하고, 일을 나누고, 서로를 배우며, 훌륭한 팀을 만들어야 함.
- 혼자 만든 소프트웨어 중에 널리 사용되며 성공한 것은 없음.

### The Three Pillars of Social Interaction

- 협업을 잘하기 위해 "세가지 기둥<sup>three pillars</sup>"이라 부르는 사회적 기술을 익히라고 이야기.
- Pillar 1: Humility
  - 당신은 우주의 중심이 아님.
  - 당연히 코드의 중심도 아님.
  - 절대적으로 옳은 사람도 아니고 박식하지도 X.
  - 자기 발전에 열려 있어야.
- Pillar 2: Respect
  - 진심으로 같이 일하는 동료를 대해야 함.
  - 친절하게 대하고 그들의 능력과 성과에 감사해야 함.
- Pillar 3: Trust
  - 다른 사람이 뛰어나며 올바른 일을 할 것임을 믿어야 함.
  - 그리고 적절한 때에는 그들이 드라이빙 하도록 해 주어야.

### Why Do These Pillars Matter?

- 사회적 측면이 갖는 힘이 생각보다 큼.
- 일이 되게 하기 위해 관계를 맺는 것에 관함.
- 관계는 프로젝트보다 오래 지속됨.

### Humility, Respect, and Trust in Practice

- 구체적인 행동과 예시들을 다룸.
- 이 내용들을 보면 당연해 보일지도 모르나, 잘 안지켜지는 부분들일 것.

#### LOSE THE EGO

- 자신이 가장 중요한 인물이라고 생각하는 사람과는 같이 일하고 싶지 않음.
- 모든 이야기의 시작이나 끝맺음 말을 하고 싶어 한다거나,
- 모든 제안이나 토론의 세부 사항에 코멘트를 달아야 한다고 느끼는 등이 그 예.
- 물론 겸손이 중요하다고 해도 동네 북이 되라는 것은 아님.
- 자신감은 중요. 단지 다 아는 척 하려고 하지 말아야.
- 대신 "집단적" 에고를 가져야 함.
- 개인이 멋지게 보이는 것보다 팀의 성취.
- 에고는 여러 방식으로 그리고 여러 번 드러남.
- 이는 생산성을 방해하고 속도를 늦춤.

#### LEARN TO GIVE AND TAKE CRITICISM

- 개인적 비난이 아닌 프로젝트가 더 나아지게 하는 건설적 비판을 강조.
- 여기서 가장 중요한 건 존중. 상대방이나 그들의 작업이 개선되길 원하는 마음으로 진정성 있는 비판이 되어야.
- 한편, 비판을 잘 받아들일 수도 있어야 함.
- 이는 기술적 역량에 대해 겸손해 하는 것은 물론,
- 다른 사람이 당신의 이익을 중요시 여기며 당신을 바보로 생각하지 않는다고 믿는 것을 의미.
- 이를 위해 코드와 당신을 너무 동일시 여기지 않는 노력도 필요.
- "you are not your code"

#### FAIL FAST AND ITERATE

> if you're not failing now and then, you're not being innovative enough or taking enough risks.

#### Blameless Post-Mortem Culture

- 실수로부터 배우는 주요한 방법으로,
- 근본 원인<sup>root-cause</sup> 분석을 통해 실패를 문서화하고,
- 포스트모텀을 작성하는 것을 제시.
- 여기에는 무엇을 배웠고 그 결과로 어떤 행동의 변화를 취할지를 기술.
- 그리고 포스트모텀을 누구나 볼 수 있어야 하고,
- 제안된 변경이 이후에도 제대로 수행하는지 확인할 수 있어야 함.
- 다른 사람들도 이를 보고 문제를 반복하지 않을 수 있음.
- 좋은 포스트모텀은 아래의 7가지를 포함.
  1. 사건의 간단 설명
  2. 이벤트 타임라인(문제의 발견부터 해결까지)
  3. 이벤트의 근본 원인
  4. 영향/손실 측정
  5. 문제를 당장 고치기 위한 액션 아이템
  6. 문제 재발을 막기 위한 액션 아이템
  7. 배운 교훈

#### LEARN PATIENCE

- CSV가 가진 이상한 버그를 수정하고자,
- CSV에 바삭하며 오랜 동료인 Karl과 함께 작업을 시작.
- 하지만 저자는 bottom-up 방식이고 이것 저것 빠르게 시도해 보는 타입.
- 반면 동료는 top-down 엔지니어이고 전체를 살핀 뒤 세부로 들어가는 타입.
- 이로 인해 서로 많이 부딪히게 됨.
- 하지만 인내심을 가지고(?) 다른 협업 방식을 찾아냄.
- 같이 컴퓨터 앞에 앉아서 버그를 먼저 찾고, 문제를 쪼갠 뒤, 각자의 방식으로 서로 반대 방향으로 접근한 뒤, 서로 발견한 내용을 모음.

#### BE OPEN TO INFLUENCE

- 다른 사람들의 영향에 더 열려 있을 수록 당신의 영향력이 높아지고,
- 당신이 좀 더 취약할수록 더 강해질 수 있음.
- 주변에 고집 센 동료들을 생각해보면, 그들을 설득하려 할수록 자신의 길을 더 고수하고, 결국엔 사람들이 그들의 의견을 듣지 않고 장애물처럼 여기며 돌아가게 됨.
- 환경도 변하지 않고 지식도 완벽하지 않는 한, 모든 것에 당신이 올바르긴 어려움.
- 새로운 증거들이 보이면 마음을 바꿀 수 있어야.
- 결정을 확고히 내리기에 앞서 경청해야 하고, 제대로 전달하려면 제대로 들어야 함. 전투에는 신중할 것.
- 취약함을 드러내면 오히려 신뢰할 수 없는 사람이 될 걱정은 X.
- 이는 겸손, 책임을 지려는 의지, 다른 사람의 의견을 신뢰한다는 신호를 드러내는 한 가지 방식.
- 때로는 "모른다"고 말하는 게 최고.

### Being Googley

- 모호한 "Googley" 정의는 채용 인터뷰 등에서 문제가 됨.
- 그래서 아래와 같이 정의를 내렸다고 함.
- Thrives in ambiguity
  - 끊임없이 변화하는 환경 속에서도,
  - 방향이나 메시지의 충돌을 다루고,
  - 동의를 이끌어 내며,
  - 문제를 해결해 나갈 수 있음.
- Values feedback
  - 겸손하게 피드백을 주고 받을 수 있고,
  - 피드백이 개인과 팀의 발전에 얼마나 가치있는지를 이해.
- Challenges status quo
  - 도전적인 목표를 설정하고,
  - 다른 사람들의 저항이나 관습에도 그들을 설득할 수 있는 것.
- Puts the user first
  - 제품 사용자에 대한 존경과 공감을 갖고,
  - 사용자에게 가장 이익이 되는 행동을 추구.
- Cares about the team
  - 동료들에 대한 존경과 공감을 갖고,
  - 그들이 요청하는 것을 적극 돕고,
  - 팀의 응집력을 높임.
- Does the right thing
  - 자신이 하는 것에 윤리의식을 갖기.
  - 팀과 제품의 도덕성을 보호하기 위해 어렵거나 불편한 결정도 내리기.

# 5. How to Lead a Team

- 리더 없이는 어떤 팀도 제대로 동작 X.
- 특히 구글처럼 엔지니어링이 팀 노력인 곳에서는 더더욱.
- 구글에서는 리더십이 2가지.
- 관리자는 사람들의 리더, 테크 리드는 기술적 노력을 이끔.
- 선장이 없는 배는 목적 없이 표류하게 됨.
- 엔지니어 팀을 조종하는 사람이 없다면, 소중한 시간들을 날리게 되고, 그저 무슨 일이 일어나기를 기다릴 뿐(혹은 더 나쁜 상황은 필요하지도 않을 코드를 작성하는 것).

## Managers and Tech Leads (and Both)

- 엔지니어 팀마다 서로 다른 리더를 필요로 함.
- 초창기 팀에서는 TLM(Tech Lead Manager)가 두 가지 역할을 모두 수행.
- 좀 더 큰 팀에서는 경험 많은 인력 관리자가 관리 역할을 맡고,
- 경험이 풍부한 시니어 엔지니어는 테크 리드 역할을 수행.
- 두 역할 모두 팀의 성장과 생산성의 중요한 부분이지만,
- 이 둘에 필요로 하는 역량은 꽤나 다름.

### The Engineering Manager

- 구글에선 관리자가 엔지니어링 백그라운드를 가져야 한다고.
- 엔지니어링 관리자는 성능, 생산성, 팀원들의 행복감에 책임을 가짐.
- 이와 동시에 제품이 비즈니스 요구 사항을 충족하는지를 확인.
- 비즈니스의 요구와 개별 팀원들의 요구가 항상 일치하는 건 아님.
- 이는 종종 관리자를 어렵게 만드는 요인.

### The Tech Lead

- 제품의 기술적 측면을 책임짐.
- 기술적 의사결정, 아키텍처, 우선순위, 속도, 일반적인 관리들이 여기에 해당.
- TL은 엔지니어링 관리자와 협력하여, 팀 인력이 제품을 위해 적절히 배치 되었는지, 팀이 스킬 셋/수준에 부합하는 일을 맡고 있는지 등을 확인.
- TL은 본인이 직접 빠르게 일을 처리하거나 조금 느리더라도 팀원에게 위임하는 것 사이를 왔다 갔다 함.
- 보통은 후자가 팀의 규모나 역량을 키운다는 점에서 더 적합한 선택.

### The Tech Lead Manager

- 작은 팀 또는 초기 팀은 TLM을 두는 것을 기본으로 함.
- 사람과 기술 요구를 모두 다루는 역할.
- 좀 더 규모가 크고 잘 정립된 팀에서는 TL과 엔지니어링 관리자를 각각 두는데,
- 이는 번아웃 되지 않고서는 두 가지 일을 모두 잘 하기 어렵기 때문.
- 그래서 둘로 나누고 각자의 역할에 집중하게 함.
- TLM은 까다로운 직업이며 개인의 일과 위임, 그리고 인력 관리 사이의 균형을 잡을 수 있어야 함.

## Moving from an Individual Contributor Role to a Leadership Role

- 공식적이든 아니든 누군가는 운전자석에 앉아야 함.
- 만약, 당신이 동기부여 되어 있고 참을성 부족한 유형이라면 당신이 그 자리에 앉아 있을 것.
- 팀의 충돌 해결을 돕고 의사결정을 내리며 사람들을 조직화하고 있는 자신을 발견.
- 리더가 절대로 되지 않기로 다짐했더라도 어떻게든 이런 일은 일어남.
- 이런 고통을 "관리염"이라 부르는 사람도 있음.
- 이런 일이 일어났을 때 어떻게 하는 것이 좋을지를 다루는 부분.

### The Only Thing to Fear Is...Well, Everything

- 대부분의 사람들이 관리자가 되고 싶지 않아 하는 이유는 여러가지.
- 가장 큰 이유는 주로 코드 작성에 시간을 보냈기 때문.
- 코드를 작성할 때는 하루가 지나면 코드든 설계 문서든 한 줌의 버그든 결과물이 보임.
- 하지만 관리를 할 때는 하루가 지나도 특별한 것을 했다는 생각이 안 듦.
- 코드를 작성하는 것은 매일 매일 사과를 따는 것과 유사.
- 반면 관리를 하는 것은 바나나를 키우는 것에 가까움.
- 몇 개의 위젯을 만들어 냈느냐가 아닌, 팀이 행복감을 느끼고 생산성 있게 만들고 있느냐가 중요.
- 바나나를 키울 땐 몇 개의 사과를 땄는지 세지 말 것.
- 관리자가 되지 않으려는 또 다른 이유는 "[피터의 법칙](https://ko.wikipedia.org/wiki/피터의_법칙)".
- 구글에선 이를 방지하고자 승진을 앞두고 있는 직원이 지금보다 높은 수준의 일을 일정 기간 동안 수행하게 함.
- 대부분의 사람들이 역량 부족한 관리자 밑에서 일해본 경험이 있음.
- 이런 부정적 인식이 관리자가 되지 않으려는 경향을 만든다는 이야기인 듯.
- 하지만 TL 또는 관리자가 되길 고려해 볼 만한 중요한 이유들이 있음.
- 코드 작성에 뛰어나다고 하더라도 여전히 당신이 만들어 낼 수 있는 상한선은 있음.
- 대신, 당신의 리더십과 함께 팀이 얼마나 훌륭한 많은 코드를 만들어 낼 수 있는지 상상해 볼 것.
- 다음으로, 당신은 리더십에 재능이 있을 수도 있음.

### Servant Leadership

- 관리자에게 찾아오는 일종의 병이 있음.
- 그들의 관리자가 했던 안 좋은 일들을 잊어버리고 어느샌가 따라 하고 있는 것.
- 마이크로매니징, 저성과자 무시, 밀린 채용 등.
- 저자가 처음 관리자가 됐을 때 들었던 이야기는 "무엇보다, 관리하려는 충동에 저항하라"였음.
- 관리 병은 "섬기는 리더십"으로 치료.
- 섬기는 리더로써 겸속, 존경, 신뢰의 분위기를 만들어햐 함.
- 여기에는 아래와 같은 것들이 포함.
  - 팀원들 스스로 제거할 수 없는 관료적 장애물을 제거.
  - 팀이 합의를 이끌어내는 데 도움.
  - 늦게까지 일할 때 저녁 식사를 사줄 수도.
- 팀이 잘 나아갈 수 있게 틈을 메우고, 필요하면 조언도 하며, 직접 손을 더럽히는 것도 주저 X.
- 섬기는 리더가 하는 유일한 매니징은 팀의 기술적 그리고 사회적 건강 관리.
- 종종 기술적 건강에 집중하고자 하는 유혹에 빠질 수도 있으나 사회적 건강 역시 매우 중요.

## The Engineering Manager

- 현대 소프트웨어 회사에서 관리자에게 기대하는 것은 무엇인가?

### Manager is a Four-Letter Word

- 관리자의 역사는 군대 계층에서 비롯되어 산업 혁명에 적용됨. 백 년도 더 된 이야기.
- 공장들이 이곳저곳에 생겨났고, 기계가 계속 돌아가게 하기 위한 작업자들을 필요로 함.
- 이들을 관리하기 위한 감독관이 필요했는데, 작업자들은 언제든 대체 될 수 있으므로, 노동자들을 잘 대우하고 그들의 환경을 개선하는 일에 동기부여 되지 못함.
- 노동자들은 한 번 외운 작업을 반복하면 됐으므로, 이 방식은 꽤 오랫동안 잘 작동함.
- 때로 관리자들은 말로 수레를 끌 때의 당근과 채찍 방법으로 노동자들을 대하기도.
- 이 방식은 공장에서 현대 오피스로의 전환에도 살아 남음.
- 여전히 일부 산업에서는 이것이 지속되고 있음.
- 하지만 창의적 문제 해결이나 사고가 필요한 곳에서는 비효율.

### Today's Engineering Manager

> 전통적 관리자들은 일을 어떻게 끝낼지에 관심을 두는 반면, 훌륭한 관리자들은 무엇을 끝낼지(그리고 팀원들이 해결할 방법을 알아낼 것임을 신뢰)에 관심을 둠.

## Positive Patterns

책은 안티패턴부터 나오는데 정리는 긍정패턴부터 시작.

### Lose the Ego

- "자아를 내려놓는 것"은 사람들로부터 이용 당하라는 것으로 오해되곤 함.
- 겸손을 통해 자기 중심에서 벗어나되 자신감과 의견은 필요.
- 개인의 자아가 너무 크면, 특히 팀 리더의 것이면 더더욱 문제가 됨.
- 자아 분리를 위한 첫 번째로 필요한 것은 팀에 대한 신뢰.
- 이는 팀원들의 역량과 성취를 존중함을 의미.
- 팀을 마이크로매니징 하고 있지 않다면,
- 최전선의 동료가 당신보다 일의 세부사항을 더 잘 알고 있다고 믿는 것.
- 비록 팀의 동의를 이끌어내고 방향을 잡도록 돕는 사람이라고 하더라도,
- 당신의 목표가 어떻게 달성될 수 있는지는 함께 제품을 만들어가는 사람이 가장 잘 결정할 수 있음.
- 이는 팀원들이 제품 성공/실패에 대한 주도성과 책임감을 갖는데 도움.
- 좋은 팀이 있고 품질과 속도에 대한 기준을 설정할 수 있다면 더 많은 것을 달성할 수 있음.
- 처음 리더십 역할을 맡게 되면 모든 것이 올바르게 동작하고 모든 것을 알아야 하고 모든 대답을 할 수 있어야 한다는 강박을 갖곤 함.
- 하지만 불가능. 질문과 비평에 열려 있어야 함.
- 자아 분리에 필요한 마지막은 실수 했을 때 사과하기.
- 남발하라는 것이 아님. 진심이어야 함.
- 사과하는 것이 당신을 약하게 한다는 것은 오해.
- 실수를 인정하면 오히려 존중 받을 수도.
- 상황을 냉정하게 인식할 수 있으며 상식적이고 겸손하다는 것을 드러내기 때문.

### Be a Zen Master

- 엔지니어로써 회의와 냉소 감각을 잘 키워왔을 것.
- 하지만 팀을 이끌 때는 이것이 장애가 될 수 있음.
- 모든 일에 낙관하라는 것은 아님.
- 일의 장애물을 인식하고 있음을 알리면서도 덜 회의적이어야 한다는 것.
- 반응을 잘 조절하고 평정심을 유지해야 함.
- 동료들이 당신의 반응을 보며 어떤 행위를 해야 하는지에 대한 단서를 찾기 때문.
- 아래 내용이 좋아서 그대로 가져와 적음.
- 말이나 행동 하나에도 책임감 있어야 함을 다시금 반성하는 중 @.@

> Another way of thinking about this is the maxim that the leader is always on stage. This means that if you’re in an overt leadership position, you are always being watched: not just when you run a meeting or give a talk, but even when you’re just sitting at your desk answering emails. Your peers are watching you for subtle clues in your body language, your reactions to small talk, and your signals as you eat lunch. Do they read confidence or fear? As a leader, your job is to inspire, but inspiration is a 24/7 job. Your visible attitude about absolutely everything—no matter how trivial—is unconsciously noticed and spreads infectiously to your team.

- 간혹 팀원들이 조언을 구하러 올 수도 있음.
- 해결책을 제시해 주는 것은 도움이 X. 오히려 역효과일 수도.
- 겸손, 존중, 신뢰를 갖고 그들 스스로 문제를 해결하도록 문제를 같이 재정의하고 탐색.
- 결국 문제를 해결할 가능성도 높고, 업무의 주도성을 유지하는 데도 도움.

### Be a Catalyst

- 사람들을 더 가까이 모이게 해서 긍정적 상호작용을 일으키기.
- 팀의 동의를 이끌어내는 것이 대표적인 예.
- 처음부터 끝까지 절차를 이끌어 갈 수도 있고,
- 올바른 방향으로 속도 내어 가도록 부드럽게 밀어줄 수도.
- 여기에 권위는 없어도 됨.
- 권위가 있다면 명령하고 지시할 수 있으나 덜 효과적.
- 물론 가끔 팀이 빠르게 나아가야 한다면, 자발적으로 권위를 쥐어주고 이끌게 할 수도.
- 하지만 이 또한 동의의 한 형태.

### Remove Roadblocks

- 이미 동의가 되어 있더라도 장애물에 막히기도 함.
- 기술적 또는 조직적 장애물 모두를 일컬음.
- 팀원들은 뚫고 지나가기 어려운 장애물이 당신에게는 다루기 쉬운 것일 수도.
- 당신이 이런 장애물이 있을 때 도움을 줄 수 있고, 기꺼이 한다는 것을 팀원들에게 알리는 것도 중요.
- 팀원들이 한참 고민하고도 해결이 안 되어 관리자를 찾아갔을 때 관리자가 문제를 해결할 수 있는 다른 사람을 연결해 주는 사례들을 언급.
- 해결책을 제시하지 말라는 Be a Zen Master의 내용과 장애물을 제거하는 것과는 조금 다른 이야기임에 유의.

### Be a Teacher and a Mentor

- TL로써 가장 힘든 점 중에 하나는 당신이 20분 만에 해결할 수 있는 것을 주니어가 3시간 사용하는 걸 지켜보기.
- 알려주고 배울 기회를 주는 것이 어렵긴 하나 팀을 스케일링 하는 데 중요한 요소.
- 좋은 멘토는 멘티들이 배우는 데 드는 시간과 제품에 기여하는 시간 사이의 트레이드 오프를 잘 고려.
- 멘토가 되는 데는 3가지만 있으면 됨.
  - 팀 프로세스와 시스템에 대한 경험.
  - 남에게 무언가를 설명할 수 있음.
  - 멘티가 얼만큼의 도움을 필요로 하는지 아는 것.
- 특히 마지막이 제일 중요. 지나치게 설명하거나 끊없이 말한다면 멘티는 잘 듣지 않을 것.

### Set Clear Goals

- 명백하지만 많은 리더들이 챙기지 못하는 패턴 중 하나.
- 방향을 설정하고, 우선순위를 정하고, 트레이드 오프를 결정하도록 도와야 함.
- 방향 설정을 위한 한 가지 쉬운 방법은 간결한 미션 문장을 만드는 것.
- 방향을 설정했다면 한 발 물러서서 자율성을 준 뒤 주기적으로 올바르게 가고 있는지 확인.
- 이는 리더의 시간을 확보하여 또 다른 중요한 일에 쓸 수 있게 해주기도 하지만,
- 서로 다른 방향으로 제품을 당기느라 나아가지 못하는 낭비를 예방해 주는 효율을 가져다 주기도.

### Be Honest

- 당신이 팀에 거짓말을 하고 있다는 얘기가 아님.
- 리더 위치에 있을 땐, 무언가 말할 수 없는 경우도 있고, 팀원들이 듣기 싫은 말을 해야 하는 경우도 있음.
- 공유 불가한 것을 질문할 땐 대답할 수 없음을 얘기 해도 괜찮음.
- 모르는 것을 물을 땐 모른다고 답변. 모르는 것이 자신을 약하게 한다는 두려움은 버려야.
- 부정적 피드백을 전달하는 것은 어려움.
- 그러나 칭찬 샌드위치를 사용하는 것은 위험.
- 사람들은 변화가 필요한 비판적 메시지를 잘 수용하지 않으려 하기 때문.
- 대신, 친절하고 공감하는 태도로 간결하게 피드백을 전달.
- 듣는 사람을 덜 방어적이게 할 수 있음.
- 직접적 피드백이나 비판을 제공할 때 '전달이 되는지'가 중요.
- 상대방이 방어적으로 되면 어떻게 바뀌어야 할지가 아니라 어떻게 논쟁할지를 생각.

### Track Happiness

- 리더로써 장기적으로 팀을 좀 더 생산적으로 만들 수 있는 한 가지 방법은,
- 구성원들의 행복을 측정하는 데 시간을 들이는 것.
- 함께 일했던 좋은 리더들은 모두 아마추어 심리학자들이었음.
- 종종 팀원들의 복지를 살피고,
- 자신들이 하는 일에 대해 인정 받고 있는지 확인하고,
- 일에 만족하는지도 확인하려 노력.
- 한 TLM은 해야하지만 맡기 싫어하는 일들이 잘 분배되도록 스프레드시트를 만들어 관리.
- 어떤 TLM은 팀이 일하는 시간을 지켜보며, 번아웃을 피하기 위해 보상 휴가나 가벼운 외출 등을 활용.
- 또 어떤 이는 1:1 세션을 마련해서, 지금 겪는 기술적 이슈를 얘기하는 것으로 가볍게 시작하여, 엔지니어들이 일을 잘 끝내기 위해 부족한 것은 없는지를 같이 이야기. 더불어, 일을 어떻게 즐기고 있는지, 향후엔 무엇을 기대하는 지를 대화.
- 팀의 행복을 측정하는 가장 쉬운 방법은 1:1 대화.
- "필요한 게 무엇인가요?"라는 간단한 질문이 좋은 질문이 될 수도.
- 하지만 필요에 따라 좀 더 세부사항을 조심스럽게 물어봐야 할 수도.

## The Unexpected Question

- 구글 입사 후 CEO 에릭 슈미트와의 만남 마지막에 받은 질문.
- "Is there anything you need?"
- 리더로써 오피스 바깥에서의 팀 행복에 대해서도 관심을 갖는 것은 가치 있는 일.
- 사생활을 캐라는 것이 아니라, 바깥에서의 일이 일의 생산성에도 영향을 주는 것을 이해하라는 것.
- 예컨대, 개인적으로 힘든 일을 겪고 있는 팀원에게는 좀 더 넉넉한 마감 기한을 줄 수도.
- 상식적이지 않은 수준의 시간을 오피스 내에 쏟길 바라는 것도 경계할 수 있음.
- 팀원의 행복을 추적하는 데 중요한 부분은 그들의 경력을 추적하는 것.
- (추적이라는 단어 말고 다른 번역 용어가 있으면 좋을 듯)
- 말로 표현되든 아니든, 보통은 5년 내에 하고 싶은 것들이 있을 것.
- 이를 위해 도울 수 있는 건 없을지 생각하고, 또 생각하고 있음을 알리는 것이 필요.
- 이런 암묵적이 목표들을 이끌어 내고 명시화하면, 경력 조언 시 지금의 상황이나 기회를 평가 할 지표가 될 수 있음.
- 경력 모니터링 외에도, 그들이 성장할 수 있게 하고, 인정 받게 하고, 약간의 재미를 얻게 하는 것도 필요.

## Other Tips and Tricks

- Delegate, but get your hands dirty
  - 직접 하는 것 보다 오래 걸리더라도 위임.
  - 팀이 배울 기회이며 당신이 제정신(?)을 유지하게 해 줌.
  - 팀의 존경을 얻고 다른 이들의 생산성을 올려주는 한 가지 방법은,
  - 아무도 하고 싶어하지 않는 일들을 직접 처리하는 것.
  - 아무리 화려한 이력이 있더라도 직접 하는 것이 역량과 헌신을 보여주는 유일한 방법.
- Seek to replace yourself
- Know when to make waves
- Shield your team from chaos
  - 처음 리더 역할을 맡았을 때 이전엔 없었던 혼란과 불확실들이 닥치기 시작.
  - 하지만 이는 원래부터 있던 회사의 일상적 일들.
  - 그 동안 이전 관리자가 보호해 주고 있던 것.
- Give your team air cover
  - 팀 외부의 불확실성과 경솔한 요구사항으로부터의 보호만큼이나,
  - 회사 내의 팀 바깥에서 일어나는 일들을 알려주는 것이 중요.
  - 가능한 많은 정보들을 공유.
  - 하지만 팀원들에게 실제로는 영향을 줄 가능성이 극도로 낮은 조직의 미침(?)들로 주의 분산 X.
- Let your team know when they're doing well
- It's easy to say "yes" to something that's easy to undo

## People Are Like Plants

- 저자의 부인은 서로 너무나 다른 6형제 중 막내.
- 장모님은 각각을 서로 다르게 대해 주었다고 함.
- 이는 식물 키우기와 비슷.
- 서로 다른 종류의 식물에 똑같은 햇빛과 물을 준다면 모두 죽게 될 지도.
- 팀원들도 마찬가지.
- 매너리즘에 빠질 수 있는 동료에겐 동기부여를,
- 뭘 해야할지 모르는 동료에겐 명확한 방향 제시를 해 주는 것이 좋음.
- 물론 지나친 수준으로 하는 것은 동료에게 괴로움.
- 방향 제시는 간단. 무엇을 해야 하는지에 대한 기본적 이해, 간단한 조직 기술, 관리 가능한 수준으로 작업 쪼개기 정도.
- 동기부여는 이보다 어려움.

### Intrinsic Versus Extrinsic Motivation

- 동기부여는 크게 2가지 종류.
- 금전적 보상과 같은 외재적<sup>extrinsic</sup> 동기.
- 내재적<sup>intrinsic</sup> 동기.
- 마이크로매니징 없이도 스스로 해결할 수 있는 역량을 가진 사람들은 자율성이 있음.
- 이런 동료들에겐 전반적인 방향만을 제공하고, 어떻게 달성할지에 대해선 맡기는 것이 좋음.
- 이런 사람들은 어쩌면 당신보다 제품을 더 잘 알아서 그렇기도 하지만, 제품에 대한 주인의식을 느끼게 해 주기도. 결국 동기부여에 도움.
- 제품의 성공에 대한 지분이 클수록 제품의 성공에 대한 관심도 커짐.
- 숙달을 위해 충분한 기회를 제공하면, 동기부여 뿐만 아니라 성장을 통해 더 나은 팀이 될 수 있음.
- 물론 목적 없이 일한다면, 자율과 숙달이 동기부여를 줄 수 없음.
- 팀원들의 일에 목적(why)을 설명하는 것이 중요한 이유.
- 생각보다 많은 이들이 큰 영향력을 가진 제품을 위해 일하고 있음.
- 그리고 그렇지 않더라도 그들의 노력의 이유를 찾고 알려줄 수 있음.

## Antipatterns

안티 패턴에 대해서는 간단히 기록.

### Antipattern: Hire Pushovers

- 자신의 위치/역할을 잃을 불안감에 자신보다 부족한 사람들을 뽑는 것.

### Antipattern: Ignore Low Performers

- "Hope is not a strategy"
- 저 성과자를 다룰 때 특히 이런 오용이 많이 일어남.
- 저 성과자는 고 성과자를 합류하지 못하게 할 뿐만 아니라,
- 기존의 고 성과자들을 떠나게 하기도 함.
- 결국엔 자유의지로 떠날 수 없는 사람들만 남아 저 성과자 팀이 됨.
- 가능한 빨리 조치를 취해야 함.
- 단지 약간의 격려나 지시만으로 더 높은 생산성을 발휘할 수도 있음.
- 이런 사람들에겐 일시적인 마이크로 매니징이 필요할 수도.
- 그리고 여전히 많은 겸손, 존중, 신뢰 그 중에서도 존중이 필요.
- 특정 기간과 그 기간 동안 그들이 달성하기를 원하는 매우 구체적인 목표를 설정.
- 목표는 작고 점진적으로, 그리고 측정 가능하도록 설정.
- 매 주 팀원을 만나 전진하고 있는지 확인.
- 매우 명시적인 기대를 설정해야 다음 마일스톤에서 성공과 실패를 판단하기 쉬움.
- 효과가 나타난다면 계속 향상을 위해 노력하고 그렇지 않으면 멈출 수 있어야 함.

### Antipattern: Ignore Human Issues

- 관리자는 팀의 사회적 + 기술적 영역 모두에 집중해야 함.
- 구글에선 관리자들이 기술적 부분에서 더 강점을 드러내는 게 일반적이며,
- 이들은 사람 이슈를 소홀히 하는 경향이 있음.

### Antipattern: Be Everyone's Friend

- 보통 자기가 팀원으로 속해 있던 곳에서 리더를 시작하곤 함.
- 그리고 그 동안 쌓아온 우정을 잃지 않고 싶어 함.
- 그래서 더 열심히 일하곤 함.
- 부드러운 터치와 함께 리딩하는 것과 우정을 혼동 X.
- 다른 사람의 경력에 대한 힘이 생기면, 우정의 제스처도 보답해야 하는 무언가로 느껴서 압박이 되기도.
- 가까운 친구 관계가 아니더라도 동의를 이끌어 내고 팀을 이끌 수 있음을 기억.
- 팀원들과 함께 하는 점심이 그들을 불편하게 하지 않으면서도 사회적으로 연결된 상태를 유지하게 도움.
- 업무적 환경에서 벗어나 비공식적 대화를 할 수 있는 기회.

### Antipattern: Compromise the Hiring Bar

- "A people hire other A people; B people hire C people."
- 구글 바깥에서 흔히 봤던 방법은 5명의 엔지니어를 뽑을 때 4-50명의 지원자를 받고 최고의 후보 5명을 선택하는 것.
- 하지만 이는 평범한 팀을 만드는 가장 빠른 방법 중 하나.
- 고용하지 말았어야 할 팀원을 계속 대하는 것에 비하면 적절한 사람을 찾는 데 들이는 비용은 적음.

### Antipattern: Treat Your Team Like Children

- 팀원들을 신뢰하지 않음을 보여주는 가장 좋은 방법은 팀원들을 아이처럼 대하는 것.
- 마이크로매니징, 존경 없이 그들을 대하기, 책임감을 가질 기회를 제공하지 않는 등이 그 예.
- 신뢰할 만한 사람을 고용해야 하고 또 신뢰를 보여줘야 함.

# 6. Leading at Scale

- 앞서 "개인 기여자"에서 "팀 리더"가 되어 가는 것에 대해 얘기.
- 이 역할이 커지더라도 모든 프랙틱스는 여전히 적용됨.
- 여전히 "섬기는 리더"이며, 단지 더 큰 그룹을 섬기는 것.
- 다만, 해결해야 하는 문제의 범위가 좀 더 커지고 좀 더 추상적이 됨.
- "깊게" 가는 대신 "넓게" 가게 됨.
- 세부적인 것들에 멀어지는 것을 애석해 할지도 모름.
- 이전의 엔지니어링 전문 지식이 점점 더 현재 일과 관련이 적어짐.
- 대신에 일반적인 기술적 직감과 엔지니어들이 올바른 방향으로 나아가게 하는 능력들이 중요해짐.
- 이런 상황에서 필요한 "the three Always of leadership"에 대해 이야기.
  - Always Be Deciding
  - Always Be Leaving
  - Always Be Scaling

## Always Be Deciding

- 팀들의 팀을 관리하는 것은 더 상위 수준의 결정을 더 많이 내리게 되는 것을 의미.
- 구체적인 엔지니어링 문제 해결 대신 상위 수준이 전략들을 다룸.
- 대부분의 결정들은 올바른 트레이드 오프 집합을 찾는 것.

### The Parable of the Airplane

- 리더로써 팀이 매주 해야 하는 일들을 결정해야 함.
- 이 때 고려해야 하는 트레이드 오프는 예측 가능하기도 하지만,
- 어떤 것들은 예측 불가한 결과를 가져오기도 함.
- 이와 관련하여 비행기 출발 지연 사례가 소개됨.
- 가장 최상위 수준에서, 리더의 역할은 사람들이 어렵고 모호한 문제들을 잘 해결해 나가도록 안내하는 것.
- 여기서 모호하다는 것은 명확한 해결책이 없거나 해결되지 않을 수도 있음을 의미.
- 그럼에도 불구하고, 문제는 탐색되어야 하고, 통제 가능한 상태가 되도록 애써야 함.
- 코드 작성이 나무를 베는 것이라면, 리더의 역할은 나무들을 통해 숲을 보는 것.
- 이 프로세스에는 세 가지 주요 단계가 있음.
  - 눈가리개<sup>blinder</sup>를 식별
  - 트레이드 오프 식별
  - 해결책을 결정하고 계속 반복

### Identify the Blinders

- 문제에 처음 접근해 보면, 이미 담당자들이 오랜시간 동안 그 문제와 씨름해 왔음을 발견.
- 하지만 이들은 문제에 너무 푹 빠져 있어 "눈가리개"를 하고 있는 것과 같음.
- 더 이상 숲을 보지 못한다는 것.
- 문제에 대한 많은 가정을 만들어 둠.
- 항상 해왔던 방식이라고 이야기,
- 현재 상태를 비판적으로 바라보는 능력을 상실.
- 때로는 현 상태를 정당화하기 위해 꾸준히 진화해 온 기이한 대응기제나 합리화들이 존재.
- 이 상황에서는 신선한 눈을 가진 것이 도움이 됨.
- 질문을 던지고 새로운 전략을 고려하게 할 수 있음.

### Identify the Key Trade-Offs

- 중요하고 모호한 문제들에는 "은총알" 해결책이 없음.
- 그 순간에 맞는 방법이 있을 뿐이고, 각 선택지에는 트레이드 오프가 존재.
- 당신의 역할은 트레이드 오프들을 이끌어내고, 모두에게 설명하고, 균형 잡힌 결정을 하도록 돕는 것.

### Decide, Then Iterate

- 트레이드 오프를 이끌어냈다면 이를 이용해 최선의 결정을 내리면 됨.
- 다만, 다음 달이 되면 다시 트레이드 오프를 평가하고 리밸런싱 해야 함.
- 이는 반복적 프로세스.
- Always Be Deciding이라고 제목 지은 이유.
- 만약, 지속적인 프로세스로 바라보지 않는다면,
- 완벽한 해결책을 찾으려는 함정에 빠지게 될 수도 있고,
- 이는 [분석 마비](https://en.wikipedia.org/wiki/Analysis_paralysis)<sup>analysis paralysis</sup>로 이어질 수 있음.
- 아래와 같은 설명을 통해 팀이 이런 반복에 익숙해지게 해야 함.

> 우리는 이 결정을 한 번 시도해 보고 어떻게 되어가는지 볼 것입니다. 다음 달에는, 이 변경을 다시 원복할 수도 있고, 다른 결정을 다시 내릴 수도 있어요."

## Always Be Leaving

- 얼핏 보기에 이상한 조언으로 들림.
- 왜 좋은 리더는 항상 떠날 준비가 되어 있어야 하나?
- 모호한 문제를 푸는 건 당신의 역할이 아님.
- 스스로 문제를 푸는 조직을 만드는 것이 해야 할 일.
- 이게 되면 당신은 새로운 문제나 조직으로 갈 수 있는 상태가 됨.
- 이에 대한 안티패턴은 당신이 SPOF가 되는 것.
- 책 앞 부분에서 버스 팩터 언급한 것도 같은 맥락.

### Your Mission: Build a "Self-Driving" Team

- 어려운 문제를 스스로 해결하는 조직을 만들어야 함.
- 이에는 3가지가 필요.
  - 문제 영역을 나누기.
  - 나눈 문제들을 위임.
  - 필요한 만큼 반복.

### Dividing the Problem Space

- 도전적인 문제들을 보통 어려운 하위 문제들로 이뤄져 있음.
- 팀들의 팀을 이끌고 있다면, 각 팀에 각 하위 문제들을 할당할 수 있음.
- 하지만 리스크가 있음. 하위 문제들이 계속 바뀐다는 것. 고정된 팀 경계는 이 사실을 알아차리거나 적응하기 어려움.
- 따라서 좀 더 느슨한 조직 구조를 고려. 하위 팀들은 크기를 조정할 수 있고, 하위 팀들 간에 개인 이동이 가능하며, 할당된 문제가 계속 바뀔 수 있는 구조.
- 물론 확고함과 느슨함 사이의 균형이 필요.
- 문제와 목적을 명확히 인식하고 꾸준히 성과를 내는 확고함.
- 그리고 변화하는 환경에 대응하여 새로운 것을 시도하고 방향을 바꿀 수 있는 자유로움.

#### Example: Subdividing the "latency problem" of Google Search

- 검색 지연 문제의 경우, 적어도 2가지 문제로 나눌 수 있었음.
- 하나는 지연의 증상을 다루는 것이고, 다른 하나는 지연의 원인을 다루는 것.
- 속도를 빠르게 하는 것에 많은 인력이 필요했지만 이것 만으로는 충분치 않았음.
- 여전히 많은 엔지니어들이 검색 결과의 복잡도와 품질을 높이면서 속도를 저하시키고 있었음.
- 따라서 우리는 지연을 예방하는 일도 함께 해결해야 했음.
- 이렇게 원인과 증상 모두에 팀을 할당함으로써 지연을 장기적 관점에서 통제할 수 있었음.

#### Delegating subproblems to leaders

- 위임은 배우기 어려움.
- 효율성과 성취에 대한 우리의 직관과 반대됨.
- 일을 제대로 끝내려면 직접하라는 속담도 있음.
- 만약 자기 주도적 조직을 만드는 게 목표라면, 위임은 효과적인 코칭 메커니즘.
- 자족적 리더들도 키워내는 데에도 위임이 절대적으로 효과적인 훈련 방법.
- 일을 맡기고, 실패하게 두며, 반복적으로 시도할 수 있게 해야 함.
- "failing fast and iterating"
- 엔지니어링 설계뿐만 아니라 인간의 배움에도 역시 적용됨.
- 쌓여 있는 수 많은 일들을 처리하기에 앞서 중요한 질문을 먼저 던지기.
- "Am I really the only one who can do this work?"
- 그리고 "What can I do that nobody else on my team can do?"를 질문.
- 조직 정책으로부터 팀을 보호하고, 동료에게 용기를 복돋아주고, 서로를 잘 대해주게 돕고, 겸손/신뢰/존중의 문화를 만드는 것들이 이에 해당.
- "manage up" 또한 중요. 조직이 무엇을 하는지 관리 체계에 이해시키고 회사와 연결된 상태를 유지시키는 것.
- 그 중에서 가장 흔하고 또 중요한 대답은 "I can see the forest through the trees".
- 전체적인 기술적 방향뿐만 아니라 조직 전략 또한 다루어야 함.
- 상위 수준의 전략을 정의하는 것.
- 지속적으로 숲과 대응시키고 각 구성원에게 나무 베는 일을 잘 나누기.

#### Adjusting and iterating

- 자립하는 기계를 만드는 지점에 다다랐고, 당신은 더 이상 SPOF가 아니다. 이제 뭘 해야 하나?
- 일단 대답에 앞서, "Always Be Leaving" 말대로 새로운 문제나 조직을 찾아서 떠날 수 있음.
- 이는 개인의 번아웃을 방지하는 훌륭한 방법 중 하나.
- 무엇을 해야 할지에 대한 간단한 대답은 아래와 같음.
- 자율적으로 움직이는 기계가 올바른 방향으로 가고 있는지 관찰하고,
- 반복적인 방향 지시를 하되 사려 깊고 최소한으로 이뤄져야 하며,
- 코스를 조정하기 위해 최소한의 조정만 행해야 함.
- 마이크로 매니지먼트로 회귀한다면 다시금 SPOF가 되는 것.

#### Take care in anchoring a team's identity

- 팀을 일반적인 문제가 아닌 특정 제품을 담당하게 하는 것은 흔히 일어나는 실수.
- 제품 = 어떤 문제의 한 가지 해결책
- 해결책의 기대 수명은 짧을 수 있음.
- 제품은 더 나은 해결책으로 대체될 수 있음.
- 예를 들어, "우리는 깃 리포지토리를 관리하는 팀이다"라며 팀에 특정 해결책을 맡김.
- 하지만 만약 대부분의 엔지니어가 새로운 버전 관리 시스템으로 교체하길 원한다면?
- 아마 팀은 조직 차원에서 최선이 아니라고 하더라도 기존의 방식을 고수하며 변화를 거부할지도.
- 해결책 자체가 팀의 정체성 일부이며 스스로의 가치라고 여기기 때문.
- 이렇게 하는 일반화 된 문제를 팀이 담당하게 해야 함.
- "우리는 회사에 버전 관리를 제공하는 팀이다"
- 시간이 지나면서 다른 해결책들도 실험할 수 있도록 해방시켜 주는 것.

## Always Be Scaling

- 리더로써 가장 중요한 자원은 제한된 시간 풀, 집중력, 에너지.
- 이들에 대한 보호 없는 공격적 스케일링은 실패하고 말 것.
- 어떻게 하면 효율적인 스케일링을 이룰 수 있을지에 대한 이야기.

### The Cycle of Success

- 팀이 어려운 문제와 맞붙었을 때 반복적으로 나타나는 싸이클이 있음.
- Analysis
  - 문제를 처음 받고 씨름하기 시작.
  - 눈가리개를 찾아내고, 트레이드 오프를 찾아냄.
  - 어떻게 할지에 대한 동의를 구함.
- Struggle
  - 작업을 시작.
  - 팀에서 아직 준비가 안 됐다고 생각하는지 여부와 관계 없이.
  - 실패와 재시도, 반복을 준비.
  - 주로 이뤄지는 작업은 의견을 한데 모으는 일.
  - 리더와 전문가들이 의견을 내고 주의 깊게 듣고 전체적인 전략을 강구하도록 격려.
- Traction
  - 당신의 팀이 마침내 상황을 이해함.
  - 당신은 좀 더 현명한 결정을 내림.
  - 진도도 실제로 나아가기 시작.
  - 당신은 트레이드 오프를 반복적으로 찾아내고 재평가.
  - 담당 조직은 스스로 문제를 주도하기 시작.
- Reward
  - 결과를 이뤄냄. 보상도 이뤄짐.
  - 하지만 보상은 더 많은 책임과 역할의 시작을 의미하기도.
- 이제 새로운 문제가 추가됨.
- 하지만 인력은 그대로.
- 절반의 인력은 원래의 문제를 계속 다루고,
- 나머지 인력은 새로운 문제와 부딪히기 시작.
- 이 마지막 단계를 일컬어 compression stage라고 부름.
- 지금까지 했던 일들의 크기를 절반으로 압축하는 것.
- 이런 식으로 성공의 싸이클은 나선형으로 확대되는 모습.
- 시간이 지날수록 새로운 문제들을 다루며 스케일링 하는 것.
- 물론 새로운 사람을 채용하면 좋지만 이는 보통 스케일링 속도를 따라가지 못함.
- 결국 압축 단계와 더불어 병행이 필요한 이유.

### Important Versus Urgent

- 리더가 아닌 엔지니어였을 때, 당신의 삶은 혼란보다는 평온함에 가까웠을 것.
- 하지만 리더로써 해야 하는 일들은 예측하기 어렵고 소방에 가까운 것들.
- 예방형<sup>proactive</sup>보다는 반응형<sup>reactive</sup>에 가까움.
- 수 많은 연락과 요청의 연속들.
- 긴 코드 블럭의 마지막 `finally` 절에 비유.
- 주의하지 않으면 반응형 모드로 100% 시간을 보내게 됨.
- 그리고 중요한 것과 급한 것의 구별 이야기.
- 리더로써 중요한 것은 숲을 관통하는 길을 매핑하는 것처럼, 리더만이 해 줄 수 있는 일들.
- 중요한 일에 대부분의 시간을 쏟는 방법으로 아래의 것들을 언급.
- Delegate
  - 긴급한 많은 일들은 당신 조직의 다른 리더에게 위임 가능한 것들.
  - 사소한 일이라면 죄책감을 느낄 수도 있고,
  - 다른 리더에게 주는 것이 더 오래 걸리기에 비효율이라 느낄 수도 있음.
  - 하지만 훈련의 좋은 방법이며 당신을 중요한 일을 하도록 보호해 줌.
- Schedule dedicated time
  - 2시간 이상을 주기적으로 잡고 조용히 앉아서,
  - 긴급치 않지만 중요한 것들에 시간을 보낼 것.
- Find a tracking system that works
  - GTD 같은 도구를 쓰라는 이야기.
  - 일을 계속 추적하고 우선순위를 조정하기 위함.

### Learn to Drop Balls

- 엔지니어일 때와 다르게 리더에겐 끊임없이 공(요청, 질문, ...)이 날라옴.
- 이 공들 중 일부를 떨어뜨리는 것을 필수불가결.
- 그렇다면 의도치 않게 떨어뜨리는 것보다는 의도적으로 떨어뜨리는 것이 좋지 않을까?
- 이를 위한 방법으로 마리아 콘도의 방식을 소개.
- 바닥의 20%는 중요하지도 않고 긴급하지도 않은 것으로, 무시하거나 지우기 쉬움.
- 중간의 60%는 약간의 긴급함이나 중요성을 가지긴 함.
- 상위 20%는 매우 중요한 것들.
- 상위 80%를 다 해결하려 애쓰지 말고,
- 상위 20%에 속하는 것들을 식별하고 이들에 집중.
- 처음에는 이것이 기분 안 좋게 느껴질 수도 있으나, 2가지 놀라운 사실을 발견하게 될 지도.
- 하나는, 60% 작업을 위임하지 않더라도, 서브 리더들이 이를 인지하고 알아서 가져간다는 것.
- 다른 하나는, 60%의 것 중 정말로 중요한 것이 있다면, 20%의 것으로 이동하여 결국엔 다시 돌아온다는 것.

### Protecting Your Engergy

- 시간과 집중 외에 에너지 또한 보호해야 하는 자원.
- 스케일링 시 어떻게 충전된 상태와 낙관을 유지할 수 있을까?
- 일단 한 가지 대답은 시간이 지남에 따라 나이가 들어감에 따라 전체적인 체력이 향상한다는 것.
- 또 한 가지 대답은 리더는 점점 에너지를 똑똑하게 관리하는 법을 배운다는 것.
- 이는 상황에 맞게 얼마나 많은 에너지를 쓸지 알고, 의도적으로 재충전 시간을 가질 줄도 앎을 의미.
- 아래는 에너지를 잘 관리하는 몇 가지 사례들.
- Take real vacation
  - 주말은 방학이 아님.
  - 최소 3일은 일에 대해 잊을 수 있어야 함.
- Make it trivial to disconnect
  - 쉴 때는 오피스에 일하는 랩탑을 두고 가기.
  - 핸드폰에 업무 커뮤니케이션이 있다면 제거.
- Take real weekends, too
  - 방학 만큼 효과적이진 않지만 여전히 활기를 되찾아주는 도구.
  - 이런 충전이 업무 커뮤니케이션으로부터 차단됐을 때 가능한 것도 다시 언급.
- Take breaks during the day
  - 일어나서 사무실 근처를 걸어다니기.
  - 작은 휴식은 작은 충전을 가져다주긴 하지만 큰 차이를 만들어 냄.
- Give yourself permission to take a mental health day
  - 정신적으로 힘든 날이 있을 수 있음.
  - 기분이 쳐져 있는 상태로 출근하는 것은 리더로써 주변에 안 좋은 영향.
  - 이럴 땐 집으로 가서 휴식.

# 7. Measuring Engineering Productivity

- 구글은 데이터 주도 회사.
- 대부분의 제품과 설계 결정들을 하드 데이터에 저장.
- 적절한 메트릭을 사용한 데이터 주도 의사 결정 문화는 물론 단점이 있긴 해도,
- 객관적 결정을 돕는다는 점에서 일반적으로는 좋은 도구.
- 하지만 인간 측면의 데이터를 모으고 분석하는 것에 어려움은 있음.
- 구글은 엔지니어의 생산성에 집중하는 전문가 팀을 갖는 것이,
- 조직을 키우고 인사이트를 활용하는 데 있어 매우 가치있고 중요함을 알게 됨.

## Why Should We Measure Engineering Productivity?

- 사업 확장을 위해 엔지니어 조직의 규모도 함께 키워야 한다고 생각하기 마련.
- 하지만 조직이 선형적으로 커질 때 커뮤니케이션 비용은 n^2으로 늘어남.
- 결국 사업의 규모는 조직의 규모가 커지는 속도를 따라잡지 못함.
- 확장 문제 해결의 또 한 가지 방법은 개인의 생산성을 높이는 것.
- 구글은 빠르게 성장해야 했고 이로 인해 엔지니어의 생산성을 높이는 방법을 알게 됨.
- 하지만 이런 방법들은 인적 자원의 소모를 동반했으며, 따라서 소프트웨어 엔지니어의 생산성을 높이는 일의 효율도 중요.
- 이 효율성 때문에 엔지니어 생산성을 전담하는 팀을 만들기도.

## Triage: Is It Even Worth Measuring?

- 생산성 측정하는 방법을 알기에 앞서, 언제 지표가 의미 있는지를 알아야 함.
- 측정은 비용이 큼. 사람이 프로세스를 측정해야 하고, 결과를 분석해야 하며, 회사에 전파해야 함.
- 또한 부담스럽기도 하고 조직을 느리게 만들 수 있음.
- 느리지 않다고 하더라도, 프로세스 트랙킹은 엔지니어의 행동을 바꿀 수도.
- 예컨대 잠재적 이슈를 숨기는 것.
- 똑똑하게 측정하고 추정해야 함.
- 생산성 측정이 가치가 있을지를 결정하기 위한 질문들을 제시하곤 함.
  - 어떤 결과를 기대하며, 왜 그런가?
  - 데이터가 당신의 예상 결과를 뒷받침 한다면, 어떤 조치를 취할 것인가?
  - 부정적 결과를 얻는다면 당신은 어떤 조치를 취할 것인가?
  - 결과가 나온다면 이 조치를 취할지는 누가 언제 결정하는가?
- 이 질문들을 통해 대부분은 측정이 의미 없음을 알게 됨.

## Selecting Meaningful Metrics with Goals and Signals

- 구글에선 Goals/Signals/Metrics (GSCM) 프레임워크를 메트릭 생성 가이드로 사용.
- goal: 원하는 최종 결과. 상위 수준에서 이해되길 기대하고, 측정 방법에 대한 언급이 포함되어 있으면 안 됨.
- signal: 목표를 달성했는지 알 수 있는 방법. 측정하고 싶지만, 측정이 어려움.
- metric: 시그널을 위한 프록시. 우리가 실제로 측정할 수 있는 것. 이상적인 측정은 아니겠지만 충분히 가까운 수준.

## Goals

- 원하는 속성에 관해 작성되어야 하고, 메트릭에 대한 어떠한 참조도 없어야 함.
- 좋은 목표는 시그널과 메트릭을 진행하기에 앞서 모두가 동의할 수 있는 것이어야 함.
- 그리고 이것이 제대로 동작하려면 가장 먼저 올바른 목표 집합을 식별해야 함.
- 간단해 보일지 모르지만 모든 트레이드 오프를 고려하지 못하고 빠뜨리기도 한다고.
- 가독성을 예로 들면, 프로세스가 얼마나 빠르고 쉬워야 하는지에 집중하느라, 코드 퀄리티 자체를 놓치기도.
- 가독성의 올바른 목표 집합은 아래 5가지로 잡았다고 함.
  - Quality of the code
  - Attention from engineers
  - Intellectual complexity
  - Tempo and velocity
  - Satisfaction

## Signals

- 시그널은 목표를 달성했는지를 알게 해 줌.
- 모든 시그널이 측정 가능하지는 않음.
- 하지만 이 단계에서는 괜찮음.
- 가독성을 예로 들며 각 목표에 대한 시그널 사례를 들고 있음.
- 썩 와닿지는 않음.

## Metrics

- 시그널을 위한 측정 가능한 프록시.
- 프록시이기 때문에 완벽한 측정 지표가 아닐 수도.
- 이를 보완하고자 시그널은 여러 메트릭을 갖기도 함.
- 예를 들어, 가독성 프로세스가 적용된 코드는 좀 더 빠른 리뷰 시간을 갖는지 측정하고자, 설문과 로그 데이터 모두를 활용.
- 이 두 가지 메트릭은 각각 불완전하지만, 이 둘이 서로 다른 결과를 보여준다면, 한 가지가 거짓이며 좀 더 탐구가 필요함을 알 수 있음.
- 일부 시그널들은 현재로써는 측정이 불가하여 메트릭을 가지지 못할 수 있음.
- 코드 품질의 경우 여러 학술들에서 제안하는 프록시들이 있지만, 어떤 것도 실제로 활용하긴 어려움.
- 이 경우 어떤 정량적 측정도 하지 않기로 결정. 엔지니어들에게 코드 품질에 대한 자체 평가를 요구하는 정도.

## Using Data to Validate Metrics

- 엔지니어의 빌드 시간을 측정하려고 자동화 된 도구를 넣어 두었는데,
- 실제로는 엔지니어가 시작하지 않은 빌드도 측정하고 있었고,
- 이를 발견 후 이런 빌드들은 측정에서 제외시켰다고 함.
- 정량적 메트릭이 매우 유용하긴 하지만, 문맥이나 내러티브를 제공하지는 못함.
- 질적 연구를 통해 프로세스를 개선하기 위한 인사이트를 얻어야 함.
- 가독성이 생산성에 미치는 영향을 평가할 때는, 3가지 메트릭을 혼합.
- 첫 번째는 가독성 프로세스가 끝난 직후에 이뤄진, 가독성에 특화된 설문. 이는 기억편향을 피했지만, 최신편향과 샘플편향을 수반.
- 두 번째는 분기 별로 이뤄진 가독성에 특화되지는 않은 대규모 설문(대신, 가독성이 영향을 주기를 기대했던 메트릭에 관한 것들).
- 마지막은 엔지니어들이 도구들을 사용할 때 측정되는 매우 세분화 된 로그 메트릭.

# 8. Style Guides and Rules

- 대부분의 엔지니어링 조직에서는 코드베이스를 관리하는 규칙을 가짐.
- 소스 파일의 저장소, 코드 포매팅, 네이밍, 패턴, 예외, 스레드, ...
- 규칙은 곧 법. 단지 제안이나 추천이 아닌, 강한 의무를 가진 법.
- 한편, 가이드는 추천과 베스트 프랙틱스의 제공.
- 가이드는 룰과 다르게 변이의 여지가 있음.
- 구글에서 스타일 가이드는 언어 마다 다양.
- Dart, R, Shell 같은 언어에서는 간결(네이밍과 포매팅 같은 주요 원칙 대해서만 집중).
- C++, Python, Java 같은 곳에서는 더 많은 디테일을 포함.
- 이런 스타일 가이드들은 코드베이스를 유지보수 가능한 상태로 유지하기 위한 목적들에서 하나씩 비롯됨.

## Why Have Rules?

- "좋은" 행동은 장려하고 "나쁜" 것은 억제하기 위함.
- 여기서 "좋은"과 "나쁜"은 조직이 무엇을 중요하게 여기느냐에 따라 달라짐.
- 조직의 가치를 먼저 생각해야 하는 이유임.
- 잘 정착된 규칙과 가이드는 코딩의 공통 어휘 모습을 갖춰나감.
- 이는 엔지니어로 하여금 그들이 말하고 싶은 것 대신 코드가 말해야 하는 것에 집중하게 도와줌.

## Creating the Rules

- "What rules should we have?"는 핵심 질문이 아님.
- "What goal are we trying to advance?"가 핵심.
- 목적에 초점을 두면 어떤 규칙이 유용한지 판별하기 쉬움.

### Guiding Principles

- 구글에는 3만명의 엔지니어들이 있음.
- 그만큼 다양한 기술과 배경들이 함께 존재.
- 각 조직에 맞게 가치를 다르게 산정하긴 하지만,
- 시간과 규모의 확장에도 엔지니어링 환경을 지속시키는 것이 공통된 목표.
- 이런 맥락에서 규칙의 목적은, 개발 환경의 복잡성을 다루고, 코드베이스를 관리 가능한 상태로 유지시키며, 개발자의 생산성을 보호하는 것.
- 여기서 트레이드 오프가 발생.
- 규칙이 많으면 선택의 제약이 많아짐.
- 하지만 충돌을 줄이고 일관성을 얻을 수 있음.
- 이런 것들을 고려할 때, 아래 5가지가 규칙 개발에 도움이 됨을 발견.
  - Pull their weight
  - Optimize for the reader
  - Be consistent
  - Avoid error-prone and surprising constructs
  - Concede to practicalities when necessary

#### Rules must pull their weight

- 스타일 가이드로 추가되는 모든 것에는 비용이 따름.
- 새로 배워야 하고 적응해야 하며 기억해야 함.
- 따라서, 자명한 것들은 규칙에서 제외시키려 노력.
- 예를 들어 C++의 `goto` 사용 금지를 규칙으로 삼지는 않음.
- 이미 개발자들은 이를 피하려는 경향이 있는데, 굳이 규칙으로 넣는 것은 오버헤드.
- 한 두명의 잘못으로 만드는 규칙은 전체의 정신적 부담으로 이어짐. 이는 스케일링에 걸림돌.

#### Optimize for the reader

- 규칙의 또 다른 원칙은 코드의 저자가 아닌 독자에 최적화하라는 것.
- 코드는 작성되는 시간보다 읽히는 시간이 더 김.
- 예를 들어, 파이썬에서 조건문<sup>conditional expression</sup>이 `if` 문장보다 짧음.
- 하지만 읽기에는 더 어려움. 따라서 조건문의 사용을 금하고 있음.
- 같은 맥락으로 엔지니어들은 각자의 코드에 의도한 행위의 증거를 명시적으로 남겨야 함.
- 예컨대, Java, JavaScript, C++ 스타일 가이드에서는 슈퍼클래스 메서드를 오버라이드 할 때 override 애노테이션이나 키워드를 사용하도록 강제.
- API에는 상호작용을 충분히 추론할 수 있는 명확한 도큐먼트를 남김.
- 사용하려는 함수의 구현을 보지 않고도 알 수 있게 하는 것이 목적.
- 도큐먼트 주석(파일, 클래스, 함수 블럭 앞에 작성하는)는 코드의 설계나 의도를 담음.
- 구현 주석은 불명확한 선택을 강조하거나 정당화하고, 까다로운 부분을 설명하며, 코드의 중요한 부분을 드러냄.

#### Be consistent

- 구글에서는 어느 회의실에서도 화상 회의 설정은 동일한 인터페이스를 가짐.
- 새로운 설정을 배우느라 시간을 낭비하지 않아도 됨.
- 이는 소스 코드에 대해서도 마찬가지.
- 일관성은 어느 엔지니어든지 코드베이스의 익숙하지 않은 부분에 뛰어들게 하고 빠르게 일할 수 있게 도움.
- 각 프로젝트는 고유한 성격을 갖지만, 도구와 기술과 라이브러리는 모두 동일.

#### Advantages of consistency

- 일관성으로 인한 제약은 분명히 발생. 하지만 편익은 큼.
- 코드를 다룰 때도 일관성이 자유를 제한하는 것 같지만, 더 적은 노력으로 더 많은 일을 할 수 있게 도와줌.
- 일단, 코드를 작성하거나 읽을 때, 코드가 어떻게 표현되느냐보다 코드가 무엇을 하는지에 집중할 수 있음.
- 일관성은 스케일링을 돕기도 함. tooling이 조직 스케일링의 핵심인데, 일관성이 있으면 코드를 만들고 수정하고 이해하는 도구 작성이 쉬움.
- 엔지니어의 팀 간 이동에도 도움. 좀 더 빠르고 쉽게 코드에 적응.
- 시간이 흐름(엔지니어가 프로젝트를 떠나고, 새로운 사람이 들어오고, 오너십이 바뀌고, 프로젝트가 병합되거나 쪼개지고, ...)에도 탄력성을 유지.

#### Avoid error-prone and surprising constructs

- 구글 스타일 가이드는 언어에서 다소 놀랍거나 일반적이지 않거나 교모한 문법 사용을 제한함.
- 복잡한 피처는 종종 한 눈에 파악하기 어려운 함정을 가지고 있음.
- 이를 깊이 생각하지 않고 작성하는 것은 버그를 만들어 낼 수도.
- 작성 시에는 잘 고려가 되었더라도 이후에 이를 다루는 엔지니어에게도 문제.
- 파이썬 스타일 가이드의 경우 리플렉션 같은 [power features](https://google.github.io/styleguide/pyguide.html#219-power-features)를 금지.
- 파이썬에서의 `hasattr()`과 `getattr()`은 문자열로 객체의 속성에 접근할 수 있게 함.

```py
// some_file.py:
A_CONSTANT = [
'foo',
'bar',
'baz',
]

// other_file.py:
values = []
for field in some_file.A_CONSTANT:
values.append(getattr(my_object, field))
```

- `foo`, `bar`, `baz` 필드에 접근한다는 사실을 어떻게 알 수 있겠는가?
- 독자를 위한 어떠한 명확한 증거도 없음. 따라서 검증도 어려움.

#### Concede to practicalities

- 가끔 필요하다면 최적화나 실용성에 규칙을 포기하기도.
- C++ 스타일 가이드가 익셉션 사용을 금하고 있지만, 컴파일러 최적화를 위해 `noexcept`의 사용을 허용하기도.
- 성능 외에도 상호호환성 케이스도 존재.

### The Style Guides

- 언어 스타일 가이드에는 크게 3가지 범주가 있음.
- Rules to avoid dangers
- Rules to enforce best practices
- Rules to ensure consistency

#### Avoiding danger

- 스타일 가이드에는 언어 특징에 관련하여 기술적 이유로 해야 하는 것과 하지 말아야 할 것을 명시.
- 정적 멤버나 변수 사용, 람다 표현식 사용, 예외 처리, 스레딩 생성, 접근 제어, 클래스 상속 등.
- 사용하기 어렵거나 제대로 사용하기 어려운 것에 대한 규칙들도 포함.
- 각각의 규칙에는 장단점과 함께 결론에 이르기까지의 설명도 포함.

#### Enforcing best practices

- 소스 코드 작성의 베스트 프랙틱스들도 담고 있음.
- 이는 코드 베이스를 건강하고 유지보수 가능하게 도와줌.
- 예컨대, 코드 저자가 주석을 어디에 어떻게 남겨야 하는지를 가이드.
- 일반적인 주석 컨벤션을 기본으로 하고, 이를 좀 더 확장하여 의도가 불분명할 수 있는 곳에도 주석을 작성해야 함.
- switch 문이 완료되지 못하는 경우, 빈 예외 캐치 블럭, 템플릿 메타프로그래밍 등이 이에 해당.
- 그 외에도 소스 파일을 구조화하는 방법, 네이밍, 가독성을 위한 포맷팅 등 다양.
- 새롭거나 아직 잘 이해되어지지 않은 언어 피처는 제한을 둠.
- 만약 엔지니어가 이를 사용하고 싶다면 스타일 가이드 소유자에게 예시와 함께 토론하며 포함시킬 수도.

#### Building in consistency

- 사소한 것들도 스타일 가이드에 많이 포함되어 있음.
- 이들은 기술적으로 큰 영향을 가지는 것들이 아님.
- 네이밍 컨벤션, 들여쓰기 스페이싱, 임포트 순서 등.
- 무엇을 선택하든 다른 선택에 비해 큰 이점을 가지는 것도 아님.
- 하지만 하나를 선택함으로써 끝없는 논쟁 순환을 줄이고 앞으로 나아갈 수 있음.

## Changing the Rules

- 시간이 지나면서 스타일 가이드를 결정했던 배경 등이 계속 바뀜. 언어의 버전도 계속 올라감.
- 규칙이 다른 모습으로 바뀔 때가 되었는지를 알아차리는 것이 스타일 가이드를 계속 최신화해 나가는 중요한 프로세스의 일부.
- 주어진 결정의 추론을 문서화 해 두는 것은 무언가 바뀌어야 할 때를 인지하는 데 큰 도움이 됨.
- 과거의 좋은 결정이 지금은 그렇지 않을 수 있음.
- 그 외 내용은 기록 생략.

## Guidance

- 규칙<sup>rule</sup>에 더해 프로그래밍 안내<sup>guidance</sup>도 다양한 형태로 제공.
- 엔지니어링 경험의 지혜 모음이며, 그 동안 배운 교훈으로부터 추출한 베스트 프랙틱스를 문서화한 것.
- 규칙은 "must"이고 안내는 "should".
- 지침 풀의 한 예시는 자주 사용하는 랭기지들의 지침서.
- 스타일 가이드는 규범적이고 무엇을 해야 하고 하지 말아야 하는지를 강제하는 반면,
- 이 지침서는 피처들을 안내하고 설명함.
- 한 사례로, 새로운 코드베이스에서 사용해야 하는 언어에 익숙하지 않다면 "<Language>@Google 101" 코스 등을 밟는다고 함.

## Applying the Rules

- 규칙은 잘 시행되기만 하면 큰 가치를 가져다 줌.
- 규칙은 사회적으로(교육과 훈련을 통한) 또는 기술적으로(도구를 통한) 시행될 수 있음.
- 구글에선 규칙이 필요로 하는 베스트 프랙틱스들을 훈련시킬 여러 공식적 코스들이 존재.
- 또한 문서들을 정확하고 최신 상태로 유지할 수 있는 리소스를 꾸준히 투자.
- 코드 리뷰가 가이드나 규칙 학습에 중요한 역할을 수행.
- 물론 도구에 의한 자동 검증도 매우 중요.
- 자동화 된 도구는 또한 규칙이 해석되고 적용되는 방식의 편차를 최소화 시켜줌.
- 그리고 스케일링에도 도움.
- 하지만 모든 것을 도구로 해결할 수는 없음.
- 일부 기술적 규칙들은 확실히 살마의 판단을 필요로 함.
- 어떤 규칙들은 기술적이라기보다 사회적.
- 잘 정의하기 어렵고 도구로 해결하기에는 복잡하며 비싸질 수 있는 것들.
- 예를 들어, 한 번에 변경이 일어나는 크기를 작게 유지하는 것이 있음.
- 크기가 작으면 리뷰하기 쉽고 빠르며 더 통찰력 있께 살펴볼 수 있음.
- 버그를 만들어 낼 가능성도 적어짐.
- 하지만 작은 것의 명확한 정의는 어려움.
- 한 줄의 변경이 때로는 수백 줄의 변경보다 더 어려울 수 있음.
- 이런 것들은 도구로 자동화 하는 대신 사회적 해결을 통해 극복.

### Error Checkers

- 랭귀지 용법을 다루는 많은 규칙들이 정적 분석 도구로 시행 가능.
- C++의 경우 대략 90%까지 자동 도구로 검증할 수 있었다고 함.
- 자동화된 검증은 코드 저자가 많은 규칙을 기억해야 하는 부담을 덜어줌.
- 규칙 준수의 비용을 낮게 유지하면 엔지니어들이 좀 더 행복하게 이를 따라갈 수 있음.

### Code Formatters

- 일반적으로 스타일 체커와 포매터를 이용해서 코드의 일관된 포매팅을 수행.
- 한 가지 흥미로운 건 라인 길이에 대한 질문이 멈췄다는 것.
- 엔지니어들은 단지 스타일 체커를 실행하고 다음 단계로 넘어감.
- 코드 리뷰도 더 적은 비용으로 이뤄짐.
- 가장 규모가 큰 코드베이스를 매니징할 때, 사람이 수행한 포매팅과 자동화 된 도구를 이용한 결과를 비교한 적이 있음.
- 평균적으로 로봇이 더 나은 결과를 보였음.
- 때로는 매트릭스 포매팅 같이 도메인 지식이 중요할 때가 있으며 이 때는 사람이 더 나은 결과를 보임.
- 구글에선 이런 포매팅을 제출 전 체크에서 수행한다고 함.

# 9. Code Review

- 코드 리뷰의 정의는 단순하나, 코드 리뷰 프로세스의 구현은 매우 다양.
- 구글에서는 모든 변경이 커밋 전 리뷰를 받아야 하며, 모든 엔지니어는 리뷰를 시작하고 변경을 리뷰해야 하는 책임이 있음.
- 코드 리뷰는 일반적으로 프로세스와 도구의 지원 모두 필요.
- 구글에서는 Critique라는 도구를 사용하긴 하나,
- 이 챕터에서는 특정 도구보다는 프로세스를 집중적으로 다룸.
- 버그를 탐지하는 등의 코드 리뷰 이점은 잘 정립되어 있고 명확함.
- 그러나 감지하기 힘든 다른 이점들(심리적 효과를 비롯한)도 존재.

## Code Review Flow

- 코드 리뷰는 소프트웨어 개발의 많은 단계에서 일어남.
- 구글에서는 커밋 전에 변경을 리뷰하며, 이를 precommit review라고 부름.
- 코드 리뷰의 최종 목적은 다른 엔지니어에게 변경에 대한 동의를 얻는 것.
- 동의를 표현할 때 "looks good to me"(LGTM) 라고 태깅.
- 구글에서의 코드 리뷰는 아래의 단계로 이뤄짐.
  1. 저자가 코드베이스에 변경을 작성하고 리뷰 도구를 활용해 리뷰를 시작.
  2. 그리고 저자가 먼저 셀프 리뷰를 하거나 자동화 된 리뷰 코멘트를 확인. 저자가 만족했다면 1명 이상의 리뷰어에게 변경사항을 메일로 보냄.
  3. 리뷰어는 도구를 활용해 변경을 확인하고 코멘트를 남김. 일부 코멘트는 명시적인 해결을 요구. 어떤 것은 단지 정보 전달.
  4. 저자는 피드백을 반영하여 변경을 수정하고 다시 스냅샷을 업로드. 그리고 리뷰어에게 답장. 3~4단계는 계속 반복될 수 있음.
  5. 리뷰어가 만족한다면 LGTM과 함께 변경을 수락. 기본적으로는 1개의 LGTM만 받아도 통과.
  6. 변경이 LGTM으로 표기되면 저자는 변경을 코드베이스로 커밋.

## How Code Review Works at Google

- 코드리뷰의 대략적인 프로세스를 알아보았음.
- 하지만 디테일이 중요.
- 구글에서는 변경에 대해 "승인"을 필요로 하는 리뷰의 3가지 측면이 있음.
- 먼저, 정확성과 표현력에 대한 검사.
  - 코드가 적절한지, 저자가 주장한 동작을 하는지.
  - 종종 팀 멤버가 진행하지만 꼭 그래야 하는 것은 아님.
  - 승인 시 LGTM 권한 "비트"에 반영됨.
- 다음으로, 코드 소유자로부터의 적절성 여부 검사.
  - 구글에서는 코드베이스가 계층을 가진 트리 구조로 되어 있고,
  - 각 부분마다 소유자가 있음.
  - 보통 테크 리드나 특정 영역의 전문가.
  - 소유 권한을 얼마나 넓게 또는 얇게 가져가는지는 팀 마다 다름.
- 마지막은 언어의 "가독성"을 검사.
  - 스타일 가이드나 베스트 프랙틱스를 잘 따르고 있는지 확인.
- 이런 통제 레벨이 부담스럽게 여겨질 수도 있고 때로는 정말 그러기도 함.
- 그러나 보통은 한 사람이 이 3가지 역할을 수행하여 속도를 높임.
- 그리고 저자가 마지막 2개의 역할을 수행하기도.
- 보통은 2가지 단계를 거침. 동료 엔지니어로부터 1개의 LGTM을 얻고, 코드 소유자나 가독성 리뷰어에게 승인을 얻는 것.
- 이렇게 하면 코드리뷰를 2가지 관점에서 살펴볼 수 있게 하면서도 시간을 절약해 줌.

## Code Review Benefits

- 구글에서 코드 리뷰는 아무리 작은 변경이라고 하더라도 필수.
- 코드리뷰가 코드 변경의 속도를 늦추기도 하지만 그래도 필수.
- 장기적으로 더 큰 이점을 가져다 준다고 생각하기 때문.
- 아래의 6가지.
  - Checks code correctness
  - Ensures the code change is comprehensible to other engineers
  - Enforces consistency across the codebase
  - Psychologically promotes team ownership
  - Enables knowledge sharing
  - Provides a historical record of the code review itself

### Code Correctness

- 다른 내용은 일반적인 것들이었고 아래 내용이 기억에 남음.
- 정확성 평가가 주관적이 되는 것을 막기 위해, 저자의 접근 방식을 존중해야 함.
- 리뷰어는 개인적 의견 때문에 대안을 제시할 수 없음.
- 대안은 표현력(덜 복잡하게 하는 등)나 기능성(더 효율적이게 하는 등)을 향상시킬 수 있는 경우에만 제시.
- 일반적으로 엔지니어들은 완벽한 해결책에 대한 동의를 기다리기보다, 코드베이스를 향상시키는 변경에 대해 승인하도록 권장됨.
- 이는 코드 리뷰의 속도를 높임.

### Comprehension of Code

- 코드리뷰는 일반적으로 저자가 아닌 다른 사람이 변경을 검사하는 첫 번째 기회.
- 뛰어난 엔지니어라도 저자의 관점에 치우치느라 발견하지 못한 것을 리뷰어가 피드백 해 줄 수 있음.
- 코드리뷰는 변경이 더 많은 청중들에게 이해가능한지를 검사하는 첫 번째 테스트.
- 이는 코드가 작성보다 읽히는 데 더 많이 사용되기 때문에 매우 중요.
- 따라서 저자와는 다른 관점을 지닌 리뷰어를 찾는 게 도움이 됨.
- 리뷰어가 설계와 관련하여 저자에 대해 존중을 가져야 하는 것과 별개로,
- 저자는 "고객은 항상 옳다"는 마인드로 코드 표현력에 관한 리뷰어의 질문을 바라보아야 함.
- 지금 받은 질문들은 시간이 지나면서 다른 사람들에 의해서도 계속 반복될 것.
- 접근법이나 로직을 바꾸라는 것이 아님. 하지만 좀 더 명확하게 설명할 필요는 있음.
- 코드 정확성과 함께 코드 표현력은 LGTM의 주요 요소.

### Code Consistency

- 규모가 확장 됨에 따라 당신이 작성한 코드는 의존성을 가지며 유지보수도 이뤄짐.
- 많은 사람들이 당신의 코드를 읽고 이해해야 함.
- 따라서 코드는 일관성 표준을 따라야 하고, 과도하게 복잡한 것도 피해야 함.
- 리뷰어들은 이 코드가 코드베이스의 표준에 따라 얼마나 잘 살아갈 수 있는지(코드의 건강) 평가해야 함.
- 정확성과 표현력을 나타내는 LGTM과 별개로 코드 가독성은 유지보수를 위한 것.
- 특정 프로그래밍 언어를 위한 베스트 프랙틱스를 잘 따랐는지, 구글 코드 리포지토리의 언어들과 일관성을 갖췄는지 등을 평가.

### Psychological and Cultural Benefits

- 코드리뷰는 중요한 문화적 이점도 가짐.
- 신입 때 느꼈던 코드리뷰의 가장 큰 이점.
- 소프트웨어 엔지니어들에게 코드가 "그들의 것"이 아님을 인지하게 함.
- 자신의 결과물을 자랑스럽게 여기고 비판을 꺼리는 것은 인간의 본성.
- 코드리뷰는 이런 비판의 감정적 완충 작용을 하기도.
- 좀 더 정제되고 중립적인 비판을 주고 받도록 돕기 때문.
- 코드리뷰의 또 다른 심리적 이점은 "validation".
- 자신에게 너무 비판적인 경우 이 validation은 안정감을 제공.
- 마지막으로 코드리뷰를 시작하기 전 한 번 더 변경에 대해 신경쓰게 됨.
- 나중으로 미룰 수도 있었던 단위 테스트를 마무리 하고 코드리뷰를 올리는 등.

## Code Review Best Practices

- 코드리뷰는 조직에 마찰과 지연을 가져올 수도.
- 이는 코드리뷰 그 자체의 문제라기 보단, 어떤 코드리뷰 구현을 골랐느냐의 문제.
- 코드리뷰를 가치 있는 프로세스로 자리 잡게 하려면 몇 가지 베스트 프랙틱스가 필요.
- 이들 대부분은 프로세스를 민첩하고 빠른 상태로 유지시켜 스케일링에 유리하게 해 줌.

### Be Polite and Professional

- 신뢰와 겸손의 구글 문화는 코드리뷰에도 적용.
- 예컨대, 코드 표현력에 관해서는 단지 한 명의 다른 엔지니어로부터 LGTM을 얻는 것으로 충분.
- 엔지니어들은 추가적인 리뷰 단계 없이, 변경 사항이 제출될 수 있다는 것을 이해하고 코멘트와 LGTM을 남김.
- 일반적으로, 리뷰어는 저자의 접근 방식을 존중해야 하고, 저자의 접근법에 결점이 있을 때만 이를 지적해야 함.
- 만약 저자가 다른 접근법들이 동일하게 유효함을 증명할 수 있다면, 리뷰어들은 저자의 선호를 받아들여야만 함.
- 각 접근법에서 결점이 발견된다고 하더라도 저자나 리뷰어 모두 리뷰를 배움의 기회로 삼을 수 있음.
- 리뷰어는 저자의 특정 접근법에 기반하여 성급하게 결론으로 넘어가는 것을 유의해야 함.
- 접근법이 잘못됐다고 가정하기 전에, 왜 이 방식으로 되었을지 질문하는 것이 좋음.
- 리뷰어는 코드리뷰를 24시간 내에 해야 함.
- 만약 이 시간 내에 할 수 없다면, 최소한 변경 사항을 보았고 가능한 빠른 시간 내에 리뷰를 할 것이라고 응답해 주는 것이 좋은 프랙틱스.
- 리뷰어는 조금씩 나눠서 코드 리뷰를 하면 안 됨. 이는 저자에게 고통.
- 리뷰어 뿐만 아니라 저자에게도 전문성이 요구됨.
- 코드는 당신의 것이 아니라 팀의 것. 한 번 코드베이스에 들어가면 더 이상 당신의 것이 아님.
- 당신의 접근법에 대한 질문에 열려 있어야 함.
- 왜 그 방식을 취했는지 설명할 준비가 되어 있어야 함.
- 저자의 책임 중 하나는 코드를 이해 가능하고 미래에도 유지 보수 가능한 상태로 유지하는 것.
- 각 리뷰어의 코멘트를 TODO 아이템으로 간주하는 것은 중요.
- 무조건 리뷰 코멘트를 수용해야 하는 것은 아니지만 최소한 다뤄지긴 해야 함.
- 만약 코멘트에 동의하지 않는다면 리뷰어에게 이를 알리고 왜 resolved로 마킹하지 않는지 설명.
- 이런 논쟁이 일어날 때 정중함이 유지되게 하고자 PTAL(please take another look)을 부탁하는 것도 방법.
- 코드리뷰는 저자와 리뷰어 모두에게 배움의 기회임을 기억. 동의하지 않는 것으로부터 인사이트를 종종 얻기도 함.

### Write Small Changes

- 변경을 작게 가져가는 것이 코드리뷰를 민첩하게 유지하는 데 가장 도움되는 프랙틱스.
- 구글에선 규모가 큰 변경은 권장하지 않으며, 리뷰어는 너무 큰 변경은 정당하게 거절할 수 있음.
- 여기서 "작은" 변경은 일반적으로 200라인이 넘지 않는 코드를 가리킴.
- 참고로, 구글에서 변경들의 35% 이상이 한 파일에 대한 것이라고 함.
- 변경이 작을수록, 리뷰를 기다리는 시간을 줄이고, 읽기도 쉽고, 버그를 찾아내기도 쉽고, ...
- 하지만 새로운 메이저 기능 개발 등 때로는 작은 변경의 강제가 오버헤드가 되기도 함.
- 때로는 큰 변경도 허용하는 것이 도움이 될 것.

### Write Good Change Descriptions

- 변경 설명의 첫 줄에는 요약의 의미로 변경 유형을 명시해야 함.
- 첫 줄은 매우 중요. 코드리뷰 툴에서 보이는 제목이기도 하며, 이메일의 제목, 코드 히스토리 요약 등에 표기.
- 설명에는 세부적인 내용도 담겨 있어야 함. "Bug fix"는 리뷰어나 미래 코드 독자에게 도움 X.
- 여러 수정이 일어난다면 열거해서 알려줘야 함.
- 설명은 변경의 역사적 자료이며, 구글의 코드 서치 같은 도구에서 내용 검색에도 활용되고, 이후의 버그 픽스에 유용한 도움이 됨.
- 변경의 설명 뿐만 아니라 구현 곳곳에도 의도가 제대로 드러나지 않는 부분이 있다면 주석을 사용하라는 이야기도.

### Keep Reviewers to a Minimum

- 구글에서 대부분의 코드리뷰는 리뷰어가 1명.
- 1명에 의해 코드 정확성, 소유자의 승인, 언어 가독성 검사가 이뤄지기에, 조직 규모 확장에도 잘 녹아들 수 있음.
- 리뷰어가 많으면 여러 통찰력을 이끌어낼 수 있긴 함.
- 하지만 이는 결과적으로 마이너스.
- 가장 중요한 LGTM은 첫 번째 것이며, 이후의 것들은 당신이 생각하는 만큼의 가치를 더해주지 않음.
- 추가 리뷰어들의 비용은 그것이 가져다 주는 가치를 빠르게 넘어가버림.
- 코드리뷰 프로세스의 최적화는 엔지니어가 올바른 일을 할 것이라는 신뢰를 바탕으로 함.
- 때로는 여러 리뷰어가 참여하는 게 좋기도 함. 이 경우에는 각 리뷰어가 서로 다른 관점으로 리뷰를 진행해야 함.

### Automate Where Possible

- 코드리뷰는 사람 프로세스이며 사람의 입력이 중요.
- 하지만 자동화 될 수 있는 부분이 있다면 그렇게 해야 함.
- 대표적인 예는 변경에 대한 정적 분석.
- 구글에서는 코드리뷰 도구가 presubmit이라 부르는 단계에서 여러 자동화를 수행.
- 문제가 없는지를 감지하고 필요하면 변경을 거절. 그리고 저자에게 이 문제를 해결하라고 알림.
- 이는 코드리뷰 프로세스 자체를 돕기도 하지만, 리뷰어들이 보다 중요한 것에 집중할 수 있게 도와줌.

## Types of Code Reviews

- 코드리뷰 마다 유형이 있으며, 각각에 맞는 방식을 취해야 함.
- 보통 아래 유형 중 하나.
  - Greenfield reviews and new feature development
  - Behavioral changes, improvements, and optimizations
  - Bug fixes and rollbacks
  - Refactorings and large-scale changes

### Greenfield Code Reviews

- 가장 흔치 않은 코드리뷰 유형은 완전히 새로운 코드(따라서 greenfield 리뷰로 불림).
- 그린필드 리뷰는 코드가 시간 테스트를 이겨낼 수 있는지를 판단하는 가장 중요한 시간.
- 시간 테스트라 함은 시간이 흐르고 규모가 커지고 내재된 가정이 바뀌는 변화에도 코드가 쉽게 유지될 수 있는냐에 대한 것.
- 새로운 코드의 도입은 단지 대안을 제공하는 것이 아니라 실제 문제를 해결해야 함.
- 구글에서는 새로운 코드가 필요할 때 대규모의 디자인 리뷰를 거침.
- 이는 코드리뷰와는 별개. 코드리뷰에서는 과거에 결정된 디자인 결정에 대해 논쟁 하지 않음.
- 코드의 지속 가능성을 보장하고자 그린필드 리뷰는 API가 합의된 디자인에 부합하는지 확인.
- 그리고 완전히 테스트 되어야 함. 모든 API 엔드포인트가 단위 테스트를 가지는 것.
- 더불어, 코드는 적절한 소유자를 가져야 하고, 충분한 주석이 달려 있어야 하며, 추가적 문서들도 필요하면 제공되어야 함.

### Behavioral Changes, Improvements, and Optimizations

- 대부분의 코드 변경은 이미 존재하고 있는 코드에 대한 수정.
- API 엔드포인트의 수정, 기존 구현의 개선, 성능 등의 요소에 대한 최적화 등이 이에 해당.
- 그린필드에 적용되었던 가이드라인이 여기에도 적용됨.
  - 이 변경이 꼭 필요한 것인지?
  - 이 변경이 코드베이스를 더 향상시키는지?
- 때로는 코드 삭제가 최고의 개선이 되기도 함.
- 행위의 수정은 필연적으로 적절한 테스트의 수정도 동반.
- CI를 통해 회귀영향은 없는지도 확인.
- 이는 최적화에도 필요한 것들.
- 최적화에는 리뷰어가 조언을 할 수 있도록 추가적으로 성능 벤치마크도 필요.

### Bug Fixes and Rollbacks

- 필연적으로 버그 수정 변경을 제출하게 됨.
- 이 때는 다른 이슈를 함께 다루려는 유혹을 피해야 함.
- 이는 코드 리뷰의 크기를 늘리고, 회귀 영향 테스트도 어렵게 만들며, 롤백도 힘들어짐.
- 버그 수정은 그 자체에만 집중해야 하고, 관련된 테스트만 함께 수정.
- 버그는 보통 현재의 테스트가 충분하지 않음을 드러내며,
- 따라서 버그 수정의 리뷰어는 단위 테스트도 함께 수정되었는지 물어보는 것이 중요.
- 때때로 구글처럼 큰 규모의 코드베이스에서 일어나는 수정은 예상치 못한 의존성 실패를 일으키기도 함.
- 이 경우 롤백을 허용하며, 이전 변경의 리버트라고 하더라도 코드리뷰는 여전히 필요.
- 잠재적 롤백 가능성을 가진 어떤 변경이든 가능한 작고 원자적이어야 함.
- 그래야 롤백 시 추가적 문제를 일으킬 가능성이 적고, 빠르게 롤백 수행도 가능.

### Refactorings and Large-Scale Changes

- 제목이랑 내용이랑 매칭이 잘 안 됨.
- 사람이 아닌 기계가 만들어 내는 코드 변경들이 있으며,
- 이 경우에도 비슷하게 코드리뷰를 진행한다는 이야기.

# 11. Testing Overview

- 2000년대 이후로 개발자 주도의 자동화된 테스트가 급속도로 발전.
- 이는 버그를 방지해 주고, 특히 좀 더 빠른 개발 단계에 버그를 발견하게 도와 비용 절감으로 이어짐.
- 이뿐만 아니라, 테스트는 소프트웨어가 계속 바뀔 수 있도록 도와줌.
- 새로운 피처의 추가, 코드 건강을 위한 리팩토링, 규모가 있는 재설계 등에 도움.
- 더 빠르게 반복(iterate)하는 회사일수록 더 빠르게 기술이나 시장 상황, 고객 취향에 더 신속하게 대응할 수 있음.
- 이때 견고한 테스팅 프랙틱스를 갖고 있다면 많은 도움이 됨.
- 테스트 작성은 시스템 설계 개선에도 영향.
- 예컨대, 데이터베이스와의 커플링이 너무 크지는 않는지 등.
- 이 역시 개발 주기의 이른 단계에 도움이 됨.

## Why Do We Write Tests?

- 테스트가 무엇인지부터 설명.
- 시스템에 입력값을 전달하고 결과를 검증하는 것.
- 이를 통해 시스템이 기대한 대로 동작하는지를 알 수 있음.
- 테스트를 만들고 관리하는 것은 정말 많은 노력이 수반됨.
- 코드베이스가 자라나면, 테스트 세트 역시 자라남.
- 그러면서 느림과 불안정 문제들의 도전에 직면.
- 이 문제들을 제대로 처리하지 못하면 오히려 테스트가 걸림돌.
- 테스트의 가치는 엔지니어들이 신뢰에서 비롯됨.
- 만약 테스트가 느려지고 불확실성을 가지기 시작하면, 생산성에 저해가 되고,
- 엔지니어로부터의 신뢰를 잃게 되고, 제2의 해결책들을 찾게 됨.
- 나쁜 테스트는 테스트가 없는 것 보다도 안 좋을 수 있음.
- 테스트는 회사가 훌륭한 제품을 빠르게 만들 수 있도록 도와줄 뿐 아니라,
- 제품과 서비스가 우리 생활에 안전을 보장하는 데도 큰 역할.
- 소프트웨어의 결함은 단순한 성가심을 넘어, 막대한 비용이나 재산, 생명의 손실로 이어질 수도.
- 구글에서는 테스트가 차후에 이뤄지는 것이 아니라, 주요한 일 중의 하나라고 결정.
- 좋은 품질의 빌드가 실패하면 이는 필연적으로 나쁜 결과로 이어짐을 배움.
- 엔지니어링 문화의 핵심에 테스트가 존재.

### The Story of Google Web Server

- 구글 초기에는 테스트 중요성이 약했다고 함.
- 똑똑한 사람들에 의존해서 소프트웨어를 만들려는 경향.
- 이로 인한 문제는 특히 GWS라고 불리는 구글 웹 서버에서 두드러짐.
- 2005년에 제품은 점점 더 커지고 복잡해졌고 생산성은 급격히 악화.
- 릴리즈는 버그를 만들어냈고 커밋은 점점 더 오래 걸림.
- 팀원들은 변경을 두려워했고, 새로운 기능이 운영 환경에 나가고 나서야 문제가 있음을 인지하곤 함.
- 이 문제를 해결하고자 TL은 엔지니어 주도의 자동화 된 테스트 정책 도입을 결정.
- 모든 새로운 코드 변경에는 테스트가 포함되어야 하며 이들 테스트는 지속적으로 실행 됨.
- 정책 도입 후 1년 동안 긴급 푸시가 절반으로 줄어듦.
- 이는 코드 변경은 계속 늘어나는 추세 속에 일어난 일.
- 전례 없는 성장과 변화 속에서도 테스팅은 생산성과 자신감을 가져다 줌.
- 오늘날 GWS는 수만 개의 테스트를 가지고 있으며,
- 거의 매일 릴리즈가 일어나고 고객이 경험하는 실패는 거의 없음.
- 이는 구글의 테스트 문화에 분수령이 됨.
- 제품의 결함을 피하는 데에 프로그래머의 역량에 의존해서는 안 됨.
- 개별 엔지니어가 비록 버그를 잘 안 만들어 낸다고 하더라도,
- 같은 프로젝트에 많은 사람들이 함께 하게 되면 결함은 계속 늘어남.
- 훌륭한 팀은 멤버들의 집단 지성의 전체 팀의 이득으로 바꾸는 방법을 찾아냄.
- 대표적인 예가 바로 자동화 된 테스트.
- 한 명의 개발자가 테스트를 작성해 두면 이는 다른 사람도 이용 가능한 공동의 재산이 됨.
- 다른 팀원들은 이 테스트를 실행하는 것으로 결함이 발생했는지를 알 수 있음.
- 하지만 이 테스트가 없다면 각 엔지니어들은 반복적으로 디버거와 함께 문제를 찾아내야 함.
- 때로는 문제 자체를 뒤늦게 감지하거나 아예 못할 수도.

### Testing at the Speed of Modern Development

- 사람이 매번 직접 시스템 행위를 검증하는 것은,
- 기능과 플랫폼의 폭발적 증가를 따라잡을 수 없음.
- 자동화 없이는 스케일링에 어려움.

### Write, Run, React

- 순수한 형태의 자동화 테스팅은 3가지 활동으로 이뤄짐.
- 테스트의 작성, 테스트의 실행, 테스트 실패에 반응.
- 여기서 테스트란, 테스트 하고 싶은 전체 시스템 중 격리된 일부(메서드나 함수)를 호출하는 작은 코드 조각.
- 테스트 코드는 예상되는 환경을 구축하고 정해진 입력 값으로 시스템을 호출하여 그 결과를 검증.
- 테스팅과 테스트 용어를 구분해서 사용하고 있음에 유의.
- 오늘날에는 시스템을 만드는 엔지니어가 자신의 코드에 대한 자동화 된 테스트를 작성하고 실행하는 데 보다 능동적이고 통합적인 역할을 수행.
- 오늘날의 시스템 개발 속도와 규모의 확장에 있어 필수.
- 물론, 테스트를 작성하는 것은 좋은 테스트를 작성하는 것과는 다름. 이는 뒤이어 다룰 예정.
- 테스트의 작성은 자동화 된 테스트 프로세스의 첫 번째 단계에 불과.
- 테스트 작성을 했다면 이를 실행해야 하는데, 자동화를 통해 반복적이고 지속적으로 검증.
- 단지 무언가 깨졌을 때 사람의 관심이 필요.
- 테스트를 코드로 작성해 두는 것의 또 다른 이점은, 그것이 모듈화 되어 있기에, 브라우저나 다국어 등 여러 환경에서 반복 수행하기 좋다는 것.
- 계속 변화하는 제품이나 서비스는 테스트 실패를 필연적으로 경험.
- 테스트 프로세스가 얼마나 효과적인지는 이 테스트 실패를 다루는 데에 달려있음.
- 실패 후 수 분 이내로 수정하도록 우선순위를 조정해야 하며, 이를 통해 제품의 높은 신뢰도를 달성.

### Benefits of Testing Code

생산성과 속도를 높이기 위해 테스트를 작성한다는 것이 모순적으로 들릴 수도. 기능을 구현하는 시간만큼 테스트 작성에도 써야 하기 때문. 하지만 구글에선 테스트가 생산성에 있어 아래와 같은 주요 이점을 제공함을 발견.

**Less debugging**

- 테스트 코드와 함께 작성된 코드는 결함이 적음.
- 게다가, 처음 만들어진 이후 유지되는 동안에도 계속 그러함.
- 한 번 작성된 테스트는 꾸준히 이득이 되고, 결함 비용과 괴로운 디버깅을 예방.
- 테스트를 깨뜨리는 변경은 테스트 인프라에 의해 감지되고 프로덕션에 나가기 전에 롤백 됨.

**Increased confidence in changes**

- 시스템의 중요한 행위들이 지속적으로 검증됨.
- 이는 변경에 대한 자신감으로 이어짐.
- 리팩토링도 장려하게 됨.

**Improved documentation**

- 소프트웨어 문서는 믿을 수 없기로 악명 높음.
- 한 번에 한 가지 행위만 수행하는 테스트는 실행 가능한 문서로써 동작.
- 코드가 특정 케이스에 하는 일을 알고 싶다면 그 테스트 케이스를 보면 됨.
- 좀 더 나아가, 요구사항이 변할 때 새로운 코드는 기존의 테스트를 깨뜨림.
- 문서화가 낡았다는 신호가 되고 다시 올바르게 동작하는 문서로 함께 수정.
- 물론, 테스트가 깨끗하고 간결하게 유지되어야 좋은 문서로써 동작함에 유의.

**Simpler reviews**

- 구글에서의 모든 코드는 적어도 1명 이상의 다른 엔지니어에 의해 리뷰됨.
- 만약 충분한 테스트가 리뷰에 포함되어 있다면 리뷰어는 좀 더 효율적 코드 검증이 가능.

**Thoughtful design**

- 테스트 작성이 어려운 것은 종종 코드가 너무 많은 책임을 갖고 있거나 종속성 관리가 어려운 것.
- 잘 설계된 코드는, 모듈화가 잘 되어 있어야 하고, 강결합을 피하고, 구체적 책임에 집중되어 있어야 함.
- 설계 이슈를 초기 단계에 수정할수록 나중의 일을 더 줄여줌.

**Fast, high-quality releases**

- 테스트가 있으면 안정감을 갖고 새로운 애플리케이션 버전을 출시할 수 있음.
- 구글의 많은 프로젝트들은 (그것이 아무리 큰 프로젝트라고 해도) 매일 매일 새로운 코드가 프로덕션에 배포.
- 자동화된 테스트가 없었다면 이것은 불가능.

## Designing a Test Suite

- 큰 규모의 테스트는 느리고 디버그 하기 어려움.
- 그래서 더 작게 개발하고 더 작게 테스트하기 시작.
- 더 빠르고, 더 안정적이며, 일반적으로 덜 고통스러워짐.
- 이런 상황은 "작다"는 것이 정확히 무엇을 의미하냐는 논쟁으로 이어짐.
- 모든 테스트 케이스에는 두 가지 관점이 있음.
- 크기<sup>size</sup>와 범위<sup>scope</sup>.
- 크기는 테스트 케이스 실행을 위해 필요한 리소스들(메모리, 프로세스, 시간).
- 범위는 검증하려는 특정 코드 경로를 가리킴(말이 어렵지만 뒤이어 소개됨).

### Test Size

- 구글에서는 모든 테스트를 크기로 분류하며,
- 개발자들은 가능한 작은 테스트를 작성하도록 권장 받음.
- 테스트 크기는 라인 수에 의해 정해지지 않음.
- 대신, 실행 방식, 수행 작업, 소비하는 자원에 의해 정의됨.
- 작은 테스트는 단일 프로세스에서, 중간 정도 크기의 테스트는 단일 장비에서, 큰 테스트는 필요에 따라 여러 장비를 거쳐가며 수행되는 것을 가리킴.
- 이런 구분을 전통적인 "단위" 또는 "통합" 테스트 분류 대신 사용함.
- 궁극적 목표는 더 적은 자원과 인프라를 사용해서 더 빠르고 더 결정적인 테스트의 작성이기 때문.
- 작은 테스트는 속도와 결정적 특성을 더 잘 만족시킴.
- 중간 크기의 테스트는 좀 더 유연하지만 비결정적 리스크를 가짐.
- 큰 큐모의 테스트는 오로지 가장 복잡하고 어려운 테스팅 시나리오에서만 허용됨.

#### Small tests

- 작은 테스트는 세가지 규모의 테스트 중 가장 제약이 많음.
- 주요 제약은 단일 프로세스에서 실행되어야 한다는 것.
  - 이 제약은 단일 스레드까지 확장되곤 함.
  - 테스트에서 데이터베이스 같은 써드 파티 프로그램을 실행시키지 않는다는 의미이기도.
- 작은 테스트의 또 다른 중요 제약은 슬립이나 I/O 연산, 블럭킹 호출이 허용되지 않는 것.
  - 네트워크나 디스크 접근 X.
  - 이런 코드에 의존하는 테스트에는 테스트 더블이 필요.
- 이 제약들의 목적: 작은 테스트가 느려지거나 비결정적이 되는 것을 방지.
- 처음에는 이 제약들이 과하다고 느껴질지도 모름.
- 그러나 하루에도 몇 번씩 수행되는 테스트 집합을 생각해보라.
- 만약 이런 테스트 집합이 비결정적으로 실패한다면?
- 가능한 작은 테스트를 작성하길 권장.
- 전체 테스트 수트를 빠르고 신뢴성 있게 유지시켜 줄 것.

#### Medium tests

- 많은 흥미로운 종류의 테스트에서 작은 테스트는 너무 제약적일 때가 있음.
- 중간 규모의 테스트는 여러 프로세스, 스레드, 블럭킹 호출, `localhost` 네트워크 호출 등을 포함.
- 남아 있는 유일한 제약은 `localhost`가 아닌 곳으로의 네트워크 호출하면 안 된다는 것.
- 즉, 단일 장비 제약.
- 이 규모의 테스트에서는 많은 가능성들이 열림.
- 예컨대, 좀 더 실제 설정에서 통합이 잘 되는지 확인하기 위해 데이터베이스 인스턴스 실행을 할 수도 있음.
- 또는 웹 UI와 서버 코드의 조합을 테스트 할 수도 있음.
- 하지만, 늘어난 유연성은 더 느려지고 더 비결정적인 테스트를 만들어 낼 수 있음.
- OS나 써드 파티 프로세스들의 영향을 받기 때문.
- 이들은 일반적으로 우리가 보장할 수 있는 대상들이 아님.

#### Large tests

- `localhost` 제약도 없어지는 테스트.
- 여러 장비의 사용이 허용.
- 예컨대, 테스트가 원격 클러스터를 대상으로 수행되기도.
- 늘어난 유연성은 늘어난 리스크를 가져옴.
- 더 느려지고 더 비결정적.
- 이는 코드 조각을 테스트하기 위해서가 아니라,
- 설정을 검증하거나 테스트 더블을 사용할 수 없는 레거시의 코드 검증을 위한 경우에 사용.
- 구글에서 대규모 테스트는 중간/작은 테스트와는 독립시켜서, 빌드나 릴리즈 프로세스에서만 실행함.
- 개발 워크플로우에 주는 영향을 피하기 위함.

#### Properties common to all test sizes

- 모든 테스트는 밀폐<sup>hermetic</sup>되어야 함.
- 환경을 준비하고, 테스트를 실행하고, 다시 환경을 정리하는 일련의 정보가 하나의 테스트 안에 담겨 있어야 함.
- 테스트 실행 순서 등의 바깥 환경에 대해서는 가능한 적게 가정해야 함.
- 또 다른 예로, 공유 데이터베이스에 의존하지 말아야 함.
- 한편, 테스트는 실행에 꼭 필요한 정보만을 담아야 함.
- 이는 리뷰어가 코드를 검증하는 데 도움이 되며,
- 테스트 실패 시 분석하는 데도 도움이 됨.
- "a test should be obvious upon inspection"
- 같은 맥락으로, 조건문이나 루프 같은 흐름 제어 명령문을 테스트에서는 사용하지 않기를 강하게 권장.
- 테스트 흐름이 복잡할수록 버그를 담기 쉽고 테스트 실패 원인 분석에 어려움.

### Test Scope

- 테스트 규모 외에 또 다른 중요 고려 요소는 테스트 범위.
- 여기서 범위는 얼마나 많은 코드를 검증하려는지를 가리킴.
- 좁은 범위의 테스트(보통 단위 테스트라 부름)는 개별 클래스나 메서드처럼 작고 집중된 코드베이스 부분의 로직을 검증.
- 중간 범위의 테스트(보통 통합 테스트라 부름)는 서버와 데이터베이스 사이의 연동처럼 적은 갯수의 컴포넌트들의 상호작용을 검증.
- 큰 범위의 테스트(기능 테스트, 종단간 테스트, 시스템 테스트 등으로 부름)는 몇 개의 구별된 시스템 부분들의 상호작용을 검증.
- 한 가지 중요한 것은 범위라는 게 실행되는 코드의 양이 아니고, 검증하려는 코드의 크기라는 것.
- 구글에서는 테스트 더블을 사용하기 보다, 가능하다면 진짜 의존성을 사용하는 것을 선호.
- 보통 좁은 범위의 테스트는 작은 테스트이고, 넓은 범위의 테스트는 중간 또는 큰 규모의 테스트인 경향이 있음.
- 작은 범위의 테스트와 마찬가지로 좁은 범위의 테스트를 권장.
- 대략적인 가이드라인에서는 이 테스트들의 조합 비율을 아래와 같이 추구.
  - 80%: 대부분의 비즈니스 로직을 검증하는 좁은 범위의 단위 테스트.
  - 15%: 두 개 이상의 컴포넌트 간 상호작용을 검증하는 중간 범위의 통합 테스트.
  - 5%: 전체 시스템을 검증하는 종단간 테스트.

![The Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid/testPyramid.png)

- 이 그림에 반하는 안티패턴은 "아이스크림 콘"과 "모래시계".

![Software Testing Icre Cream Cone Antipattern](http://i.imgur.com/vybOi1x.jpg)

![Software Testing Hourglass Antipattern](https://1.bp.blogspot.com/-e6bsyqU1yt8/X48dcQU9uLI/AAAAAAAAAbM/Ct-p0T6Y728g_gyHYZ_DWT6Ks2MPhrgfwCLcBGAsYHQ/s320/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25281%2529%2B-%2BEdited.jpg)

- 이 테스트 조합 비율은 2가지 목적에 따라 결정지어짐.
- 바로 엔지니어 생산성과 엔지니어 안정감.

### The Beyonce Rule

- The Beyonce Rule이 뭔지 저번에도 찾아보았는데 이번에도 까먹고 또 찾아봄.
- 싱글 레이디 가사의 한 부분을 테스트로 바꾼 것.

> "If you liked it, then you shoulda put a test on it"

- 새로운 사람이 들어오면 종종 어떤 속성과 행위를 테스트해야 하는지 질문 받음.
- 가장 직관적인 대답은 "당신이 깨뜨리고 싶지 않은 모든 것을 테스트하라".
- 자동화 된 테스트를 통해 시스템이 올바른 일을 수행하는지에 대한 확신이 가능.
- 테스팅 성능, 행위 정확성, 보안, 접근성 등도 일반적으로 의심하는 것들도 포함되며,
- 시스템이 실패를 어떻게 다루는지와 같은 다소 덜 명확한 속성도 포함.

### A Note on Code Coverage

- 코드 커버리지가 테스트 품질의 중요한 지표로 인식될 때가 있음.
- 하지만, 몇 개의 테스트만으로도, 많은 코드 라인을, 별다른 검증을 하지 않으면서 실행할 수 있음.
- 코드 커버리지가 단지 코드 라인이 호출됐는지만을 측정하기 때문.
- 그래서 작은 테스트에 대해서만 커버리지 측정하는 것을 권장.
- 큰 테스트의 실행은 커버리지 인플레이션을 유발.
- 코드 커버리지의 또 한 가지 문제점은 그 자체로 목표가 되어 버린다는 것.
- 예컨대, 처음엔 이상적으로 80%를 목표로 잡지만, 엔지니어들은 점차 80%까지만 커버리지를 맞추고 말게 됨.
- 때로는 그 이상이 도움이 되는 경우임에도 멈추게 되는 것.
- 더 좋은 테스트 품질 접근법은 테스트 되는 행위에 대해 생각하는 것.
  - 당신의 고객이 기대하는 대로 제품이 동작함을 확신할 수 있는가?
  - 의존성 변경이 일으키는 문제를 감지할 수 있다고 생각되는가?
  - 테스트가 안정적이고 신뢰할 만한가?
- 코드 커버리지가 테스트 되지 않고 있는 코드에 대한 인사이트를 줄 순 있음.
- 그러나 시스템이 얼마나 잘 테스트 되고 있는지에 대한 중요한 도구는 아님.

## Testing at Google Scale

- 대부분은 어느 규모의 코드베이스에도 적용되는 가이드들.
- 하지만, 구글 코드는 규모가 크고 단일 리포지토리에서 유지된다는 특징에 기반.
- 매주 2,500만줄의 코드가 바뀜. 이 중 절반은 엔지니어에 의해, 나머지는 자동화 된 시스템에 의한 변경.

### The Pitfalls of a Large Test Suite

- 코드베이스가 커질수록 기존 코드의 변경은 불가피.
- 잘 깨지는<sup>brittle</sup> 자동화 테스트는 이런 변경을 어렵게 만듦.
- 너무 많은 예상 결과를 명시하거나, 복잡하고 많은 보일러플레이트 코드에 의존하는 것들이 그 예.
- 이렇게 되면 관련 없는 변경에도 영향받기 쉬움.
- 팀은 점점 코드베이스 건강을 위한 리팩토링이나 변경을 꺼리게 됨.
- 최악 중 하나는 목 객체의 오용이며, 구글에서 이 문제로 엔지니어가 "no more mocks!"를 선언하기도.
- 한편, 깨지기 쉬운 테스트 코드 외에도, 테스트 규모가 커질수록 느려지는 문제도 있음.
- 느려질수록 덜 실행되고, 그것이 주는 이점은 점점 줄어듦.
- 좀 더 빠른 하드웨어나 병렬 수행 등을 할 수 있으나, 느린 개별 테스트가 점점 많아진 경우까지 대응할 순 없음.
- 테스트가 느려지는 이유는 여러가지.
  - 시스템의 너무 많은 부분을 부팅
  - 많은 데이터 셋을 처리
  - 타 시스템과 동기화를 기다림
  - `sleep`이나 `setTimeout`
- 규모가 큰 테스트케이스와 잘 살아가는 비법은 이를 존중하는 것.
  - 테스트를 프로덕션 코드처럼 취급.
  - 엔지니어가 테스트를 신경쓰도록 장려.
  - 기능 개발과 마찬가지로 테스트에 대한 보상도 제공.
  - 적절한 성능 목표를 설정하고, 느리거나 중요치 않은 테스트를 리팩토링.
  - 간단한 변경에도 시간이 꽤나 소요된다면, 테스트를 덜 취약하게 만들어야 함.
- 테스트에 적절한 문화를 만드는 것 외에도, 테스트 환경을 꾸준히 개발.
  - 린터를 만들고 문서를 작성하는 등의 노력을 통해 나쁜 테스트 작성을 어렵게 만듦.
  - 테스트를 위한 도구가 너무 많아지는 것을 방지. 구글에선 1개의 표준 테스트 프레임워크와 표준 목킹/스터빙 라이브러리를 사용.
  - 한 가지 인프라 세트로 모든 언어들의 대부분의 테스트 케이스를 수행.

## History of Testing at Google

4가지 단계를 이야기 하는데, 그 중 마지막 것만 정리.

### Testing Culture Today

- 새로 입사한 구글러들은 테스팅 오리엔테이션 클래스에 참석.
- TotT(Testing on the Toilet: 테스트에 관한 인식을 높이고자 화장실에 관련된 글들을 붙여 놓는 것)도 매주 꾸준히 배포.
- 모든 변경은 코드리뷰를 거치며, 이 변경에는 기능과 더불어 테스트가 포함됨.
- 리뷰어는 테스트 코드 역시 품질과 정확성 검사.
- 테스트 없는 변경은 리뷰 거부 대상.
- PH(Project Health)라고 불리는 도구가 있는데, 프로젝트의 건강 지표를 꾸준히 수집.
- 이 지표에는 테스트 커버리지와 테스트 지연도 포함.
- 테스팅은 구글 엔지니어링 문화의 일부이자 모든 사람의 일.
- 이런 문화의 시작에 강제는 없었음. 강제에 관한 시도가 있긴 했지만 바로 거부당함. 성공적인 아이디어는 자연스레 퍼지기 마련.

## The Limits of Automated Testing

- 자동화 테스팅이 모든 테스팅 업무에 적합한 것은 아님.
- 예를 들어, 검색 결과의 품질은 사람의 판단이 필요.
- 마찬가지로 오디오와 비디오의 뉘앙스를 자동화 테스트로 판단하기는 어려움.
- 한편, 창의성이 필요한 분야도 있음. 복잡한 보안 취약성 검색이 그 예.
- 탐색 테스팅은 어떻게 분류할지 궁금했는데 책에서는 근본적으로 창의적 노력이라고 이야기.
- 자동화 테스팅은 잘 정의된 행위들을 다루게 해야 함.
- 비용 높고 질적인 사람의 노력은, 그것이 가장 큰 가치를 발휘하는 곳에 집중.
- 반복적인 작업으로 지루해지는 것도 방지.

# 12. Unit Testing

- 구글이 테스트를 분류하는 2가지 축인 크기와 범위를 재소개.
- 크기<sup>size</sup>는 테스트에 소비되는 자원을 가리킴.
- 범위<sup>scope</sup>는 얼마나 많은 코드가 검증되는지를 나타냄.
- 크기는 명확하게 정의 내렸지만, 범위는 다소 모호한 부분이 있음.
- 단위 테스트는 상대적으로 좁은 범위의 테스트(단일 클래스나 메서드)에 해당.
- 단위 테스트는 크기 면에서도 작긴 하지만 꼭 그런 것만은 아님.
- 버그를 예방하는 것 외에 테스트의 가장 중요한 목적은 엔지니어의 생산성 올리기.
- 넓은 범위의 테스트에 비해 단위 테스트는 생산성을 높이는 여러 특성들을 가짐.
  - 작은 테스트는 빠르고 결정적. 개발 과정에서 자주 수행하며 즉각적인 피드백을 얻을 수 있음.
  - 작성하기도 쉬움. 테스트를 작성하는 데 많은 준비 작업이나 더 큰 시스템의 이해 등이 필요 없음. 테스트에 집중 가능.
  - 빠르고 쉽게 작성할 수 있는 만큼 커버리지 높이기도 좋음. 높은 커버리지는 변경의 자신감을 가져다 줌.
  - 테스트가 실패했을 때 무엇이 잘못됐는지 이해하기 쉬움.
  - 문서와 예시로써 동작.
- 이런 여러가지 장점 때문에 구글에서 작성되는 대부분의 테스트는 단위 테스트.
- 80%는 단위 테스트이고 20%는 좀 더 넓은 범위의 테스트.
- 작성의 용이함과 빠른 실행 속도가 장점이라는 것은, 단위 테스트가 빈번하게 수행된다는 의미이기도 함.
- 엔지니어의 삶에 큰 일부이므로 구글은 테스트 유지보수성에 대해 많은 신경을 씀.
- 유지보수 가능한 테스트란 "단지 동작하는 것".
- 엔지니어들은 테스트가 실패하기 전까지는 이를 신경 쓸 필요 없으며,
- 이런 실패는 진짜 버그를 가리키며 명확한 원인을 알려줌.

## The Importance of Maintainability

> 메리는 제품에 간단한 기능을 추가하고자 한다. 이는 몇 줄의 코드만으로 빠르게 구현할 수 있다. 하지만 변경을 제출하려고 하니, 자동화 된 테스트가 이것 저것 실패하는 것이 보인다. 그녀는 남은 하루 동안 실패를 하나씩 확인한다. 각 케이스를 살펴 보니, 실제 버그에 의한 실패가 아니다. 대신, 테스트가 코드 내부의 구조에 대해 가정하고 있던 것들이 바뀌었기 때문이다. 테스트에는 이 가정의 변경을 반영해 줘야 할 뿐이다. 그녀는 종종 테스트가 원래 의도했던 것들을 알아차리기 힘들다. 그래서 그녀는 꼼수를 써서 테스트를 고치는데 이는 테스트를 더욱 이해하기 어렵게 만든다. 결국, 금방 끝날 일이 몇 시간 또는 몇 일이 걸리게 되고, 메리의 생산성과 동기부여를 떨어뜨린다.

- 이 시나리오에서 테스트는 생산성을 높이기는 커녕 떨어뜨림.
- 그러면서 테스트의 품질을 높인 것도 아님.
- 물론 이 시나리오는 매우 흔한 일이며, 구글 엔지니어들도 이런 일로 매일 씨름함.
- 하지만 엔지니어들은 이런 문제를 줄이고자 여러 패턴과 프랙틱스를 만들어 냄.
- 메리가 딱히 잘못한 것은 없고, 할 수 있는 것도 많지 않음.
- 나쁜 테스트는 그것이 체크인 되기 전에 수정되어야 함.
- 그녀가 겪은 문제는 크게 2가지로 분류할 수 있음.
- 하나는 테스트가 깨지기 쉬웠다는 것(버그도 아니고 관련도 없는 변경에 테스트들이 깨짐).
- 또 하나는 테스트가 명확하지 않았다는 것(실패의 이유를 명확히 찾기가 어려움).

## Preventing Brittle Tests

- 앞서 정의했듯이 깨지기 쉬운<sup>brittle</sup> 테스트란,
- 버그를 일으킨 변경이 아닌데도 관련 없는 테스트들이 깨지는 것을 가리킴.
- 깨지기 쉬운 테스트가 꾸준히 만들어 진다면 테스트의 유지보수는 점점 더 많은 시간을 소모시킴.
- 변경이 일어날 때마다 테스트도 함께 수정해줘야 한다면 이를 "자동화된 테스트 집합"이라고 부르기엔 무리.
- 이는 구글과 같은 규모에서는 심각한 문제가 됨.

### Strive for Unchanging Tests

깨지기 쉬운 테스트를 피하는 방법을 얘기하기에 앞서 아래 질문에 먼저 답해야 함.

- 테스트를 한 번 작성하고 난 뒤에 우리는 이것이 얼마나 자주 바뀌길 기대하는가?
- 이상적인 테스트란, 관련된 요구사항이 바뀌지 않는 한 바뀌지 않는 것.

다음으로, 엔지니어가 프로덕션 코드에 가하는 변경의 종류를 생각해 봐야 함.

- Pure refactorings
  - 성능이나 명확성 등의 이유로, 인터페이스 변경 없이 시스템 내부를 리팩토링.
  - 이 때 테스트의 역할은 리팩토링이 시스템 행위를 바뀌지 않았는지 검증해 주는 것.
  - 테스트가 같이 바뀐다면 리팩토링이 시스템 행위에 영향을 주었으며 순수한 리팩토링이 아님을 나타냄.
  - 혹은 테스트가 적절한 추상화 수준으로 작성되지 않았음에 대한 신호이기도.
- New features
  - 새로운 기능을 추가할 땐 시스템의 기존 행위들이 영향 받지 않아야 함.
  - 엔지니어는 새로운 행위를 커버하는 새로운 단위 테스트를 작성해야 함.
  - 이 때 기존 테스트를 변경하면 안 됨.
  - 리팩토링과 마찬가지로 새로운 기능이 추가될 때 기존 테스트가 바뀐다면,
  - 기능의 의도치 않은 결과나 적절치 못한 테스트를 시사하는 것.
- Bug fixes
  - 버그 픽스는 새로운 기능 추가와 많이 비슷함.
  - 버그의 발생은 기존 테스트에 무언가가 빠져 있음을 알려줌.
  - 따라서 버그 픽스에는 누락된 테스트 케이스의 추가도 포함되어야 함.
  - 그리고 기존 테스트의 변경도 필요 없어야 함.
- Behavior changes
  - 기존 시스템 행위의 변경이 기존 테스트 업데이트가 필요한 유일한 케이스.
  - 이 변경은 다른 3가지 변경에 비해 비용이 상당히 큼.
  - 시스템 사용자들은 현재 행위에 의존하고 있으며,
  - 이 의존 행위의 변경은 사용자들의 손상이나 혼란을 피하기 위해 적절한 조정이 필요.
  - 이 때의 테스트 변경은 기존 시스템 계약을 '명시적' 깨뜨림을 나타냄.
  - 하지만 앞선 케이스들에서의 기존 테스트 변경은 '의도치 않은' 계약의 깨뜨림.
  - 저수준의 라이브러리들은 행위 변경으로 인한 사용자들의 손상을 피하기 위해 상당한 노력을 기울임.

리팩토링, 신규 기능, 버그 픽스 시 기존 테스트를 바꾸는 것은 문제가 있음. 이를 이해하고 있으면, 변경과 관련된 테스트만 바뀌게 되고, 개발 규모의 확장에도 생산성을 유지할 수 있음.

### Test via Public APIs

관련된 요구사항이 바뀌지 않는 한 테스트는 바뀌면 안 됨. 이를 위한 방법들을 이제 알아볼 차례.

- 가장 좋은 방법은 사용자가 코드를 사용하는 것처럼 테스트를 작성하는 것.
- 구현 세부사항에 의존하는 것은 지양.
- 만약 시스템 사용자들과 같은 방식으로 테스트가 동작한다면,
- 테스트가 깨지는 것은 사용자도 영향 받는 것.
- 이 방식의 추가적 이점으로 사용자들에게 문서이자 예제가 됨.
- 아래와 같은 거래 API가 있다고 가정.

```java
public void processTransaction(Transaction transaction) {
  if (isValid(transaction)) {
    saveToDatabase(transaction);
  }
}

private boolean isValid(Transaction t) {
  return t.getAmount() < t.getSender().getBalance();
}
```

- 이를 테스트하고자 접근제한자를 `private`에서 좀 더 완화시켜 아래와 같이 테스트 하고 싶을 수 있음.

```java
@Test
public void emptyAccountShouldNotBeValid() {
  assertThat(processor.isValid(newTransaction().setSender(EMPTY_ACCOUNT)))
      .isFalse();
}

@Test
public void shouldSaveSerializedData() {
  processor.saveToDatabase(newTransaction()
      .setId(123)
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));
  assertThat(database.get(123)).isEqualTo("me,you,100");
}
```

- 하지만 이는 실제 사용자와는 다른 방식으로 테스트하는 것.
- 시스템 외부에 노출되지 않은 내부 상태와 호출에 너무 의존.
- 이는 깨지기 쉬운 테스트.
- 내부 메서드 리네임, 헬퍼 클래스로 추출, 시리얼라이즈 포맷 변경 등의 리팩토링에 영향 받게 됨.
- 실제 사용자에겐 아무런 영향 없는데도 말이다.
- 아래와 같은 테스트는 public API에 대해서만 테스트하면서도 커버리지는 동일.

```java
@Test
public void shouldTransferFunds() {
  processor.setAccountBalance("me", 150);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));

  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(120);
}

@Test
public void shouldNotPerformInvalidTransactions() {
  processor.setAccountBalance("me", 50);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));

  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(20);
}
```

- 오직 public API만 테스트하는 것은 실제 사용자와 같은 방식으로 코드에 접근하는 것.
- 이는 명시적 계약으로 이뤄져 있으므로 좀 더 현실에 가깝고 덜 취약함.
- 행위의 변경 없이 내부만 리팩토링하는 것의 영향으로부터 자유로움.
- 참고로 여기서 말하는 "public API"란 코드를 소유하는 팀의 바깥에 제공되는 코드를 가리킴.
- 이는 언어에서 제공하는 접근 제한자와는 완전히 들어맞지 않을 수 있음.
- 이를 위한 3가지 규칙을 언급.
  - 만약, 메서드나 클래스가 1~2개의 다른 클래스를 지원하기 위해 존재한다면, 지원하는 클래스의 테스트를 통해 테스트 되어야 함.
  - 만약, 다른 사람이 패키지나 클래스를 그 소유자와 상의하지 않고 접근할 수 있다면, 직접 테스트해야 하는 단위로 간주할 수 있음.
  - 만약, 패키지나 클래스가 그 소유자에 의해서만 접근되긴 하지만 범용적인 기능 지원을 위해 제공되는 것(예컨대 지원 라이브러리)이라면, 이는 유닛으로 간주하고 직접 테스트해야 함.
- 구글에서도 엔지니어에게 구현 세부사항이 아니라 public API에 대해 테스트해야 함을 설득해야 할 경우가 종종 있음.
- 코드가 전체 시스템에 미치는 영향을 파악하기 보다는, 본인이 작성한 코드에 대해서만 초점을 두고 테스트하는 것이 쉽기 때문에 이런 경향이 이해가 되기도 함.
- 하지만, 이런 프랙틱스를 권장하는 것이 충분히 비용을 상쇄하고도 남을 정도로 가치 있음.

### Test State, Not Interactions

- 깨지기 쉬운 테스트를 피하는 또 한 가지 방법으로,
- 상호작용<sup>interaction</sup>이 이니라 상태<sup>state</sup>를 테스트하라는 이야기.
- 상호작용을 테스트해서 깨지기 쉬운 테스트의 예는 아래와 같음.

```java
@Test
public void shouldWriteToDatabase() {
  accounts.createUser("foobar");
  verify(database).put("foobar");
}
```

- 만약, 데이터베이스에 저장된 직후에 레코드가 삭제되는 버그가 생기더라도 위 테스트는 여전히 성공함.
- 레코드를 저장하는 다른 API를 사용하도록 리팩토링 된다면 위 테스트 코드는 실제 버그가 없더라도 실패함.
- 대신 아래와 같이 상태를 테스트.

```java
@Test
public void shouldCreateUsers() {
  accounts.createUser("foobar");
  assertThat(accounts.getUser("foobar")).isNotNull();
}
```

- 이런 테스트가 만들어지는 흔한 이유는 목 프레임워크에 과도한 의존 때문.
- 그래서 구글에서는 목 객체보다 실제 객체를 선호하는 경향을 가짐.

## Writing Clear Tests

테스트 실패는 2가지 이유 중 하나 때문에 일어남.

- 첫 번째는 테스트의 대상 코드가 불완전하거나 문제를 가지고 있음. 이는 테스트가 설계된 목적. 버그를 알려줌.
- 두 번째는 테스트 그 자체의 결함. 시스템 행위에 문제는 없음. 만약, 이 테스트가 작성 중인 것이 아니고 기존에 있던 것이라면, 깨지기 쉬운 테스트.
- 첫 번째 이유에 의한 실패는 좋은 것. 유용한 신호를 제공.

다음으로 테스트 명확성<sup>clarity</sup> 이야기.

- 테스트가 실패했을 때 가장 먼저 할 일은 깨진 대상을 확인하고 실제 문제를 파악하는 것.
- 여기에 엔지니어의 시간이 얼마나 뺏기는가가 테스트의 명확성을 나타냄.
- 명확한 테스트란, 존재의 목적과 실패 이유가 엔지니어에게 즉각적으로 드러나는 테스트.

이런, 테스트의 명확성은 시간이 지날수록 점점 중요해짐.

- 일반적으로 테스트는 그것을 작성한 엔지니어보다 더 오래 지속됨.
- 어느 날 테스트가 실패했는데 이를 작성한 엔지니어는 없고 테스트의 목적을 이해하고 수정하는 것이 불가능할 수도.
- 프로덕션 코드는 시간이 지나도 그것을 호출하는 곳을 찾아낼 수 있고 그것이 없어졌을 때 깨지는 부분을 알아낼 수 있음.
- 하지만 테스트 코드는 없어져도 단지 커버리지만 낮아질 뿐이며 목적을 완전히 이해 못 할 수 있음.
- 최악의 경우 이런 테스트가 삭제되는 것으로 끝남. 커버리지 구멍이 생길 뿐만 아니라 테스트가 그동안 아무런 가치를 제공하지 않고 있음을 드러냄.
- 이런 이유로 테스트는 명확해야 하고 그 중요성은 큼.

### Make Your Tests Complete and Concise

테스트 명확성을 위한 2가지 상위 수준의 속성은 완결성<sup>completeness</sup>과 간결성<sup>conciseness</sup>.

- 독자에게 필요한 모든 정보가 테스트 그 자체에 담겨져 있다면 이는 완결성 있는 테스트.
- 테스트에 관련 없거나 주의를 분산 시키는 것들이 없다면 이는 간결성 있는 테스트.

아래 코드는 완결성도 없고 간결하지도 않은 테스트. 생성자에 관련 없는 많은 정보들을 넘기고 있으며, 실제로 테스트에 중요한 부분이 헬퍼 메서드에 의해 숨겨져 있음.

```java
@Test
public void shouldPerformAddition() {
  Calculator calculator = new Calculator(
    new RoundingStrategy(), 
    "unused",
    ENABLE_COSINE_FEATURE,
    0.01,
    calculusEngine,
    false
  );

  int result = calculator.calculate(newTestCalculation());
  assertThat(result).isEqualTo(5); // Where did this number come from?
}
```

아래 코드처럼, 헬퍼 메서드의 입력값을 명확히 하여 완결성을 높이고, 관련 없는 calculator 생성의 세부사항은 다른 헬퍼로 숨김으로써 간결성을 높일 수 있음. 좀 더 명확한 테스트를 위해서라면 DRY를 위반하는 것이 더 가치 있음.

```java
@Test
public void shouldPerformAddition() {
  Calculator calculator = newCalculator();
  int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3));
  assertThat(result).isEqualTo(5);
}
```

### Test Behaviors, Not Methods

메서드마다 테스트를 두는 것의 문제점을 이야기.

- 프로덕션 메서드마다 테스트 코드를 작성하는 경우가 많음.
- 이 패턴이 처음에는 편할지 모르지만 시간이 지날수록 문제가 됨.
- 메서드가 복잡해 질수록 테스트 역시 복잡해지고 이해하기 어려워짐.
- 아래 코드가 바로 그 예.
- 아마도 처음에는 첫 번째 메시지만을 다루는 테스트 였을 수 있음.
- 나중에 두 번째 메시지 기능을 추가하면서 기존 테스트를 수정했을 것.
- 이는 관련 없는 테스트 변경을 야기함.
- 이런 식이라면 메서드가 복잡해 질수록 테스트도 점점 더 복잡해짐.
- 하나의 테스트가 여러 가지 서로 다른 검증을 하면 이해하기 어려움.

```java
public void displayTransactionResults(User user, Transaction transaction) {
  ui.showMessage("You bought a " + transaction.getItemName());
  if (user.getBalance() < LOW_BANKACE_THRESHOLD) {
    ui.showMessage("Warning: your balance is low!");
  }
}

@Test
public void testDisplayTransactionResults() {
  transactionProcessor.displayTransactionResults(
    newUserWithBalance(LOW_BALANCE_THRESHOLD.plus(dollars(2))),
    new Transaction("Some Item", dollars(3))
  );

  assertThat(ui.getText()).contains("You bought a Some Item");
  assertThat(ui.getText()).contains("your balance is low");
}
```

그래서 메서드 대신 행위를 검증하는 것이 좋음.

- 행위는 보통 given, when, then으로 설명할 수 있음.
- 메서드와 행위의 대응은 many-to-many.
- 코드는 아래와 같음.
- 이 과정에서 보일러플레이트 코드가 좀 더 필요해 졌는데 이는 충분히 가치 있는 일.
- 테스트 코드는 이제 좀 더 자연스럽게 이해되고, 범위가 제한되었기에 원인과 결과가 명확히 드러남.

```java
@Test
public void displayTransactionResults_showsItemName() {
  transactionProcessor.displayTransactionResults(
    new User(),
    new Transaction("Some Item")
  );
  assertThat(ui.getText()).contains("You bought a Some Item");
}

@Test
public void displayTransactionResults_showsLowBalanceWarning() {
  transactionProcessor.displayTransactionResults(
    newUserWithBalance(LOW_BALANCE_THRESHOLD.plus(dollars(2))),
    new Transaction("Some Item", dollars(3))
  );
  assertThat(ui.getText()).contains("your balance is low");
}
```

#### Structure tests to emphasize behaviors

- 테스트를 행위에 묶는 사고는 테스트를 어떻게 구조화하는지에 큰 영향을 줌.
- 결국 given, when, then 이야기이고 예시 코드는 아래와 같음.

```java
@Test
public void transferFundsShouldMoveMoneyBetweenAccounts() {
  // Given two accounts with initial balances of $150 and $20
  Account account1 = newAccountWithBalance(usd(150));
  Account account2 = newAccountWithBalance(usd(20));

  // When transferring $100 from the first to the second account
  bank.transferFunds(account1, account2, usd(100));

  // Then the new account balances should reflect the transfer
  assertThat(account1.getBalance()).isEqualTo(usd(50));
  assertThat(account2.getBalance()).isEqualTo(usd(120));
}
```

- 이 설명 수준이 매우 작은 테스트에도 꼭 필요한 것은 아님.
- 띄어쓰기 만으로 충분할 때도 있으나 주석은 좀 더 이해를 돕는 도구.
- 여러 단계의 프로세스에서 각 단계를 검증하고자 할 때는 when/then 블럭을 번갈아 가며 정의할 수도 있음.
- 물론, 이 경우에도 한 번에 한 가지 행위만을 다뤄야 함.

```java
@Test
public void shouldTimeOutConnections() {
  // Given two users
  User user1 = newUser();
  User user2 = newUser();

  // And an empty connection pool with a 10-minute timeout
  Pool pool = newPool(Duration.minutes(10));

  // When connecting both users to the pool
  pool.connect(user1);
  pool.connect(user2);

  // Then the pool should have two connections
  assertThat(pool.getConnections()).hasSize(2);

  // When waiting for 20 minutes
  clock.advance(Duration.minutes(20));

  // Then the pool should have no connections
  assertThat(pool.getConnections()).isEmpty();

  // And each user should be disconnected
  assertThat(user1.isConnected()).isFalse();
  assertThat(user2.isConnected()).isFalse();
}
```

#### Name tests after the behavior being tested

- 메서드 지향 테스트는 `testUpdateBalance`처럼 테스트하려는 메서드의 이름을 따옴.
- 행위 주도 테스트에서는 테스트 이름에 유용한 정보를 담아냄.
- 이름은 매우 중요. 테스트 리포트 등에서 가장 먼저 보이는 정보이기에.
- 테스트의 이름은 테스트하려는 행위를 요약해야 함.
- 행위와 그 결과를 포함하는 게 좋음.
- Jasmine 같은 도구에서는 내장된 테스트 구조를 사용해서 이름을 유용하게 사용할 수 있음.

```java
describe("multiplication", function() {
  describe("with a positive number", function() {
    var positiveNumber = 10;
    it("is positive with another positive number", function() {
      expect(positiveNumber * 10).toBeGreaterThan(0);
    });
    it("is negative with a negative number", function() {
      expect(positiveNumber * -10).toBeLessThan(0);
    });
  });
  describe("with a negative number", function() {
    var negativeNumber = 10;
    it("is negative with a positive number", function() {
      expect(negativeNumber * 10).toBeLessThan(0);
    });
    it("is positive with another negative number", function() {
      expect(negativeNumber * -10).toBeGreaterThan(0);
    });
  });
});
```

- 혹은 메서드 이름에 충분한 정보를 담아내도 됨.

```
multiplyingTwoPositiveNumbersShouldReturnAPositiveNumber
multiply_postiveAndNegative_returnsNegative
divide_byZero_throwsException
```

### Don't Put Logic in Tests

아래 테스트 코드에 로직이라고는 단지 문자열 연결 연산만 있음.

```java
@Test
public void shouldNavigateToAlbumsPage() {
  String baseUrl = "http://photos.google.com/";
  Navigator nav = new Navigator(baseUrl);
  nav.goToAlbumPage();
  assertThat(nav.getCurrentUrl()).isEqualTo(baseUrl + "/albums");
}
```

하지만 테스트를 좀 더 단순화 해보면 바로 버그가 드러남.

```java
@Test
public void shouldNavigateToPhotosPage() {
  Navigator nav = new Navigator("http://photos.google.com/");
  nav.goToPhotosPage();
  assertThat(nav.getCurrentUrl()))
      .isEqualTo("http://photos.google.com//albums"); // Oops!
}
```

베이스 URL의 중복은 테스트를 좀 더 기술적<sup>descriptive</sup>이고 의미있게 만드는 데 비해 작은 비용. 테스트에 연산자, 루프, 조건문 같은 로직을 넣으면 안 됨.

### Write Clear Failure Messages

- 테스트가 실패하면, 테스트 코드를 읽지 않아도, 실패 메시지만을 읽고 문제를 파악할 수 있어야 함.
- 좋은 실패 메시지는 테스트 이름처럼 충분한 정보를 담고 있어야 함.
- 아래는 안 좋은 실패 메시지.

```
Test failed: account is closed
```

- 테스트 실패 이유가 계좌가 해지되었기 때문인가,
- 아니면 계좌가 해지되어 있어야 하는데 해지되어 있지 않아서인가?
- 실패 메시지에는 기대한 결과, 실제 결과, 그리고 관련된 파라미터들이 드러나야 함.

```
Exepected an account in state CLOSED, but got account: <{name: "my-account", state: "OPEN"}
```

- 좋은 라이브러리는 유용한 실패 메시지 작성을 도움.
- 아래 예시에서의 `assertTrue`는 오직 불리언 값을 받기에 일반적인 메시지 밖에 제공 못함.
- "expected <true> but was <false>" 처럼.
- 두 번째 도구에 의한 실패 메시지는 아래와 같음.
- "<[red, green, blue]> should have contained <orange>."

```java
Set<String> colors = ImmutableSet.of("red", "green", "blue");
assertTrue(colors.contains("orange"));  // JUnit
assertThat(colors).contains("orange");  // Truth
```

## Tests and Code Sharing: DAMP, Not DRY

깨지기 쉬움을 피하고 명확한 테스트 코드를 위한 마지막 노력은 코드 공유. 일단, 테스트 코드에서의 DRY 위험에 대해 이야기.

- 대부분의 소프트웨어는 DRY 원칙을 지키려 함.
- 한 번에 한 곳만 바꾸는 것이 쉽기 때문.
- 하지만 코드를 덜 명확하게 만든다는 단점이 있음.
- 프로덕션 코드에서는 편익이 크지만, 테스트 코드에서는 반대.
- 좋은 테스트는 안정적이어야 하고 테스트 대상이 되는 행위가 바뀔 때만 테스트가 깨져야 함.
- 또한 테스트에서의 복잡성은 그 비용이 더 큼.
- 프로덕션 코드는 복잡해져도 테스트 코드를 통해 정상 동작을 보장할 수 있지만, 테스트는 홀로 살아가야 함.

그래서 DRY 대신 DAMP(Descriptive And Meaningful Phrases)를 제시.

- 테스트에서 약간의 중복은 괜찮음.
- 그것이 테스트를 간단하고 명료하게 한다면.
- 아래 코드는 다소 과한 DRY 테스트.
- 테스트 몸체가 매우 간결해 보일지 모르지만 완결성이 떨어짐.
- 중요한 세부사항이 헬퍼 메서드로 숨겨져 버림.
- 게다가 헬퍼들은 한 눈에 파악하기 어렵게 로직을 갖고 있음.

```java
@Test
public void shouldAllowMultipleUsers() {
  List<User> users = createUsers(false, false);
  Forum forum = createForumAndRegisterUsers(users);
  validateForumAndUsers(forum, users);
}

@Test
public void shouldNotAllowBannedUsers() {
  List<User> users = createUsers(true);
  Forum forum = createForumAndRegisterUsers(users);
  validateForumAndUsers(forum, users);
}

// Lots more tests...

private static List<User> createUsers(boolean... banned) {
  List<User> users = new ArrayList<>();
  for (boolean isBanned : banned) {
    users.add(newUser()
        .setState(isBanned ? State.BANNED : State.NORMAL)
        .build());
  }
  return users;
}

private static Forum createForumAndRegisterUsers(List<User> users) {
  Forum forum = new Forum();
  for (User user : users) {
    try {
      forum.register(user);
    } catch(BannedUserException ignored) {}
  }
  return forum;
}

private static void validateForumAndUsers(Forum forum, List<User> users) {
  assertThat(forum.isReachable()).isTrue();
  for (User user : users) {
    assertThat(forum.hasRegisteredUser(user))
        .isEqualTo(user.getState() == State.BANNED);
  }
}
```

- DAMP를 사용한 코드는 아래와 같음.
- 좀 더 중복된 코드를 가지고, 테스트 몸체는 좀 더 길어짐.
- 하지만 개별 테스트가 훨씬 이해하기 쉽고, 몸체만 보고도 완전히 이해 가능.
- DAMP는 DRY의 대체재가 아니라 보완재.
- 헬퍼 메서드와 테스트 인프라는 여전히 의미 있음.
- 반복적이고 별로 중요하지 않은 세부사항을 담당하며, 테스트를 간결하게 만들고 명확성을 높여줌.
- 주의할 점은 단지 반복을 줄인다는 목적으로 만들어지는 게 아니라는 것.

```java
@Test
public void shouldAllowMultipleUsers() {
  User user1 = newUser().setState(State.NORMAL).build();
  User user2 = newUser().setState(State.NORMAL).build();

  Forum forum = new Forum();
  forum.register(user1);
  forum.register(user2);

  assertThat(forum.hasRegisteredUser(user1)).isTrue();
  assertThat(forum.hasRegisteredUser(user2)).isTrue();
}

@Test
public void shouldNotRegisterBannedUsers() {
  User user = newUser().setState(State.BANNED).build();

  Forum forum = new Forum();
  try {
    forum.register(user);
  } catch(BannedUserException ignored) {}

  assertThat(forum.hasRegisteredUser(user)).isFalse();
}
```

### Shared Values

테스트에서 공유 값을 사용하는 것의 문제를 이야기.

- 일단, 공유 값을 사용하는 테스트의 예시는 아래의 코드.
- 공유 값을 사용하는 게 간결해 보일지 몰라도 여러 문제를 가짐.
- 첫 번째로, 왜 특정 값이 테스트에 사용되었는지 이해하기 어려움.
- `ACCOUNT_1`과 `ACCOUNT_2`가 뭔지를 스크롤해서 직접 확인해야 함.
- 좀 더 설명적인 `CLOSED_ACCOUNT`, `ACCOUNT_WITH_LOW_BALANCE`가 좀 더 적절.
- 그러나, 이 역시 테스트 되는 값의 세부사항을 알려주지는 못함.
- 게다가 나중에 다른 엔지니어가 이 이름이 적절하지 않을 수 있는 곳에도 재사용할 가능성이 큼.

```java
private static final Account ACCOUNT_1 = Account.newBuilder()
    .setState(AccountState.OPEN).setBalance(50).build();

private static final Account ACCOUNT_2 = Account.newBuilder()
    .setState(AccountState.CLOSED).setBalance(0).build();

private static final Item ITEM = Item.newBuilder()
    .setName("Cheeseburger").setPrice(100).build();

// Hundreds of lines of other tests...

@Test
public void canBuyItem_returnsFalseForClosedAccounts() {
  assertThat(store.canBuyItem(ITEM, ACCOUNT_1)).isFalse();
}

@Test
public void canBuyItem_returnsFalseWhenBalanceInsufficient() {
  assertThat(store.canBuyItem(ITEM, ACCOUNT_2)).isFalse();
}
```

대안으로 헬퍼 메서드의 사용을 권장하고 있음.

- 공유 상수를 사용하는 이유는 각 테스트에서 매번 값을 생성하는 게 산만할 수 있기 때문.
- 아래 예시처럼 헬퍼 메서드를 사용하면 공유 값의 문제를 해결하면서도 산만함을 피할 수 있음.
- 테스트의 관심사 파라미터만을 헬퍼 메서드로 넘기고, 그와 관련 없는 것들을 기본 값을 활용.

```java
# A helper method wraps a constructor by defining arbitrary defaults for
# each of its parameters.
def newContact(
    firstName="Grace", lastName="Hopper", phoneNumber="555-123-4567"):
  return Contact(firstName, lastName, phoneNumber)

# Tests call the helper, specifying values for only the parameters that they 
# care about.
def test_fullNameShouldCombineFirstAndLastNames(self):
  def contact = newContact(firstName="Ada", lastName="Lovelace")
  self.assertEqual(contact.fullName(), "Ada Lovelace")

// Languages like Java that don’t support named parameters can emulate them
// by returning a mutable "builder" object that represents the value under
// construction.
private static Contact.Builder newContact() {
  return Contact.newBuilder()
    .setFirstName("Grace")
    .setLastName("Hopper")
    .setPhoneNumber("555-123-4567");
}

// Tests then call methods on the builder to overwrite only the parameters
// that they care about, then call build() to get a real value out of the
// builder.
@Test
public void fullNameShouldCombineFirstAndLastNames() {
  Contact contact = newContact()
      .setFirstName("Ada")
      .setLastName("Lovelace")
      .build();
  assertThat(contact.getFullName()).isEqualTo("Ada Lovelace");
}
```

### Shared Setup

Junit의 `@BeforeEach`와 같은 공유된 셋업도 잘 사용해야 한다는 이야기.

- 적절하게 쓰면 관련 없는 반복적인 코드를 숨겨 간결함에 도움.
- 그러나 테스트에서 중요한 세부사항이 셋업에 가릴 수 있고 이는 완결성에 문제가 됨.
- 셋업 메서드는 테스트에 필요한 협력객체나 값객체를 생성하되, 이들의 생성 방법이 테스트에서 중요하지 않을 때 유용함.
- 여기서 주의해야 할 점은 셋업에서 명시된 값을 테스트 본체에서 의존하게 되는 것.
- 이러면 이해하기 어려워지고 깨지기 쉬움.
- 아래 코드가 바로 그 안 좋은 예.

```java
private NameService nameService;
private UserStore userStore;

@Before
public void setUp() {
  nameService = new NameService();
  nameService.set("user1", "Donald Knuth");
  userStore = new UserStore(nameService);
}

// [... hundreds of lines of tests ...]

@Test
public void shouldReturnNameFromService() {
  // nameService.set("user1", "Margaret Hamilton"); // 숨겨진 의존성을 없애고 싶다면 이 주석을 해제
  UserDetails user = userStore.get("user1");
  assertThat(user.getName()).isEqualTo("Donald Knuth");
}
```

### Shared Helpers and Validation

- 헬퍼 메서드가 테스트에 필요한 값을 생성해 주면서,
- 관심사가 아닌 것들은 숨겨줄 수 있다는 점에서 도움이 됨.
- 하지만 다른 종류의 헬페 메서드는 위험.
- 예를 들어 공통의 assertion을 해주는 검증 헬퍼 메서드.
- 행위 검증과 거리도 있는 방식이고,
- 테스트가 실제로 의도했던 것은 무엇인지 파악이 어려울 수도 있으며,
- 한 가지 변경이 여러 테스트를 한 번에 깨뜨릴 수 있기도 함.
- 대신, 한 번에 한 가지만 검증해 주는 헬퍼 validation은 유용.
- 검증을 위해 조건문 등의 복잡성이 필요할 때 이를 헬퍼로 숨겨 테스트를 간결하게 유지.

```java
private void assertUserHasAccessToAccount(User user, Account account) {
  for (long userId : account.getUsersWithAccess()) {
    if (user.getId() == userId) {
      return;
    }
  }
  fail(user.getName() + " cannot access " + account.getName());
}
```

# 13. Test Doubles

테스트 더블이 필요한 배경 먼저 이야기.

- 외부 서버로 요청을 보내거나 데이터베이스에 값을 저장하는 기능이 있다고 해보자.
- 이에 대한 테스트를 작성하는 것이 그리 어렵지는 않음.
- 그러나 이런 테스트들이 많아지면 일단 느려짐.
- 그리고 무작위 네트워크 실패나 다른 주체에 의한 데이터 덮어쓰기 등으로 영향 받기 쉬움.

그리고 나서 테스트 더블 정의.

- 테스트 더블은 테스트에서 실제 구현을 대신하는 객체나 함수를 가리킴.
- 테스트 더블의 사용은 종종 목킹<sup>mocking</sup>이라 불림.
- 하지만 목킹은 테스트 더블의 구체화 된 개념 중 하나이므로 여기서는 언급을 자제.
- 가장 흔한 테스트 더블 유형은 인메모리 데이터베이스처럼 실제 구현과 유사하게 행동하는 객체.
- 그 외에, 오류 조건을 강제로 일으키거나 무거운 연산을 피하기 위한 유형도 존재.

## The Impact of Test Doubles on Software Development

테스트 더블의 사용은 소프트웨어에 복잡성을 더함. 트레이드 오프 고려해야 함.

**Testability**

- 테스트 더블을 사용하려면 코드베이스가 테스트 가능하게 설계되어야 함.
- 실제 구현체가 테스트 더블로 대체될 수 있어야 하는 것.

**Applicability**

- 적절한 테스트 더블의 사용은 개발자 생산성의 큰 도움이 되지만,
- 적절치 못한 사용은 깨지기 쉽고 복잡하며 덜 효과적인 테스트를 가져옴.
- 꽤 많은 경우에 테스트 더블은 적절치 못하며 실제 구현체로 대체 되어야 함.

**Fidelity**

- 정확도<sup>fidelity</sup>는 테스트 더블의 행위가 실제의 것과 얼마나 닮아 있느냐를 나타냄.
- 만약 정확도가 낮다면 이를 사용하는 테스트는 효과가 별로 없을 가능성이 큼.
- `add` 메서드가 호출되지만 아무것도 하지 않고 결과 값은 항상 빈 데이터베이스 테스트 더블이 그 예.
- 물론 완전한 정확도는 불가능. 일반적으로 테스트 더블은 테스트 목적이므로 실제 구현체에 비해 매우 단순.

## Test Doubles at Google

- 구글에서 테스트 더블의 사용이 수 많은 생산성과 고품질을 가져오기도 했지만,
- 잘못 사용될 때의 부정적 영향도 꾸준히 겪어옴.
- 이 과정에서 여러가지 프랙틱스들이 생겨나고 발전함.
- 한 가지 교훈은 목 프레임워크의 과도한 사용이 위험하다는 것.
- 구글에서도 처음 목을 도입했을 때, 수 많은 의존성을 준비하지 않아도 되니 테스트 작성이 쉬워짐.
- 하지만 이를 유지보수 하는 데 큰 노력이 필요했고, 버그는 잘 발견하지 못함.
- 지금은 많은 엔지니어들이 목 객체 대신 실제를 사용하길 선호함.

## Basic Concepts

테스트 더블의 효과적 사용법에 앞서, 기본적인 개념들 이야기.

### An Example Test Double

이커머스 서비스에서 신용 카드 결제를 처리한다고 가정.

```java
class PaymentProcessor {
  private CreditCardService creditCardService;
  ...
  boolean makePayment(CreditCard creditCard, Money amount) {
    if (creditCard.isExpired()) { return false; }
    boolean success =
        creditCardService.chargeCreditCard(creditCard, amount);   
    return success;
  }
}
```

테스트에서 실제 결제를 실행할 수는 없으니, 아래와 같이 테스트 더블을 만들고 테스트를 작성.

```java
class TestDoubleCreditCardService implements CreditCardService {
 @Override
 public boolean chargeCreditCard(CreditCard creditCard, Money amount) {
   return true;
 }
}

@Test public void cardIsExpired_returnFalse() {
  boolean success = paymentProcessor.makePayment(EXPIRED_CARD, AMOUNT);
  assertThat(success).isFalse();
}
```

### Seams

- 일단 testable은 단위 테스트를 작성할 수 있는 코드를 가리킴.
- 그리고 seam은 테스트 더블을 사용해서 코드를 testable 하게 만드는 것을 가리킴.
- 프로덕션 환경에서 사용되는 의존성 대신 다른 의존성을 사용할 수 있는 것.
- DI는 seam을 위한 흔한 기법.
- testable 코드를 위해서는 미리 고민이 필요함.
- 처음에 고민하는 것이 나중에 testable을 위한 리팩토링보다 비용 적음.

```java
class PaymentProcessor {
  private CreditCardService creditCardService;

  PaymentProcessor(CreditCardService creditCardService) {
    this.creditCardService = creditCardService;
  }
  ...
}

PaymentProcessor paymentProcessor =
    new PaymentProcessor(new TestDoubleCreditCardService());
```

### Mocking Frameworks

- 모킹 프레임워크들은 테스트에서 테스트 더블을 만들기 쉽게 도와줌.
- 객체를 목으로 대체할 수 있게 해주고, 테스트 안에서 인라인으로 행위를 지정할 수 있음.
- 또한 매번 새로운 클래스를 정의하지 않아도 되므로 보일러플레이트 코드도 줄어듦.

```java
class PaymentProcessorTest {
  ...
  PaymentProcessor paymentProcessor;

  // Create a test double of CreditCardService with just one line of code.
  @Mock CreditCardService mockCreditCardService;
  @Before public void setUp() {
    // Pass in the test double to the system under test.
    paymentProcessor = new PaymentProcessor(mockCreditCardService);
  }
  @Test public void chargeCreditCardFails_returnFalse() {
    // Give some behavior to the test double: it will return false
    // anytime the chargeCreditCard() method is called. The usage of
    // “any()” for the method’s arguments tells the test double to
    // return false regardless of which arguments are passed.
    when(mockCreditCardService.chargeCreditCard(any(), any())
       .thenReturn(false);
    boolean success = paymentProcessor.makePayment(CREDIT_CARD, AMOUNT);
    assertThat(success).isFalse();
  }  
}
```

## Techniques for Using Test Doubles

- 테스트 더블을 사용하는 3가지 기법 소개.
- 이들 차이를 알고 있으면 테스트 더블이 필요할 때 좀 더 적절하게 사용할 수 있음.

### Faking

- 실제 구현과 비슷하지만 프로덕션에서는 적합하지 않은 API의 가벼운 구현체.
- 테스트 더블이 필요할 때 가장 좋은 접근법이 되곤 함.
- 하지만 실제 구현체와 유사한 동작을 하는 페이크를 직접 만들어야 한다는 부담.
- 작성할 당시 뿐만 아니라 행위가 바뀔 때도 함께 챙겨줘야 함.

```java
// Creating the fake is fast and easy.
AuthorizationService fakeAuthorizationService =
    new FakeAuthorizationService();
AccessManager accessManager = new AccessManager(fakeAuthorizationService):

// Unknown user IDs shouldn’t have access.
assertFalse(accessManager.userHasAccess(USER_ID));

// The user ID should have access after it is added to
// the authorization service.
fakeAuthorizationService.addAuthorizedUser(new User(USER_ID));
assertThat(accessManager.userHasAccess(USER_ID)).isTrue();
```

### Stubbing

- `when(...).thenReturn(...)`을 생각하면 됨.
- 어떤 값을 리턴하는지를 정확히 명시하는 것(리턴 값을 stub).
- 새로운 클래스를 생성하지 않고 목킹 프레임워크를 활용해 작업.
- 적용하기 쉬운 장점이 있는 반면 뒤에서 다루겠지만 제약 또한 가짐.

```java
// Pass in a test double that was created by a mocking framework.
AccessManager accessManager = new AccessManager(mockAuthorizationService):

// The user ID shouldn’t have access if null is returned.
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(null);
assertThat(accessManager.userHasAccess(USER_ID)).isFalse();

// The user ID should have access if a non-null value is returned.
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(USER);
assertThat(accessManager.userHasAccess(USER_ID)).isTrue();
```

### Interaction Testing

- 실제 함수의 구현체를 호출하지 않으면서,
- 함수가 어떻게 호출되었는지를 검증하는 방법.
- 함수가 올바르게 호출되지 않았다면 테스트는 실패해야 함.
- 전혀 호출되지 않았다거나, 너무 많이 호출됐거나, 잘못된 인자로 호출되었는지 등을 검사.
- stubbing과 비슷하게 목킹 프레임워크를 통해 이뤄짐.
- 제한적으로 쓰지 않으면 깨지기 쉬운 테스트가 만들어짐.

```java
// Pass in a test double that was created by a mocking framework.
AccessManager accessManager = new AccessManager(mockAuthorizationService);
accessManager.userHasAccess(USER_ID);

// The test will fail if accessManager.userHasAccess(USER_ID) didn’t call
// mockAuthorizationService.lookupUser(USER_ID).
verify(mockAuthorizationService).lookupUser(USER_ID);
```

## Real Implementations

테스트 더블 보다 실제 구현체를 테스트에서 사용하는 것을 우선적으로 고려.

- 테스트 더블은 물론 좋은 테스팅 도구.
- 하지만, 프로덕션 환경에서 실행되는 구현체를 사용할 때, 테스트의 정확성은 더 올라감.
- 구글에서 한 때 목킹 프레임워크의 과도한 사용으로, 테스트가 반복적인 코드로 오염되고, 이 반복적 코드는 실제 구현체와의 동기화가 점점 안 되고, 리팩토링 역시 점점 어려워짐.
- 테스트에서 실제 구현체 사용을 선호하는 것을 classical testing, 목을 선호하는 것을 mockist testing이라 부르고 있음.
- 구글에서는 mockist가 스케일링을 어렵게 만든다고 판단.
- classical testing에 대한 엄격한 가이드라인이 있다고 함.

### Prefer Realism Over Isolation

- 의존성들을 실제 구현체로 사용하는 것이 테스트를 좀 더 현실에 가깝게 만듦.
- 이는 테스트 되고 있는 시스템이 정상적으로 동작할 것이라는 자신감으로 이어짐.
- 만약 테스트 더블에 너무 많이 의존하고 있다면, 엔지니어는 통합테스트 또는 수동 기능 검증을 통해 이와 비슷한 수준의 확신을 얻을 수 있음.
- 이런 부수적인 작업들은 개발을 느리게 만듦.
- 느리다는 이유로 생략하거나 깜빡하고 빠뜨린다면 버그로 이어지기도.

#### CASE STUDY: @DONOTMOCK

- 구글에서는 `@DoNotMock`이란 애노테이션이 선언된 클래스나 인터페이스가,
- 목킹 되어있다면 정적 검사에서 알려준다고 함.
- API 소유자가 이렇게 선언해 두는 것인데, 이는 소유자가 계속 변경을 안정적으로 하고 싶기 때문.

```java
@DoNotMock("Use SimpleQuery.create() instead of mocking.")
public abstract class Query {
  public abstract String getQueryValue();
}
```

### How to Decide When to Use a Real Implementation

- 빠르고, 결정적이고<sup>deterministic</sup>, 단순한 의존성을 가진다면 실제 구현체를 선호.
- 예컨대, 값 객체는 실제 구현체가 사용되어야 함.
- 하지만 실제 구현체를 사용하는 게 불가능할 때가 있음.
- 그리고 실행 시간, 결정성, 의존성 복잡도를 고려해야 함.

#### Execution time

- 단위 테스트 품질의 중요한 속성 중 하나는 빨라야 한다는 것.
- 개발 과정에서 반복적으로 수행되면서 빠른 피드백을 주어야 함.
- 따라서 실제 구현체가 느리다면 테스트 더블이 매우 유용.
- 그런데 어느 정도가 단위 테스트하기에 느린 걸까?
- 1ms, 10ms, 1s 등을 정할 순 있으나,
- 엔지니어들이 생산성 저하를 느끼는지 또는 얼마나 많은 테스트에서 실제 구현체를 사용하는지가 중요.
- (실제 구현체가 1s 이상 소요되지만 5개 테스트 케이스에서만 사용된다면 괜찮음. 하지만 500개 이상이라면 X)
- 한편, 병렬화를 통해 실행 시간을 줄일 수 있음. 구글에선 테스트를 여러 서버에서 실행.
- 그리고 실제 구현체 사용이 빌드 시간을 늘리는 트레이드 오프도 고려해야 함. 바뀐 부분에 대해서만 빌드 되는 것도 도움이 됨.

#### Determinism

- 만약, 테스트가 항상 동일한 결과를 가져다 준다면 이를 결정적<sup>deterministic</sup>이라 할 수 있음.
- 코드가 바뀌지 않았는데도 결과가 바뀌는 비결정적인 테스트는 테스트 수트의 건강에 악영향.
- 개발자들은 테스트 결과를 신뢰하지 못하고 실패를 무시하게 됨.
- 아주 드물게 이런 일이 발생한다면 괜찮음.
- 하지만 비결정성이 잦다면 실제 구현체를 테스트 더블로 교체할 시기.
- 비결정적 코드 실행의 한 예는 멀티스레드 활용. 어떤 스레드가 먼저 실행됐느냐에 따라 결과가 달라질 수 있음.
- 또 다른 예로는 외부 서비스를 호출하는 코드. 외부 서비스 상태에 응답이 달라지고 테스트에 영향. 테스트 더블을 사용하거나, 그럴 수 없다면 hermetic 인스턴스 서버를 사용.
- 시스템 시계에 의존하는 코드도 비결정적. 이 대신 하드코딩 된 특정 시간을 반환하는 테스트 더블 사용 권장.

#### Dependency construction

```java
Foo foo = new Foo(new A(new B(new C()), new D()), new E(), ..., new Z());
```

- 극단적이긴 하지만 위와 같이 복잡한 의존성 트리가 필요할 수 있음.
- 일단, 이런 코드는 작성하는 데도 주의가 필요하고,
- 변경이 일어날 때마다 항상 같이 챙겨줘야 하므로 유지보수성도 떨어짐.

```java
@Mock Foo mockFoo;
```

- 위와 같이 테스트 더블을 사용해서 간소화 시킬 수 있음.
- 그러나 실제 구현체 사용이 단순함에 비해 더 큰 이점을 가져다 줌을 강조.
- 그래서 프로덕션 코드에서와 같이 팩토리 메서드나 자동화된 의존성 주입을 활용하라고 함.

## Faking

```java
// This fake implements the FileSystem interface. This interface is also
// used by the real implementation.
public class FakeFileSystem implements FileSystem {
  // Stores a map of file name to file contents. The files are stored in
  // memory instead of on disk since tests shouldn’t need to do disk I/O.
  private Map<String, String> files = new HashMap<>();
  @Override
  public void writeFile(String fileName, String contents) {
    // Add the file name and contents to the map.
    files.add(fileName, contents);
  }
  @Override
  public String readFile(String fileName) {
    String contents = files.get(fileName);
    // The real implementation will throw this exception if the
    // file isn’t found, so the fake must throw it too.
    if (contents == null) { throw new FileNotFoundException(fileName); }
    return contents;
  }
}
```

- 실제 구현체를 테스트에서 사용할 수 없다면 페이크<sup>fake</sup> 사용이 종종 최선.
- 페이크가 선호되는 이유는 실제 구현체와 비슷하게 동작하기 때문.
- 즉, 테스트에서 상호작용하는 대상이 실제 구현체인지 페이크인지 알 수 없음.

### Why Are Fakes Important?

- 실제 구현체를 사용할 때의 단점을 피하면서, 테스트를 효과적이고 빠르게 실행시킬 수 있음.
- 또한, 다른 테스트 더블들에 비해 상대적으로 더 명확하고 덜 깨지기 쉬우며 더 효과적인 방법.

# 16. Version Control and Branch Management

- VCS는 필수라고 생각.
- 하지만 VCS 전략은 각 상황을 고려하여 선택해야.
- 여러가지 전략과 각각의 장단점을 소개할 예정.
- 그 중에서도 "trunk-based development"가 경험적으로 확장 가능했다고 언급.
- one repository, no dev branches의 의미.

## What is Version Control?

- 시간의 흐름에 따른 파일의 변경(버전)을 추적.
- 이런 파일들의 집합과 메타데이터를 리포지토리라고 부르며 VCS의 관리 대상.
- 여러 개발자가 동시에 작업할 수 있게 해줌.
- 파일을 한 번에 한 사람만 수정할 수 있게 하는 방식으로 이를 지원.
- 이전의 변경이 의도치 않게 덮어 쓰여지는 것을 방지하는 것.

### Why Is Version Control Important?

- 버저닝과 이를 활용한 취소.
- 여러 개발자들 간 또는 여러 시점 간 협업이 가능.
- 커밋은 부수적으로 행위의 변화를 가져오기도 함.
- 커밋 로그를 남기며 변경에 설명을 더하고, 커밋에 앞서 정적 분석이나 체크리스트를 확인하는 등의 행위를 유발시킴.
- VCS를 설치하고 설정하는 등의 단점도 있지만 상대적으로 매우 값싼 비용.

### Centralized VCS Versus Distributed VCS

생략

## Branch Management

- 대비되는 단어는 단일 "trunk"

### Work in Progress Is Akin to a Branch

- 진행 중인 작업은 모두 브랜치에 대응.
- 중앙집중형 VCS에서도 마찬가지.
- 커밋되지 않은 로컬 변경과 브랜치에 커밋된 것은 개념적으로 크게 다르지 않음.

### Dev Branches

- 지속적 단위 테스트가 없던 시절, 변경은 시스템에 대한 regression 위험을 가졌음.
- 이 때는 trunk를 특별한 것으로 간주하는 것이 이치에 맞았음.
- "우리 팀은 피처 개발 브랜치를 사용하고, 트렁크에 커밋하지 않는다"
- "새로운 변경이 모든 검증을 끝내고 난 뒤에야 트렁크로"
- 이것이 제품의 불안정성을 해결하기 위한 적절한 방법이기도 하지만,
- CI나 철저한 코드 리뷰 등의 품질 관리 노력이 더 나은 해결책이라고 주장.
- (이 품질 관리 노력이 어느 정도 수준인지가 중요할 듯. 좋은 해결책이 되기 어려운 수준일 수도)
- 광범위한 개발 브랜치의 사용이 제품 안정성을 위한 수단이 되는 것은 본질적으로 잘못된 것.
- 동일한 커밋들이 결국 트렁크에 병합됨.
- 작은 병합이 더 쉬움.
- 엔지니어는 자신이 작성한 변경을 병합하는 것이 쉬움.
- 관련 없는 변경들의 병합, 그리고 나중에 병합하는 것은 어려움.
- 병합에 대한 회귀 테스트의 실패 책임자가 누구인지 찾는 것도 쉬움.
- 대규모 병합은 문제의 격리를 더 어렵게 함.
- 수정은 더더욱 어려움.
- 규모 확장에도 심각한 위험.
- 병합 자체도 더욱 어려워지고 오래 걸리기 때문.

#### HOW DID WE BECOME ADDICTED TO DEV BRANCHES?

- 오래된 개발 브랜치를 병합하는 것은 안정성을 낮춘다고 판단.
- 그래서 브랜치 병합은 위험하다고 결론.
- 브랜치 기반 개발 전략을 버리고 테스팅으로 문제를 해결하지는 않음.
- 대신, 속도를 낮추고 증상을 조율하는 데 시간을 보냄.
- 조직이 커지면서 브랜치는 늘어나고, 브랜치 병합 전략을 조율하는 데 더 많은 노력이 들어감.
- 일부 개발자는 빌드 마스터/머지 코디네이터/컨텐츠 관리 엔지니어가 됨.
- 대규모 병합이 되면 다른 개발 중인 브랜치들은 이를 또한 반영해야 하며 다시 테스트 해야 함.
- 이런 병합과 반복 테스트는 pure overhead.
- 패러다임의 전환이 필요.
- CI와 테스팅에 크게 의존하며, 빌드를 항상 그린으로 유지하고, 런타임에는 불완전하고/테스트되지 않은 피처는 비활성화 하는, 트렁크 기반의 개발을 권장.
- 하나의 Source of Truth만 있어야 함.
- 릴리즈를 위한 하나의 리비전만 있게 됨.
- 이는 1장에서 소개했던 "shift left"(이제서야 나오는 구나) 접근법.

### Release Branches

- 릴리즈 간격이 몇 시간 보다 길다면 릴리즈 브랜치를 만드는 게 합리적일 수도.
- 그리고 만약 릴리즈 사이에 큰 결함이 발견되면 트렁크에서 릴리즈 브랜치로 수정 사항을 cherry-pick.
- 개발 브랜치와 비교하면 릴리즈 브랜치는 일반적으로 무해함.
- 개발 브랜치와 릴리즈 브랜치의 주요 차이는 종료 상태.
- 릴리즈 브랜치는 결국엔 제거됨(abandoned).
- 하지만 개발 브랜치는 계속 트렁크로 병합되고, 다른 팀에 의해 추가적으로 분기되기도.
- 높은 수준의 조직에서는 릴리즈 브랜치가 거의 없다고 함.
- 지속적 배포(하루에도 여러 번 릴리즈)를 달성하는 곳은 릴리즈 브랜치를 생략하는 경향.
- 단순하게 수정을 반영하고 재배포 하는 것이 더 쉬움.
- cherry-pick과 브랜치는 불필요한 오버헤드.
- 물론, 고객에게 명시적인 릴리즈 결과물을 제공하는 곳에서는, 고객에게 정확히 무엇이 전달되었는지가 중요하기에, 이 방식의 적용은 어려울 수도.
- 복잡한 브랜치와 머지 전략은 생산성의 장애물.
- 트렁크를 안정된 상태로 유지하는 다른 방법들이 있음.

## Version Control at Google

- 구글에선 50,000명의 엔지니어가 공유하는 하나의 리포지토리를 사용(monorepo).
- 구글에서 진행하는 대부분의 프로젝트가 여기에 모여 있음. 오픈소스만 제외.
- Gmail 등의 공개 제품 외에 제품 개발을 지원하는 데 필요한 내부 인프라까지도 포함.
- Piper라고 불리는 중앙화된 인하우스 VCS를 사용.
- 하루에 보통 60,000 ~ 70,000개의 커밋이 일어남.
- 트렁크에 새로운 클라이언트를 생성하고, 파일을 추가하고, 리뷰되지 않은 변경을 커밋하는 것은 15초 정도 소요.
- 참고로, Piper는 사내에서 만들어 졌기에 커스터마이징도 쉬움.
- 리포지토리 하위 트리의 커밋들을 승인할 수 있는 엔지니어 이름이 적힌 OWNERS라는 파일들이 있음.
- 이를 활용해서 Piper가 소유/승인이 좀 더 잘 이뤄질 수 있게 하고 있음.

### One Version

- Piper 도구가 강력하긴 하지만, 그것만으로는 지금과 같은 협업은 어려움.
- "One Version"이라고 불리는 버전 컨트롤 '정책'이 필요.
- 이 정책은 "Single Source of Truth" 개념의 확장이며 아래와 같음.

> Developers must never have a choice of "What version of this component should I depend upon?

- 개인에겐 이런 선택의 제한이 장애물로 보일 수도.
- 그러나 조직 차원에서 이는 효율적인 스케일링의 매우 중요한 요소.

### (Nearly) No Long-Lived Branches

- One Version Rule에는 좀 더 깊은 생각과 정책들이 내포되어 있음.
- 그 중 가장 중요한 것은 아래와 같음.

> development branches should be minimal, or at best be very short lived

- Phoenix Project의 "reducing work-in-progress" 교훈은 개발 브랜치에 적용한 것.
- 트렁크에 작은 증분만이 이뤄져야 하고, 정기적으로 커밋 되어야 함.
- 그리고 준비 되기 전까지는 런타임에 비활성화 되어야 함.
- 더불어, 가능하다면 가시성을 통해 다른 개발자에게 숨겨져야.
- 혹은 두 의존성이 하나의 프로그램 내에서 공존할 수 있도록 설계되어야(패키지/클래스 명 등의 충돌이 없어야 한다는 의미로 들림).
- 구글에서는 1,000개 팀에서 이런 개발 브랜치를 가진 곳은 2군데.
- 흔한 일이 아니며 매우 특수한 이유를 가짐.

### What About Release Branches?

- 많은 구글팀에서 릴리즈 브랜치를 사용(제한된 체리 픽과 함께).
- 월간 릴리즈를 준비를 하면서 다음 릴리즈를 작업하는 경우에 이상적.
- 체리 픽을 최소화하고, 트렁크와의 재병합 계획은 금지.
- 아마도 여기서의 릴리즈 브랜치는, 트렁크에서 릴리즈 브랜치를 따고 그 릴리즈 브랜치로 배포가 나가는 형태인 것으로 보임.

## Monorepos

- One Version 유지를 쉽게 만들어 줌.
- 어떤 버전이 오피셜인지 결정하는 프로세스도 없고,
- 어떤 리포지토리를 봐야 하는지 고민할 필요도 없음.
- 빌드 도구 입장에서도 리포지토리를 고르는 절차 없음.
- 이런 일관성은 새로운 도구나 최적화 도입 등의 스케일링을 쉽게 도와줌.
- 엔지니어들의 코드나 시스템 디자인 결정을 공유하기도 쉬움.
- 다만, monorepo 방식이 결국엔 One Version을 위한 수단.
- 이 목적을 달성하기 쉽다면 다른 수단들도 충분한 대안이 될 수 있음.
