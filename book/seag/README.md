# Software Engineering at Google

# Thesis

# 1. What is Software Engineering?

프로그래밍과 소프트웨어 엔지니어링의 3가지 중요한 차이.

1. 시간
   - 수명이 길어질수록 변경이 많음.
   - 비즈니스, OS, 하드웨어, 언어 버전 등.
   - 이에 대응할 수 있는 것이 중요해짐.
   - 수명이 짧은 코드는 단지 프로그래밍 문제에 가까움.
2. 스케일
   - 프로그래밍 작업은 보통 개인의 작업.
   - 소프트웨어 엔지니어링은 팀의 노력.
   - 팀 협업은 개인 프로그래밍에 없던 여러 가지 새로운 문제를 안겨줌.
   - 하지만 혼자할 때에 비해, 좋은 시스템을 만들 가능성이 큼.
   - 제품, 조직, 개발 워크플로우의 규모가 커짐에 따른 비용을 잘 유지하고 관리해야 함.
3. 트레이드 오프
   - 종종 부정확한 가치 메트릭을 기반으로,
   - 상위 수준의 이해관계 결과물을 고려하며,
   - 여러 길 사이의 트레이드 오프를 고려한 복잡한 결정을 내려야 함.

## Time and Change

- 모바일 앱이나 스타트업의 코드 수명은 비교적 짧음.
- 하지만 구글 검색이나 Apache HTTP 프로젝트의 수명은 예측할 수 없음.
- 내부적으로는 indefinitely로 간주한다고 함. 
- 이런 수명이 긴 프로젝트에서는 업그레이드 문제가 중요.
- 이런 업그레이드를 고려하지 않다가 한 번에 업그레이드 하려는 경우 그 비용은 상당.
- 이 비용을 겪고 나면 후속 업그레이드도 크다고 느껴, 코드를 재작성하거나 아예 업그레이드 자체를 피하기도.
- 하지만 첫 번째 큰 업그레이드 이후에도 지속적으로 나아가는 것이 프로젝트의 장기 유지가능성의 핵심.
- 물론, 업그레이드가 제공하는 가치와 비용, 그리고 프로젝트의 기대 수명을 같이 고려해야.

### Hyrum's Law

다른 엔지니어들에게 사용되는 프로젝트를 맡고 있다면, Hyrum's Law가 "it works"와 "it is maintainable"의 차이에 대한 중요한 교훈이 됨.

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.

### Why Not Just Aim for "Nothing Changes"?

- 새로운 기능을 지속적으로 제공해야 하고
- 보안 취약점이 새로 발견되고
- 버그도 계속 발견됨
- CPU 등의 변경에 따라 최적화도 계속 달라짐
- 수명이 긴 프로젝트라면 변경을 피하기 어려움

## Scale and Efficiency

- 조직과 개발/운영 프로세스 역시 유지 가능해야 한다는 이야기.
- 조직이 커질 때, 그 조직의 반복 작업을 돕는 컴퓨팅 리소스도 함께 스케일링 되어야 함.
- 그렇지 않으면 작업 시간은 점점 늘어나고, 이는 작업을 미루게 되는 배경이 되기도.
- 지속 가능성을 위한 노력의 예시로는 아래와 같은 것들이 있음.
    - 조직 규모에 맞게 테스트 클러스터도 함께 확장 되어야 함.
    - 전체 빌드에 걸리는 시간, 리포지토리를 pull 받는 데 걸리는 시간도 커지지 않도록.
    - 새로운 버전의 랭귀지로 업그레이드 하는 데 걸리는 시간들도 마찬가지.
- 이런 문제들은 서서히 자라나며 잘 인식하지 못할 수 있음.
- [bolied frog](https://en.wikipedia.org/wiki/Boiling_frog#As_metaphor)를) 언급하며 이런 특징을 가진 문제들의 위험성을 강조.

### Policies That Don't Scale

- 조직이 커지거나 코드 베이스가 커질 때 일의 양도 같이 늘어난다면 not scale.
- 그 일의 자동화나 최적화를 하는 메커니즘이 적절한 곳에 있어야 함.
- 일반적인 deprecation 접근법을 스케일 문제의 예로 들고 있음.
- 새로운 위젯을 만들었다고 가정.
- 그리고 기존 것의 사용을 중단하고 새로운 것의 사용을 강제.
- 작은 소프트웨어에서는 이것이 가능할 수도.
- 그러나 의존성 그래프가 깊고 넓은 경우엔 실패하기 쉬움.
- 회사의 성장 속도를 저해하는 요인이 되기도.
- 대신, 하위 호환성을 유지하는 방식을 권장.
- 의존 프로젝트들은 더 이상 따라잡기 위한 급진적 노력을 기울이지 않아도 됨.

### Policies That Scale Well

- 한 가지 사례는 인프라스트럭처 팀의 안전한 변경을 보호하는 정책.

> If a product experiences outages or other problems as a result of infrastructure changes, but the issue wasn't surfaced by tests in out CI system, it is not the fault of the infrastructure change.

- 공통 CI 시스템에서 실행되지 않는 맞춤형의 복잡한 테스트는 신경쓰지 않는다는 것.
- 그렇지 않으면 인프라 팀은 영향 받는 모든 팀의 코드를 추적하고 테스트는 어떻게 했는지 일일이 물어봐야 함.
- 100명의 엔지니어가 있을 때는 이것이 가능했으나 규모가 커진 지금은 불가능.
- 대신, 공유된 커뮤니케이션 포럼과 전문 지식이 조직의 규모 확장에 도움.
- 엔지니어들이 공유 포럼에서 토론하고 질문에 응답하면서 지식이 전파되고 전문가들이 생겨남.

### Shifting Left

- 개발 단계의 앞 쪽에서 버그나 보안 이슈를 발견하고 대응할 수록,
- 더 적은 비용을 감수한다는 일반적인 이야기가 갑자기 나옴.
- 일반적으로 보던 개발 단계가 뒤로 갈수록 비용이 지수적으로 늘어나는 그래프도 소개.

## Trade-offs and Costs

- 프로그램을 작성, 소프트웨어의 생명주기, 엔지니어 규모 확장 시에도 소프트웨어를 유지하는 것을 이해했다면, 남은 것은 올바른 결정 내리기.
- 구글 내에서는 "내가 그렇게 말했기 때문"에 대한 강한 혐오감이 있음.
- 모든 것에는 이유가 있어야.
- 그리고 어느 주제든 결정자가 있어야 함.
- 잘못된 것 같아 보이는 결정에 대해서는 이의 제기.
- 다만 목표는 만장일치가 아니라 합의.
- 이런 의사 결정시에는 여러 비용을 고려해야 하는데,
- 재정적, 리소스 측면 등과 같은 것 뿐만 아니라 사회적 비용이나 구성원들의 만족감 같은 비용도 포함.

### Example: Markers

- 구글을 데이터 중심 문화라고 불러주지만 너무 단순화 된 얘기.
- 데이터가 없는 경우에는 증거, 선례, 논쟁으로 결정.
- 모든 가능한 선택지를 두고 트레이드 오프를 고려하며 현명한 결정을 내리려 노력.
- 때때로 직감이나 베스트 프랙틱스에 기반한 결정이 이뤄지기도 하지만, 근본적이고 실제적인 비용을 측정하거나 추정하는 모든 방식을 다 사용한 이후에나 가능.

### Inputs to Decision Making

- CPU와 네트워크 간 트레이드 오프 측정과 같이,
- 결정을 내리기 위한 데이터가 측정할 수 있거나 적어도 추정이 가능한 것들이 있음.
- 한편, 측정하기 어렵거나 측정 방법조차 모를 때도.
- 잘 설계 되지 못한 API가 가져오는 비용 측정이 그 예.
- 후자의 것도 측정하기 위한 노력을 하긴 하지만, 측정이나 예측하기 어렵다는 것도 인정하면서, 우선순위를 낮추지 않고 계속 다루려 노력해야 함.

### Example: Distributed Builds

- 로컬 빌드가 오래 걸려서 점점 문제가 됐음.
- 빌드를 최대한 빠르게 하는 방법을 고민하기 시작.
- 고성능 개발 장비는 대부분 유휴 상태이기 때문에 좋은 선택은 아니라고 판단.
- 구글은 자신들만의 분산 빌드 시스템을 만들었음.
- 물론, 이를 만드는 비용도 발생했고, 개발자들의 습관/워크플로우을 바꾸는 데에도 많은 시간이 걸림. 컴퓨팅 리소스는 당연.
- 하지만 전체적으로 아낄 수 있는 시간이 컸음.
- 그래서 헤피 엔딩이냐. 꼭 그런 것만은 아님.
- 로컬에서는 커지지 않게 신경 쓰던 의존성이 마구 늘어남.
- 실행 환경이 빠르기 때문에 신경 쓰지 않아도 문제가 되지 않았던 것.
- Jevons 역설.

### Example: Deciding Between Time and Scale

- 문제 해결을 위해 라이브러리 등의 의존성을 추가할 수도 있음.
- 또는 좀 더 요구에 들어맞도록 이를 포크/재개발을 할 수도 있음.
- 맞춤형은 새로운 기능을 추가하기도 쉽고, 최적화에도 유리. 의존성의 변경으로부터 자유롭기도.
- 하지만 모든 것을 직접하게 되면, 확장성과 더불어 지속가능성이 떨어짐.
- 보안 이슈를 단지 의존성 업데이트 만으로 해결할 수 없는 것이 그 예.

# 2. How to Work Well on Teams

- 구글 소프트웨어 엔지니어링의 문화적, 사회적 측면을 다루는 부분.
- 통제 가능한 변수인 우리 자신에 초점을 맞추는 것으로 시작.
- 소프트웨어 개발은 팀의 노력.
- 엔지니어링 팀의 성공을 위해 겸손, 존중, 신뢰 기반의 행동이 필요.

## Help Me Hide My Code

- 사람들은 자신이 작업 중인 것을, 다른 사람이 보고 판단하는 것을 두려워 하는 경향이 있다는 이야기.
- 이런 불안함은 더 큰 문제의 징후라는 얘기도 함.

## The Genius Myth

- 사람들은 우상을 찾고 숭배하려는 성향이 있음.
- 리누스 토발즈의 리눅스도 분명 그의 초기 작업이 훌륭하긴 했지만,
- 그 이후의 수 많은 똑똑한 사람들의 노력 없이는 불가능한 결과물.
- 그리고 많은 엔지니어들이 천재처럼 보이길 원한다고 함(하지만 대부분 천재는 아님).
- 이런 천재 신화는 위에서 말한 불안함의 또 다른 징후.
- 그래서 작업 중인 것을 공유하길 꺼려함.
- 천재 신화를 떠나, 단지 좋은 모습만을 보여주고자 하는 마음에, 이런 경향은 더 만연하다고 생각 됨.

## Hiding Considered Harmful

- 만약 모든 시간을 혼자 일하는 데 쓰고 있다면,
- 불필요한 실패의 위험을 키우고 성장의 기회를 날리는 것.
- 물론, 소프트웨어 개발이 깊은 집중력과 개인 시간을 어느 정도 필요로 하는 지적 작업이긴 하지만,
- 협업과 리뷰 역시 매우 중요한 요소.
- 무엇보다도 당신이 올바른 길을 가고 있는지를 어떻게 알 수 있겠는가?

### Early Detection

- 뭔가 완성되기 전까지 공개하는 것을 꺼리는 건 도박.
- 초반일수록 실수하기 쉬움.
- 제대로 하고 있는지를 다른 사람에게 피드백 받으며 반복 확인하고 수정해야 함.
- 처음이 갖는 리스크를 줄이는 일.
- "Fail early, fail fast, fail often"

### The Bus Factor

> the number of people that need to get hit by a bus before your project is completely doomed.

- 프로젝트의 지식과 노하우가 프로젝트에 얼마나 잘 분산되어 있는가?
- 만약, 당신이 프로토타입 코드가 동작하는 원리를 이해하는 유일한 사람이라면,
- 당신이 버스에 치이게 되었을 때 프로젝트는 위험.
- 두 명이서 같이 만들고 있다면 버스 팩터는 2배가 됨.
- 여러 명으로 된 팀으로 일한다면 더 나아짐.
- 영역 별로 2명 이상의 소유자를 갖는 것 외에도 좋은 문서를 두는 것이 프로젝트의 성공을 도움.

### Pace of Progress

- 컴파일하고 일할 때를 생각해보자.
- 한 번에 10,000 라인의 코드를 작성하고 컴파일 버튼을 누르는가?
- 결과는 재앙일 것.
- 프로그래머의 작업은 빽빽한 피드백 루프가 함께 할 때 제일 좋음.
- get feedback as early as possible, test as early as possible, and think about security and production environments as early as possible.
- 모두 "shifting left" 아이디어.
- 이는 코드 레벨 뿐만아니라 전체 프로젝트 레벨에서 필요한 이야기.
- 잘 되는 프로젝트는 빠르게 진화하며 시간이 지남에 따라 바뀌는 환경에 적응해야 함.
- 예상치 못한 설계 장애물이나 정치적 위험을 마주치거나, 단지 계획한 것이 제대로 되지 않기도.
- 요구사항은 계속 변경.
- 이렇게 계획이나 설계가 바로 바로 바뀌어야 한다는 피드백 루프를 어떻게 구성할 수 있을까?
- 답은 팀으로 일하는 것.
- "Many eyes make sure your project stays relevant and on track"

## It's All About the Team

> software engineering is a team endeavor

- 숨어서 비밀 발명품을 준비하는 것으로 세상을 바꾸는 것이 아님.
- 다른 사람들과 함께 일해야 함.
- 비전을 공유하고, 일을 나누고, 서로를 배우며, 훌륭한 팀을 만들어야 함.
- 혼자 만든 소프트웨어 중에 널리 사용되며 성공한 것은 없음.

### The Three Pillars of Social Interaction

- 협업을 잘하기 위해 "세가지 기둥<sup>three pillars</sup>"이라 부르는 사회적 기술을 익히라고 이야기.
- Pillar 1: Humility
  - 당신은 우주의 중심이 아님.
  - 당연히 코드의 중심도 아님.
  - 절대적으로 옳은 사람도 아니고 박식하지도 X.
  - 자기 발전에 열려 있어야.
- Pillar 2: Respect
  - 진심으로 같이 일하는 동료를 대해야 함.
  - 친절하게 대하고 그들의 능력과 성과에 감사해야 함.
- Pillar 3: Trust
  - 다른 사람이 뛰어나며 올바른 일을 할 것임을 믿어야 함.
  - 그리고 적절한 때에는 그들이 드라이빙 하도록 해 주어야.

### Why Do These Pillars Matter?

- 사회적 측면이 갖는 힘이 생각보다 큼.
- 일이 되게 하기 위해 관계를 맺는 것에 관함.
- 관계는 프로젝트보다 오래 지속됨.

### Humility, Respect, and Trust in Practice

- 구체적인 행동과 예시들을 다룸.
- 이 내용들을 보면 당연해 보일지도 모르나, 잘 안지켜지는 부분들일 것.

#### LOSE THE EGO

- 자신이 가장 중요한 인물이라고 생각하는 사람과는 같이 일하고 싶지 않음.
- 모든 이야기의 시작이나 끝맺음 말을 하고 싶어 한다거나,
- 모든 제안이나 토론의 세부 사항에 코멘트를 달아야 한다고 느끼는 등이 그 예.
- 물론 겸손이 중요하다고 해도 동네 북이 되라는 것은 아님.
- 자신감은 중요. 단지 다 아는 척 하려고 하지 말아야.
- 대신 "집단적" 에고를 가져야 함.
- 개인이 멋지게 보이는 것보다 팀의 성취.
- 에고는 여러 방식으로 그리고 여러 번 드러남.
- 이는 생산성을 방해하고 속도를 늦춤.

#### LEARN TO GIVE AND TAKE CRITICISM

- 개인적 비난이 아닌 프로젝트가 더 나아지게 하는 건설적 비판을 강조.
- 여기서 가장 중요한 건 존중. 상대방이나 그들의 작업이 개선되길 원하는 마음으로 진정성 있는 비판이 되어야.
- 한편, 비판을 잘 받아들일 수도 있어야 함.
- 이는 기술적 역량에 대해 겸손해 하는 것은 물론,
- 다른 사람이 당신의 이익을 중요시 여기며 당신을 바보로 생각하지 않는다고 믿는 것을 의미.
- 이를 위해 코드와 당신을 너무 동일시 여기지 않는 노력도 필요.
- "you are not your code"

#### FAIL FAST AND ITERATE

> if you're not failing now and then, you're not being innovative enough or taking enough risks.

#### Blameless Post-Mortem Culture

- 실수로부터 배우는 주요한 방법으로,
- 근본 원인<sup>root-cause</sup> 분석을 통해 실패를 문서화하고,
- 포스트모텀을 작성하는 것을 제시.
- 여기에는 무엇을 배웠고 그 결과로 어떤 행동의 변화를 취할지를 기술.
- 그리고 포스트모텀을 누구나 볼 수 있어야 하고,
- 제안된 변경이 이후에도 제대로 수행하는지 확인할 수 있어야 함.
- 다른 사람들도 이를 보고 문제를 반복하지 않을 수 있음.
- 좋은 포스트모텀은 아래의 7가지를 포함.
  1. 사건의 간단 설명
  2. 이벤트 타임라인(문제의 발견부터 해결까지)
  3. 이벤트의 근본 원인
  4. 영향/손실 측정
  5. 문제를 당장 고치기 위한 액션 아이템
  6. 문제 재발을 막기 위한 액션 아이템
  7. 배운 교훈

#### LEARN PATIENCE

- CSV가 가진 이상한 버그를 수정하고자,
- CSV에 바삭하며 오랜 동료인 Karl과 함께 작업을 시작.
- 하지만 저자는 bottom-up 방식이고 이것 저것 빠르게 시도해 보는 타입.
- 반면 동료는 top-down 엔지니어이고 전체를 살핀 뒤 세부로 들어가는 타입.
- 이로 인해 서로 많이 부딪히게 됨.
- 하지만 인내심을 가지고(?) 다른 협업 방식을 찾아냄.
- 같이 컴퓨터 앞에 앉아서 버그를 먼저 찾고, 문제를 쪼갠 뒤, 각자의 방식으로 서로 반대 방향으로 접근한 뒤, 서로 발견한 내용을 모음.

#### BE OPEN TO INFLUENCE

- 다른 사람들의 영향에 더 열려 있을 수록 당신의 영향력이 높아지고,
- 당신이 좀 더 취약할수록 더 강해질 수 있음.
- 주변에 고집 센 동료들을 생각해보면, 그들을 설득하려 할수록 자신의 길을 더 고수하고, 결국엔 사람들이 그들의 의견을 듣지 않고 장애물처럼 여기며 돌아가게 됨.
- 환경도 변하지 않고 지식도 완벽하지 않는 한, 모든 것에 당신이 올바르긴 어려움.
- 새로운 증거들이 보이면 마음을 바꿀 수 있어야.
- 결정을 확고히 내리기에 앞서 경청해야 하고, 제대로 전달하려면 제대로 들어야 함. 전투에는 신중할 것.
- 취약함을 드러내면 오히려 신뢰할 수 없는 사람이 될 걱정은 X.
- 이는 겸손, 책임을 지려는 의지, 다른 사람의 의견을 신뢰한다는 신호를 드러내는 한 가지 방식.
- 때로는 "모른다"고 말하는 게 최고.

### Being Googley

- 모호한 "Googley" 정의는 채용 인터뷰 등에서 문제가 됨.
- 그래서 아래와 같이 정의를 내렸다고 함.
- Thrives in ambiguity
  - 끊임없이 변화하는 환경 속에서도,
  - 방향이나 메시지의 충돌을 다루고,
  - 동의를 이끌어 내며,
  - 문제를 해결해 나갈 수 있음.
- Values feedback
  - 겸손하게 피드백을 주고 받을 수 있고,
  - 피드백이 개인과 팀의 발전에 얼마나 가치있는지를 이해.
- Challenges status quo
  - 도전적인 목표를 설정하고,
  - 다른 사람들의 저항이나 관습에도 그들을 설득할 수 있는 것.
- Puts the user first
  - 제품 사용자에 대한 존경과 공감을 갖고,
  - 사용자에게 가장 이익이 되는 행동을 추구.
- Cares about the team
  - 동료들에 대한 존경과 공감을 갖고,
  - 그들이 요청하는 것을 적극 돕고,
  - 팀의 응집력을 높임.
- Does the right thing
  - 자신이 하는 것에 윤리의식을 갖기.
  - 팀과 제품의 도덕성을 보호하기 위해 어렵거나 불편한 결정도 내리기.

# 5. How to Lead a Team

- 리더 없이는 어떤 팀도 제대로 동작 X.
- 특히 구글처럼 엔지니어링이 팀 노력인 곳에서는 더더욱.
- 구글에서는 리더십이 2가지.
- 매니저는 사람들의 리더, 테크 리드는 기술적 노력을 이끔.
- 선장이 없는 배는 목적 없이 표류하게 됨.
- 엔지니어 팀을 조종하는 사람이 없다면, 소중한 시간들을 날리게 되고, 그저 무슨 일이 일어나기를 기다릴 뿐(혹은 더 나쁜 상황은 필요하지도 않을 코드를 작성하는 것).

## Managers and Tech Leads (and Both)

- 엔지니어 팀마다 서로 다른 리더를 필요로 함.
- 초창기 팀에서는 TLM(Tech Lead Manager)가 두 가지 역할을 모두 수행.
- 좀 더 큰 팀에서는 경험 많은 인력 관리자가 관리 역할을 맡고,
- 경험이 풍부한 시니어 엔지니어는 테크 리드 역할을 수행.
- 두 역할 모두 팀의 성장과 생산성의 중요한 부분이지만,
- 이 둘에 필요로 하는 역량은 꽤나 다름.

### The Engineering Manager

- 구글에선 매니저가 엔지니어링 백그라운드를 가져야 한다고.
- 엔지니어링 매니저는 성능, 생산성, 팀원들의 행복감에 책임을 가짐.
- 이와 동시에 제품이 비즈니스 요구 사항을 충족하는지를 확인.
- 비즈니스의 요구와 개별 팀원들의 요구가 항상 일치하는 건 아님.
- 이는 종종 매니저를 어렵게 만드는 요인.

### The Tech Lead

- 제품의 기술적 측면을 책임짐.
- 기술적 의사결정, 아키텍처, 우선순위, 속도, 일반적인 관리들이 여기에 해당.
- TL은 엔지니어링 매니저와 협력하여, 팀 인력이 제품을 위해 적절히 배치 되었는지, 팀이 스킬 셋/수준에 부합하는 일을 맡고 있는지 등을 확인.
- TL은 본인이 직접 빠르게 일을 처리하거나 조금 느리더라도 팀원에게 위임하는 것 사이를 왔다 갔다 함.
- 보통은 후자가 팀의 규모나 역량을 키운다는 점에서 더 적합한 선택.

### The Tech Lead Manager

- 작은 팀 또는 초기 팀은 TLM을 두는 것을 기본으로 함.
- 사람과 기술 요구를 모두 다루는 역할.
- 좀 더 규모가 크고 잘 정립된 팀에서는 TL과 엔지니어링 매니저를 각각 두는데,
- 이는 번아웃 되지 않고서는 두 가지 일을 모두 잘 하기 어렵기 때문.
- 그래서 둘로 나누고 각자의 역할에 집중하게 함.
- TLM은 까다로운 직업이며 개인의 일과 위임, 그리고 인력 관리 사이의 균형을 잡을 수 있어야 함.

# 16. Version Control and Branch Management

- VCS는 필수라고 생각.
- 하지만 VCS 전략은 각 상황을 고려하여 선택해야.
- 여러가지 전략과 각각의 장단점을 소개할 예정.
- 그 중에서도 "trunk-based development"가 경험적으로 확장 가능했다고 언급.
- one repository, no dev branches의 의미.

## What is Version Control?

- 시간의 흐름에 따른 파일의 변경(버전)을 추적.
- 이런 파일들의 집합과 메타데이터를 리포지토리라고 부르며 VCS의 관리 대상.
- 여러 개발자가 동시에 작업할 수 있게 해줌.
- 파일을 한 번에 한 사람만 수정할 수 있게 하는 방식으로 이를 지원.
- 이전의 변경이 의도치 않게 덮어 쓰여지는 것을 방지하는 것.

### Why Is Version Control Important?

- 버저닝과 이를 활용한 취소.
- 여러 개발자들 간 또는 여러 시점 간 협업이 가능.
- 커밋은 부수적으로 행위의 변화를 가져오기도 함.
- 커밋 로그를 남기며 변경에 설명을 더하고, 커밋에 앞서 정적 분석이나 체크리스트를 확인하는 등의 행위를 유발시킴.
- VCS를 설치하고 설정하는 등의 단점도 있지만 상대적으로 매우 값싼 비용.

### Centralized VCS Versus Distributed VCS

생략

## Branch Management

- 대비되는 단어는 단일 "trunk"

### Work in Progress Is Akin to a Branch

- 진행 중인 작업은 모두 브랜치에 대응.
- 중앙집중형 VCS에서도 마찬가지.
- 커밋되지 않은 로컬 변경과 브랜치에 커밋된 것은 개념적으로 크게 다르지 않음.

### Dev Branches

- 지속적 단위 테스트가 없던 시절, 변경은 시스템에 대한 regression 위험을 가졌음.
- 이 때는 trunk를 특별한 것으로 간주하는 것이 이치에 맞았음.
- "우리 팀은 피처 개발 브랜치를 사용하고, 트렁크에 커밋하지 않는다"
- "새로운 변경이 모든 검증을 끝내고 난 뒤에야 트렁크로"
- 이것이 제품의 불안정성을 해결하기 위한 적절한 방법이기도 하지만,
- CI나 철저한 코드 리뷰 등의 품질 관리 노력이 더 나은 해결책이라고 주장.
- (이 품질 관리 노력이 어느 정도 수준인지가 중요할 듯. 좋은 해결책이 되기 어려운 수준일 수도)
- 광범위한 개발 브랜치의 사용이 제품 안정성을 위한 수단이 되는 것은 본질적으로 잘못된 것.
- 동일한 커밋들이 결국 트렁크에 병합됨.
- 작은 병합이 더 쉬움.
- 엔지니어는 자신이 작성한 변경을 병합하는 것이 쉬움.
- 관련 없는 변경들의 병합, 그리고 나중에 병합하는 것은 어려움.
- 병합에 대한 회귀 테스트의 실패 책임자가 누구인지 찾는 것도 쉬움.
- 대규모 병합은 문제의 격리를 더 어렵게 함.
- 수정은 더더욱 어려움.
- 규모 확장에도 심각한 위험.
- 병합 자체도 더욱 어려워지고 오래 걸리기 때문.

#### HOW DID WE BECOME ADDICTED TO DEV BRANCHES?

- 오래된 개발 브랜치를 병합하는 것은 안정성을 낮춘다고 판단.
- 그래서 브랜치 병합은 위험하다고 결론.
- 브랜치 기반 개발 전략을 버리고 테스팅으로 문제를 해결하지는 않음.
- 대신, 속도를 낮추고 증상을 조율하는 데 시간을 보냄.
- 조직이 커지면서 브랜치는 늘어나고, 브랜치 병합 전략을 조율하는 데 더 많은 노력이 들어감.
- 일부 개발자는 빌드 마스터/머지 코디네이터/컨텐츠 관리 엔지니어가 됨.
- 대규모 병합이 되면 다른 개발 중인 브랜치들은 이를 또한 반영해야 하며 다시 테스트 해야 함.
- 이런 병합과 반복 테스트는 pure overhead.
- 패러다임의 전환이 필요.
- CI와 테스팅에 크게 의존하며, 빌드를 항상 그린으로 유지하고, 런타임에는 불완전하고/테스트되지 않은 피처는 비활성화 하는, 트렁크 기반의 개발을 권장.
- 하나의 Source of Truth만 있어야 함.
- 릴리즈를 위한 하나의 리비전만 있게 됨.
- 이는 1장에서 소개했던 "shift left"(이제서야 나오는 구나) 접근법.

### Release Branches

- 릴리즈 간격이 몇 시간 보다 길다면 릴리즈 브랜치를 만드는 게 합리적일 수도.
- 그리고 만약 릴리즈 사이에 큰 결함이 발견되면 트렁크에서 릴리즈 브랜치로 수정 사항을 cherry-pick.
- 개발 브랜치와 비교하면 릴리즈 브랜치는 일반적으로 무해함.
- 개발 브랜치와 릴리즈 브랜치의 주요 차이는 종료 상태.
- 릴리즈 브랜치는 결국엔 제거됨(abandoned).
- 하지만 개발 브랜치는 계속 트렁크로 병합되고, 다른 팀에 의해 추가적으로 분기되기도.
- 높은 수준의 조직에서는 릴리즈 브랜치가 거의 없다고 함.
- 지속적 배포(하루에도 여러 번 릴리즈)를 달성하는 곳은 릴리즈 브랜치를 생략하는 경향.
- 단순하게 수정을 반영하고 재배포 하는 것이 더 쉬움.
- cherry-pick과 브랜치는 불필요한 오버헤드.
- 물론, 고객에게 명시적인 릴리즈 결과물을 제공하는 곳에서는, 고객에게 정확히 무엇이 전달되었는지가 중요하기에, 이 방식의 적용은 어려울 수도.
- 복잡한 브랜치와 머지 전략은 생산성의 장애물.
- 트렁크를 안정된 상태로 유지하는 다른 방법들이 있음.

## Version Control at Google

- 구글에선 50,000명의 엔지니어가 공유하는 하나의 리포지토리를 사용(monorepo).
- 구글에서 진행하는 대부분의 프로젝트가 여기에 모여 있음. 오픈소스만 제외.
- Gmail 등의 공개 제품 외에 제품 개발을 지원하는 데 필요한 내부 인프라까지도 포함.
- Piper라고 불리는 중앙화된 인하우스 VCS를 사용.
- 하루에 보통 60,000 ~ 70,000개의 커밋이 일어남.
- 트렁크에 새로운 클라이언트를 생성하고, 파일을 추가하고, 리뷰되지 않은 변경을 커밋하는 것은 15초 정도 소요.
- 참고로, Piper는 사내에서 만들어 졌기에 커스터마이징도 쉬움.
- 리포지토리 하위 트리의 커밋들을 승인할 수 있는 엔지니어 이름이 적힌 OWNERS라는 파일들이 있음.
- 이를 활용해서 Piper가 소유/승인이 좀 더 잘 이뤄질 수 있게 하고 있음.

### One Version

- Piper 도구가 강력하긴 하지만, 그것만으로는 지금과 같은 협업은 어려움.
- "One Version"이라고 불리는 버전 컨트롤 '정책'이 필요.
- 이 정책은 "Single Source of Truth" 개념의 확장이며 아래와 같음.

> Developers must never have a choice of "What version of this component should I depend upon?

- 개인에겐 이런 선택의 제한이 장애물로 보일 수도.
- 그러나 조직 차원에서 이는 효율적인 스케일링의 매우 중요한 요소.

### (Nearly) No Long-Lived Branches

- One Version Rule에는 좀 더 깊은 생각과 정책들이 내포되어 있음.
- 그 중 가장 중요한 것은 아래와 같음.

> development branches should be minimal, or at best be very short lived

- Phoenix Project의 "reducing work-in-progress" 교훈은 개발 브랜치에 적용한 것.
- 트렁크에 작은 증분만이 이뤄져야 하고, 정기적으로 커밋 되어야 함.
- 그리고 준비 되기 전까지는 런타임에 비활성화 되어야 함.
- 더불어, 가능하다면 가시성을 통해 다른 개발자에게 숨겨져야.
- 혹은 두 의존성이 하나의 프로그램 내에서 공존할 수 있도록 설계되어야(패키지/클래스 명 등의 충돌이 없어야 한다는 의미로 들림).
- 구글에서는 1,000개 팀에서 이런 개발 브랜치를 가진 곳은 2군데.
- 흔한 일이 아니며 매우 특수한 이유를 가짐.

### What About Release Branches?

- 많은 구글팀에서 릴리즈 브랜치를 사용(제한된 체리 픽과 함께).
- 월간 릴리즈를 준비를 하면서 다음 릴리즈를 작업하는 경우에 이상적.
- 체리 픽을 최소화하고, 트렁크와의 재병합 계획은 금지.
- 아마도 여기서의 릴리즈 브랜치는, 트렁크에서 릴리즈 브랜치를 따고 그 릴리즈 브랜치로 배포가 나가는 형태인 것으로 보임.

## Monorepos

- One Version 유지를 쉽게 만들어 줌.
- 어떤 버전이 오피셜인지 결정하는 프로세스도 없고,
- 어떤 리포지토리를 봐야 하는지 고민할 필요도 없음.
- 빌드 도구 입장에서도 리포지토리를 고르는 절차 없음.
- 이런 일관성은 새로운 도구나 최적화 도입 등의 스케일링을 쉽게 도와줌.
- 엔지니어들의 코드나 시스템 디자인 결정을 공유하기도 쉬움.
- 다만, monorepo 방식이 결국엔 One Version을 위한 수단.
- 이 목적을 달성하기 쉽다면 다른 수단들도 충분한 대안이 될 수 있음.
