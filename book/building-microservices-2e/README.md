# Building Microservices, 2nd Edition

두 번 읽었던 책인데 2판 나왔길래 아래 챕터들만 다시 읽어보는 것으로.

- CH1. What Are Microservices?
- CH2. How to Model Microservices?
- CH3. Splitting The Monolith
- CH6. Workflow
- CH10. From Monitoring to Observability
- CH12. Resiliency
- CH13. Scaling
- CH14. User Interfaces
- CH15. Organizational Structures

# Chapter 1. What Are Microservices?

## Microservices at a Glance

기본 개념.

- 독립적으로 배포 가능한 서비스.
- 이 서비스는 비즈니스 도메인을 모델링.
- 기능들을 캡슐화하며, 다른 서비스들이 네트워크를 통해 접근.
- 이들이 모여 전체 시스템을 구성.

SOA와의 관계.

- 물론 서비스 경계를 그리는 것에 대해 논란이 있고,
- 독립적 배포가 핵심이긴 하나,
- SOA의 한 형태.
- 특정 기술에 구애받지 않는 것이 한 가지 주요 이점.

캡슐화와 DB.

- 기능은 캡슐화되어 있고,
- 이 기능은 네트워크 엔드포인트를 통해 노출.
- 구현 세부 사항은 숨겨져 있다는 의미이며,
- 공유 DB가 없는 형태를 주로 가짐.
- 필요하면 각자 DB를 가지고 캡슐화.

정보 은닉과 변경.

- 외부 인터페이스로 노출하는 것을 제외하고는 정보를 가능한 숨김.
- 외부 인터페이스에 영향을 주지 않는 내부의 변경은 쉬우며,
- 이는 배포 독립성에 있어 핵심.
- 따라서 명확하고 안정적인 서비스 경계가 중요.
- 높은 응집도와 낮은 결합도.
- 이를 위한 한 가지 방법으로 헥사고날 아키텍처 언급.

## Key Concepts of Microservices

### Independent Deployability

- 다른 서비스의 배포 없이도,
- 한 서비스를 수정하고 배포할 수 있는 것.
- 이를 위해 서비스 간 낮은 결합도를 유지해야 함.
- 이는 서비스 간의 계약이 명시적이고, 잘 정의되어 있으며, 안정적이어야 함을 의미.
- 공유 DB 등의 선택은 이를 어렵게 만듦.

### Modeled Around a Business Domain

- 2개 이상의 마이크로서비스를 동시에 수정해야 하는 기능 출시는 비용이 큼.
- 관련 팀들이 같이 협업해야 하고, 새로운 버전의 배포 순서 등도 고려해야 함.
- 따라서 한 번에 한 곳만 바뀌는 경계 설정이 중요.
- 종종 3티어 아키텍처(presentation/business logic/data)를 만나게 되는데,
- 이 3티어 계층이 모두 같이 바뀌는 경우가 많음.
- 계층이 복잡해 질수록 문제는 더 심각.
- 기술적 응집력보다는 비즈니스적 응집력을 선호.

### Owning Their Own State

- 사람들이 가장 힘들어 하는 것이 공유 DB를 안 쓰는 것.
- 데이터의 소유자에게 데이터를 제공 받아야 함.
- 이런 식으로 숨겨야 할 것과 공유해야 하는 것을 잘 나누면,
- 하위호환성을 위한 비용을 절감할 수 있음.
- 앞에서 언급했든 같은 비즈니스 기능을 가진 것끼리 모아야 함.
- 비즈니스 관련 변경의 비용을 줄이는 것이 목적.
- DB 데이터 역시 마찬가지.

### Size

- 얼마나 작아야 하는지는 자주 나오는 질문.
- 하지만 실제 마이크로서비스에서는 그다지 관심사 주제가 아님.
- 그리고 크기 측정은 또 어떻게 할 것인지가 모호.
- 라인 수, 인터페이스의 수, 이해 가능한 정도 등 모두 한계가 있음.
- 이보다는 아래 2가지가 더 중요.
- 먼저, 마이크로서비스를 얼마나 많이 다룰 수 있는 역량이 되느냐(많을수록 복잡성도 증대).
- 다음으로, 서로 강하게 결합되지 않는 경계를 어떻게 나눌 것인가.

### Flexibility

> microservices buy you options.

- 서비스를 나누면 유연성이 올라감.
- 조직적, 기술적, 확장적, 강건적 유연성.
- 하지만 비용/복잡성도 함께 올라감.
- 따라서 선택의 문제.
- 저자는 점진적 적용을 권장.
- 가고 있는 길의 영향을 좀 더 판단하기 쉽고,
- 멈추거나 돌아오기도 쉽기 때문.

### Alignment of Architecture and Organization

> Organizations which design systems...are constrained to produce designs which are copies of the communication structures of these organizations.

- 콘웨이 법칙 이야기.
- 과거와 지금은 다름.
- 사일로 현상과 핸드오프를 줄이고,
- 더 빠르고 잦은 소프트웨어 출시를 바람.
- 기술 계층으로 팀을 구분하기보다,
- 비즈니스 경계로 팀을 구성.
- 다른 팀과의 커뮤니케이션 비용 없이도,
- 자율적으로 빠르게 원하는 기능을 결정하고 출시.
- 14, 15장에서 좀 더 자세히 다룸.

## The Monolith

- 일반적으로 마이크로서비스는 모놀리스의 대안.
- 이 둘의 비교가 마이크로서비스의 가치 판단에 도움.

### The Single-Process Monolith

- 가장 흔히 떠올리는 모놀리스.
- 단일 프로세스로 모든 코드가 배포되는 것.
- 그리고 스케일링 이유로 이 프로세스의 여러 인스턴스가 실행될 것.
- 많은 작은 조직에 적합한 모델.

### The Modular Monolith

- 단일 프로세스 모노리스가 점점 커지면서,
- 모듈러 모놀리스로 나아갈 수 있음.
- 단일 프로세스 안에 여러 모듈이 모여 있는 것.
- 모듈 경계가 잘 정의되어 있다면, 많은 조직들에게 매우 좋은 선택.
- 마이크로서비스에 비해 좀 더 쉽게 병렬 작업이 가능함.
- 좀 더 간단한 배포 토폴로지를 가지기 때문.
- 여기서 일어나는 문제는 보통 코드 레벨에서 DB 분해가 잘 안 된다는 것.
- 이는 나중에 마이크로서비스로 떼어낼 때 어려움으로 작동하곤 함.
- 그래서 미리 DB를 여러 개로 나눠두기도 함.

### The Distributed Monolith

- 분산 모놀리스는 시스템이 여러 개의 서비스로 구성되어 있긴 하나,
- 어떤 이유로든 모두가 한 번에 배포되는 것을 가리킴.
- 이 방식은 단일 프로세스 모놀리스의 단점과,
- 분산 시스템의 단점을 모두 가짐.
- 한편, 장점은 크게 취하지 못함.
- 이런 유형이 나타나는 이유는 보통 정보 은닉이나 비즈니스 응집성 등이 부족.
- 대신, 여러 서비스들 간 높은 결합도를 가지며 한 번에 여러 곳이 바뀌고 배포도 한 번에.

### Monoliths and Delivery Contention

- 소유권의 혼란.
- 여러 사람이 같은 코드를 동시에 수정하게 되고,
- 서로 다른 팀이 기능 출시에 함께 엮이거나,
- 누구의 소유인지 누가 결정을 내려야 하는지 혼란이 있는 것.
- 모놀리스라고 해서 무조건 이 문제를 겪는 건 아니지만,
- 마이크로서비스 환경에서는 이 문제가 훨씬 유연하며 쉽게 접근이 가능함.

### Advantages of Monoliths

- 단순한 배포 토폴로지는 분산 시스템이 갖는 여러 위험으로부터 자유로움.
- 개발 워크플로우가 간단하고, 모니터링, 트러블슈팅, 종단간 테스팅 등이 훨씬 쉬움.
- 코드 재사용성도 쉬움.
- 하지만 많은 이들이 모놀리스를 피해야 하는 것으로 바라보곤 함.
- 하지만 모놀리스는 분명한 아키텍처 선택지 중 하나.

## Enabling Technology

- 마이크로서비스의 적용에 있어 기술적인 부분은 생산성 측면에 있어 매우 중요.
- 뒤에서 자세히 다루기에 앞서 마이크로서비스 적용에 있어 필요한 몇 가지 기술들 간단히 소개.

### Log Aggregation and Distributed Tracing

- 로그 애그리게이션 시스템은 마이크로서비스 적용의 선행조건.
- 이것 없이는 트러블슈팅이 매우 어려움.
- 모든 서비스의 로그를 중앙 수집하고,
- 분석뿐만 아니라 알림 메커니즘에도 활용.
- 저자는 [Humio](https://www.humio.com/)를 선호한다고.
- 관련 호출들을 엮어주는 correlation ID를 구현하면 더 도움이 됨.

### Containers and Kubernetes

- 각 서비스를 격리된 환경에서 실행시키면,
- 한 서비스의 문제를 그 서비스로 제한할 수 있음.
- 가상화도 하나의 방법이지만 컨테이너가 좀 더 경량화 된 해결책.
- 경량화 된 만큼 속도(스케일링 등)나 비용 측면에서 유리.
- 이런 컨테이너가 많아지면 오케스트레이션을 위해 k8s도 고민.
- 하지만 컨테이너가 많지 않다면 k8s의 비용이 더 클 것.

### Streaming

- 서비스 별로 DB를 갖게 되어도 여전히 데이터 공유가 필요.
- 그리고 변경의 일괄 리포팅보다 실시간 반응을 더 선호.
- 이로 인해 스트리밍을 고려하게 됨.
- Kafka 등의 도구 이야기 간단히 언급.

### Public Cloud and Serverless

- 퍼블릭 클라우드 서비스들 이야기.
- 여러 관리형 서비스와 배포 도구들 제공.
- 서버리스 이야기도.

## Advantages of Microservices

- 분산 시스템이 갖는 많은 이점과 겹침.
- 여기에 정보 은닉과 도메인 주도 개발이 더해짐.

### Technology Heterogeneity

- 서비스마다 다른 기술을 사용할 수 있다는 이야기.
- 또한 이런 기술 세부사항들은 컨슈머나 업스트림 서비스들에게 은닉.
- 따라서 변경하기 쉬움.

### Robustness

- 벌크헤드.
- 한 서비스의 장애가 다른 곳으로 전파되지만 않는다면,
- 문제를 그 한 곳으로 격리시킬 수 있음.
- 하지만 새로운 장애/실패 원인이 늘어남에 유의.
- 네트워크는 언제든 실패할 수 있음.
- 이런 실패가 일어날 수 있음을 받아들이고.
- 이런 문제 역시 전파되지 않는 구조를 고민해야.

### Scaling

- 모놀리스에서는 모든 게 함께 스케일링.
- 하지만 필요한 부분만 선택적으로 스켕일링 가능.
- 비용 측면에서 효율적.

### Ease of Deployment

- 모놀리스에서는 일부만 바뀌어도 전체 애플리케이션을 배포.
- 영향 범위와 리스크가 큼.
- 이로 인해 배포를 꺼려하는 경향도.
- 릴리즈 주기가 길어지며 영향과 리스크는 더욱 증가.
- 마이크로서비스에서는 필요한 부분만을 빠르게 배포.
- 변경의 속도도 올라가고 위험도 국소화.

### Organizational Alignment

- 코드와 팀의 규모가 크면 여러 생산성이 낮아짐.
- 서로 다른 팀이 섞이면 문제는 더 심각.
- 마이크로서비스에서는 조직과 아키텍처 경계를 일치시키기 쉬움.
- 생산성이 올라가고 집중하기 좋은 환경이 될 수 있음.
- 나중에 15장 좀 더 자세히 읽어보자.

### Composability

- 지금 시대에는 여러 서비스 채널(웹, 스마트폰, 태블릿, ...)이 존재.
- 마이크로서비스는 이런 환경에서의 재사용성을 높이고,
- 여러 조합으로 외부의 변화에 유연하게 대응.

## Microservice Pain Points

- 많은 장점과 더불어 높은 복잡도를 가져옴.
- 따라서 이 편익을 계산할 수 있어야.

### Developer Experience

- 개인 장비에서 띄울 수 있는 서비스의 수는 제한적.
- 이를 극복하는 극단적 방법 중 하나는 클라우드에서 개발하는 것.
- 하지만 피드백 주기가 느려지고 이는 생산성 문제로 이어짐.
- 그래서 개발자가 작업해야 하는 시스템의 범위를 한정하는 것이 현실적.
- 하지만 집단적 소유권<sup>collective ownership</sup>을 수용하려는 조직에서는 어령루 수도.

### Technology Overload

- 여러 필요한 기술들이 부담으로 다가올 수도.
- 꽤 많은 과거의 기술들이 단지 마이크로서비스 친화적이라고 브랜딩만 새로 하는 경우가 많다고 함.
- 마이크로서비스의 도입과 함께 기술 숭배를 펼치기도.
- 하지만 필수가 아닌 것들이 많음.
- 균형을 잡아야 함.
- 점진적으로 마이크로서비스를 도입하면서,
- 필요에 따라 조금씩 새로운 기술을 도입하는 방식을 권장.

### Cost

- 단기적으로는 비용이 늘어남.
- 더 많은 프로세스, 컴퓨터, 네트워크, 저장소, 지원 도구들(라이센스 비용으로 이어짐)이 필요.
- 조직의 생산성도 단기적으로 느려짐.
- 새로운 기술과 개념들을 적응해야 하므로.
- 비용은 늘어나는 대신 더 많은 고객을 만나고 수익을 올리는 데 도움.

### Reporting

- DB가 하나일 때는 조인 등을 통해 쉽게 데이터 확인이 가능.
- DB가 분리되면 스트리밍을 통해 실시간 리포팅을 구성하기도.
- 혹은 중앙 리포팅 DB를 만들고 여기로 데이터를 발행할 수도.

### Monitoring and Troubleshooting

- 1개의 단일 서비스 인스턴스가 내려갔다면, 이 영향을 어떻게 이해해야 할까?
- 수십 수백개의 프로세스가 있을 때는 다른 접근법이 필요.
- CH10에서 다룰 내용들.

### Security

- 한 프로세스 내에서만 돌던 데이터가,
- 이제는 서비스들 간 네트워크를 통해 이동함.
- 중간에 데이터가 노출될 수도, 조작될 수도 있음.
- 여러가지 보호 수단이 필요.

### Testing

- MSA에서 종단간 테스트는 매우 규모가 큼.
- 여러 프로세스에 걸쳐 테스트를 실행해야 하며,
- 모두 배포되어야 하고 적절히 설정되어 있어야 함.
- 잘못된 배포로 인한 네트워크 탐임아웃이나 서비스 인스턴스 다운 등,
- 환경적 이유로 거짓 음성(테스트 실패)이 나온 건 아닌지도 확인해야 함.
- MSA 규모가 점점 더 커지면 종단간 테스트의 투자 대비 수익은 점점 낮아짐.
- 따라서 계약 주도 테스팅이나 프로덕션에서의 테스팅 등 새로운 형태의 테스트가 필요.
- 병렬 실행이나 카나리 배포 등 새로운 배포 기법도 필요.

### Latency

- 로컬에 함께 있던 것들이 쪼개짐.
- 따라서 네트워크 전송이 일어남.
- 시스템의 지연으로 이어짐.
- 이 지연을 정확히 예상하긴 어려우므로,
- 이 역시 점진적인 MSA 적용의 한 가지 이유가 됨.
- 조금씩 옮겨가며 그 영향을 확인하고 조치를 취해 리스크를 제한.
- 더불어 지연을 수용할 만한 곳은 어디인지 등의 판단도 함께 필요.

> make a small change and the measure the impact.

### Data Consistency

- DB가 쪼개지다 보니 데이터 일관성 문제가 생기기 마련.
- DB가 제공해 주는 트랜잭션 사용이 불가하기 때문.
- 그리고 분산 트랜잭션은 대부분의 경우에 큰 문제가 됨.
- 사가 패턴을 대안으로 제시.
- 결과적 일관성도 대안.
- 점진적 접근 필요성 또 언급.

## Should I Use Microservices?

- 앞서 언급한 많은 도전과제들 때문에,
- MSA의 도입은 신중한 것이 좋다고 함.
- 자기 자신이 처한 문제 영역, 역량, 기술적 배경, 공감대 등 고려해야 할 것이 많음.
- MSA는 여러 선택지 중 하나.

### Whom They Might Not Work For

- 새로운 제품이나 스타트업들에게 MSA는 X.
- 서비스 경계를 건드리는 변경이 많이 일어나긴 때문.
- 도메인 모델이 어느 정도 안정된 상태에서 적용하는 것을 권장.
- 무조건 성공할 것이라 확신하며 처음부터 MSA를 하는 사람도 있지만,
- 고객이 이 새로운 제품을 사용할지는 미지수이며,
- 결과적으로 완성된 모습은 처음의 의도와는 완전히 다를 수도.
- 또한 인력이 적은 곳에서는 MSA를 위해 필요한 일들이 부담으로 작용할 수 있음.
- "microservice tax"
- 이 세금을 지금 지불할 만한 가치가 있는 상황인지 판단 필요.
- 배포나 관리를 고객이 하는 경우도 있음.

### Where They Work Well

- 저자의 경험상, MSA를 하는 가장 큰 이유는,
- 더 많은 개발자들이 서로 방해 없이 같은 시스템을 개발하는 것.
- 조직과 아키텍처 경계를 올바르게 세우기만 한다면,
- 서로 독립적으로 일하며 배포 경합 등의 문제를 피해갈 수 있음.
- SaaS 애플리케이션이 MSA 적합하다는 이야기도.
- 서비스 별 기술 선택이 좀 더 자율적이기에 퍼블릭 클라우드 활용과도 잘 어울림.
- 다양한 새로운 채널을 통해 고객에게 서비스를 제공해야 하는 곳에도.
- 무엇보다, 시스템 성장과 함께 유연성을 제공할 수 있다는 것이 큰 장점.
- 물론 그 유연성에는 비용이 뒤따르지만, 미래의 선택에 열려있을 수 있음.

# Chapter 2. How to Model Microservices

## What Makes a Good Microservice Boundary?

- 한 마이크로 서비스의 변경이 다른 서비스들과 격리되는 것은 매우 중요.
- 독립적인 변경, 배포, 릴리즈가 가능해야 함.
- 이 관점에서 서비스들 간 경계는 어떻게 나눠야 할까?
- 이 경계 식별은 근본적으로 모듈의 분해와 유사.
- 다만 모델 간에 서로 네트워크로 통신한다는 점이 차이.
- 따라서 모듈 분해에 중요한 요소를 활용할 수 있음.
- 여기서는 3가지인 정보 은닉, 응집력, 결합도 이야기.
