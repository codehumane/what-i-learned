# Building Microservices, 2nd Edition

두 번 읽었던 책인데 2판 나왔길래 아래 챕터들만 다시 읽어보는 것으로.

- CH1. What Are Microservices?
- CH2. How to Model Microservices?
- CH3. Splitting The Monolith
- CH6. Workflow
- CH10. From Monitoring to Observability
- CH12. Resiliency
- CH13. Scaling
- CH14. User Interfaces
- CH15. Organizational Structures

# Chapter 1. What Are Microservices?

## Microservices at a Glance

기본 개념.

- 독립적으로 배포 가능한 서비스.
- 이 서비스는 비즈니스 도메인을 모델링.
- 기능들을 캡슐화하며, 다른 서비스들이 네트워크를 통해 접근.
- 이들이 모여 전체 시스템을 구성.

SOA와의 관계.

- 물론 서비스 경계를 그리는 것에 대해 논란이 있고,
- 독립적 배포가 핵심이긴 하나,
- SOA의 한 형태.
- 특정 기술에 구애받지 않는 것이 한 가지 주요 이점.

캡슐화와 DB.

- 기능은 캡슐화되어 있고,
- 이 기능은 네트워크 엔드포인트를 통해 노출.
- 구현 세부 사항은 숨겨져 있다는 의미이며,
- 공유 DB가 없는 형태를 주로 가짐.
- 필요하면 각자 DB를 가지고 캡슐화.

정보 은닉과 변경.

- 외부 인터페이스로 노출하는 것을 제외하고는 정보를 가능한 숨김.
- 외부 인터페이스에 영향을 주지 않는 내부의 변경은 쉬우며,
- 이는 배포 독립성에 있어 핵심.
- 따라서 명확하고 안정적인 서비스 경계가 중요.
- 높은 응집도와 낮은 결합도.
- 이를 위한 한 가지 방법으로 헥사고날 아키텍처 언급.

## Key Concepts of Microservices

### Independent Deployability

- 다른 서비스의 배포 없이도,
- 한 서비스를 수정하고 배포할 수 있는 것.
- 이를 위해 서비스 간 낮은 결합도를 유지해야 함.
- 이는 서비스 간의 계약이 명시적이고, 잘 정의되어 있으며, 안정적이어야 함을 의미.
- 공유 DB 등의 선택은 이를 어렵게 만듦.

### Modeled Around a Business Domain

- 2개 이상의 마이크로서비스를 동시에 수정해야 하는 기능 출시는 비용이 큼.
- 관련 팀들이 같이 협업해야 하고, 새로운 버전의 배포 순서 등도 고려해야 함.
- 따라서 한 번에 한 곳만 바뀌는 경계 설정이 중요.
- 종종 3티어 아키텍처(presentation/business logic/data)를 만나게 되는데,
- 이 3티어 계층이 모두 같이 바뀌는 경우가 많음.
- 계층이 복잡해 질수록 문제는 더 심각.
- 기술적 응집력보다는 비즈니스적 응집력을 선호.

### Owning Their Own State

- 사람들이 가장 힘들어 하는 것이 공유 DB를 안 쓰는 것.
- 데이터의 소유자에게 데이터를 제공 받아야 함.
- 이런 식으로 숨겨야 할 것과 공유해야 하는 것을 잘 나누면,
- 하위호환성을 위한 비용을 절감할 수 있음.
- 앞에서 언급했든 같은 비즈니스 기능을 가진 것끼리 모아야 함.
- 비즈니스 관련 변경의 비용을 줄이는 것이 목적.
- DB 데이터 역시 마찬가지.

### Size

- 얼마나 작아야 하는지는 자주 나오는 질문.
- 하지만 실제 마이크로서비스에서는 그다지 관심사 주제가 아님.
- 그리고 크기 측정은 또 어떻게 할 것인지가 모호.
- 라인 수, 인터페이스의 수, 이해 가능한 정도 등 모두 한계가 있음.
- 이보다는 아래 2가지가 더 중요.
- 먼저, 마이크로서비스를 얼마나 많이 다룰 수 있는 역량이 되느냐(많을수록 복잡성도 증대).
- 다음으로, 서로 강하게 결합되지 않는 경계를 어떻게 나눌 것인가.

### Flexibility

> microservices buy you options.

- 서비스를 나누면 유연성이 올라감.
- 조직적, 기술적, 확장적, 강건적 유연성.
- 하지만 비용/복잡성도 함께 올라감.
- 따라서 선택의 문제.
- 저자는 점진적 적용을 권장.
- 가고 있는 길의 영향을 좀 더 판단하기 쉽고,
- 멈추거나 돌아오기도 쉽기 때문.

### Alignment of Architecture and Organization

> Organizations which design systems...are constrained to produce designs which are copies of the communication structures of these organizations.

- 콘웨이 법칙 이야기.
- 과거와 지금은 다름.
- 사일로 현상과 핸드오프를 줄이고,
- 더 빠르고 잦은 소프트웨어 출시를 바람.
- 기술 계층으로 팀을 구분하기보다,
- 비즈니스 경계로 팀을 구성.
- 다른 팀과의 커뮤니케이션 비용 없이도,
- 자율적으로 빠르게 원하는 기능을 결정하고 출시.
- 14, 15장에서 좀 더 자세히 다룸.

## The Monolith

- 일반적으로 마이크로서비스는 모놀리스의 대안.
- 이 둘의 비교가 마이크로서비스의 가치 판단에 도움.

### The Single-Process Monolith

- 가장 흔히 떠올리는 모놀리스.
- 단일 프로세스로 모든 코드가 배포되는 것.
- 그리고 스케일링 이유로 이 프로세스의 여러 인스턴스가 실행될 것.
- 많은 작은 조직에 적합한 모델.

### The Modular Monolith

- 단일 프로세스 모노리스가 점점 커지면서,
- 모듈러 모놀리스로 나아갈 수 있음.
- 단일 프로세스 안에 여러 모듈이 모여 있는 것.
- 모듈 경계가 잘 정의되어 있다면, 많은 조직들에게 매우 좋은 선택.
- 마이크로서비스에 비해 좀 더 쉽게 병렬 작업이 가능함.
- 좀 더 간단한 배포 토폴로지를 가지기 때문.
- 여기서 일어나는 문제는 보통 코드 레벨에서 DB 분해가 잘 안 된다는 것.
- 이는 나중에 마이크로서비스로 떼어낼 때 어려움으로 작동하곤 함.
- 그래서 미리 DB를 여러 개로 나눠두기도 함.

### The Distributed Monolith

- 분산 모놀리스는 시스템이 여러 개의 서비스로 구성되어 있긴 하나,
- 어떤 이유로든 모두가 한 번에 배포되는 것을 가리킴.
- 이 방식은 단일 프로세스 모놀리스의 단점과,
- 분산 시스템의 단점을 모두 가짐.
- 한편, 장점은 크게 취하지 못함.
- 이런 유형이 나타나는 이유는 보통 정보 은닉이나 비즈니스 응집성 등이 부족.
- 대신, 여러 서비스들 간 높은 결합도를 가지며 한 번에 여러 곳이 바뀌고 배포도 한 번에.

### Monoliths and Delivery Contention

- 소유권의 혼란.
- 여러 사람이 같은 코드를 동시에 수정하게 되고,
- 서로 다른 팀이 기능 출시에 함께 엮이거나,
- 누구의 소유인지 누가 결정을 내려야 하는지 혼란이 있는 것.
- 모놀리스라고 해서 무조건 이 문제를 겪는 건 아니지만,
- 마이크로서비스 환경에서는 이 문제가 훨씬 유연하며 쉽게 접근이 가능함.

### Advantages of Monoliths

- 단순한 배포 토폴로지는 분산 시스템이 갖는 여러 위험으로부터 자유로움.
- 개발 워크플로우가 간단하고, 모니터링, 트러블슈팅, 종단간 테스팅 등이 훨씬 쉬움.
- 코드 재사용성도 쉬움.
- 하지만 많은 이들이 모놀리스를 피해야 하는 것으로 바라보곤 함.
- 하지만 모놀리스는 분명한 아키텍처 선택지 중 하나.

## Enabling Technology

- 마이크로서비스의 적용에 있어 기술적인 부분은 생산성 측면에 있어 매우 중요.
- 뒤에서 자세히 다루기에 앞서 마이크로서비스 적용에 있어 필요한 몇 가지 기술들 간단히 소개.

### Log Aggregation and Distributed Tracing

- 로그 애그리게이션 시스템은 마이크로서비스 적용의 선행조건.
- 이것 없이는 트러블슈팅이 매우 어려움.
- 모든 서비스의 로그를 중앙 수집하고,
- 분석뿐만 아니라 알림 메커니즘에도 활용.
- 저자는 [Humio](https://www.humio.com/)를 선호한다고.
- 관련 호출들을 엮어주는 correlation ID를 구현하면 더 도움이 됨.

### Containers and Kubernetes

- 각 서비스를 격리된 환경에서 실행시키면,
- 한 서비스의 문제를 그 서비스로 제한할 수 있음.
- 가상화도 하나의 방법이지만 컨테이너가 좀 더 경량화 된 해결책.
- 경량화 된 만큼 속도(스케일링 등)나 비용 측면에서 유리.
- 이런 컨테이너가 많아지면 오케스트레이션을 위해 k8s도 고민.
- 하지만 컨테이너가 많지 않다면 k8s의 비용이 더 클 것.

### Streaming

- 서비스 별로 DB를 갖게 되어도 여전히 데이터 공유가 필요.
- 그리고 변경의 일괄 리포팅보다 실시간 반응을 더 선호.
- 이로 인해 스트리밍을 고려하게 됨.
- Kafka 등의 도구 이야기 간단히 언급.

### Public Cloud and Serverless

- 퍼블릭 클라우드 서비스들 이야기.
- 여러 관리형 서비스와 배포 도구들 제공.
- 서버리스 이야기도.

## Advantages of Microservices

- 분산 시스템이 갖는 많은 이점과 겹침.
- 여기에 정보 은닉과 도메인 주도 개발이 더해짐.

### Technology Heterogeneity

- 서비스마다 다른 기술을 사용할 수 있다는 이야기.
- 또한 이런 기술 세부사항들은 컨슈머나 업스트림 서비스들에게 은닉.
- 따라서 변경하기 쉬움.

### Robustness

- 벌크헤드.
- 한 서비스의 장애가 다른 곳으로 전파되지만 않는다면,
- 문제를 그 한 곳으로 격리시킬 수 있음.
- 하지만 새로운 장애/실패 원인이 늘어남에 유의.
- 네트워크는 언제든 실패할 수 있음.
- 이런 실패가 일어날 수 있음을 받아들이고.
- 이런 문제 역시 전파되지 않는 구조를 고민해야.

### Scaling

- 모놀리스에서는 모든 게 함께 스케일링.
- 하지만 필요한 부분만 선택적으로 스켕일링 가능.
- 비용 측면에서 효율적.

### Ease of Deployment

- 모놀리스에서는 일부만 바뀌어도 전체 애플리케이션을 배포.
- 영향 범위와 리스크가 큼.
- 이로 인해 배포를 꺼려하는 경향도.
- 릴리즈 주기가 길어지며 영향과 리스크는 더욱 증가.
- 마이크로서비스에서는 필요한 부분만을 빠르게 배포.
- 변경의 속도도 올라가고 위험도 국소화.

### Organizational Alignment

- 코드와 팀의 규모가 크면 여러 생산성이 낮아짐.
- 서로 다른 팀이 섞이면 문제는 더 심각.
- 마이크로서비스에서는 조직과 아키텍처 경계를 일치시키기 쉬움.
- 생산성이 올라가고 집중하기 좋은 환경이 될 수 있음.
- 나중에 15장 좀 더 자세히 읽어보자.

### Composability

- 지금 시대에는 여러 서비스 채널(웹, 스마트폰, 태블릿, ...)이 존재.
- 마이크로서비스는 이런 환경에서의 재사용성을 높이고,
- 여러 조합으로 외부의 변화에 유연하게 대응.

## Microservice Pain Points

- 많은 장점과 더불어 높은 복잡도를 가져옴.
- 따라서 이 편익을 계산할 수 있어야.

### Developer Experience

- 개인 장비에서 띄울 수 있는 서비스의 수는 제한적.
- 이를 극복하는 극단적 방법 중 하나는 클라우드에서 개발하는 것.
- 하지만 피드백 주기가 느려지고 이는 생산성 문제로 이어짐.
- 그래서 개발자가 작업해야 하는 시스템의 범위를 한정하는 것이 현실적.
- 하지만 집단적 소유권<sup>collective ownership</sup>을 수용하려는 조직에서는 어령루 수도.

### Technology Overload

- 여러 필요한 기술들이 부담으로 다가올 수도.
- 꽤 많은 과거의 기술들이 단지 마이크로서비스 친화적이라고 브랜딩만 새로 하는 경우가 많다고 함.
- 마이크로서비스의 도입과 함께 기술 숭배를 펼치기도.
- 하지만 필수가 아닌 것들이 많음.
- 균형을 잡아야 함.
- 점진적으로 마이크로서비스를 도입하면서,
- 필요에 따라 조금씩 새로운 기술을 도입하는 방식을 권장.

### Cost

- 단기적으로는 비용이 늘어남.
- 더 많은 프로세스, 컴퓨터, 네트워크, 저장소, 지원 도구들(라이센스 비용으로 이어짐)이 필요.
- 조직의 생산성도 단기적으로 느려짐.
- 새로운 기술과 개념들을 적응해야 하므로.
- 비용은 늘어나는 대신 더 많은 고객을 만나고 수익을 올리는 데 도움.

### Reporting

- DB가 하나일 때는 조인 등을 통해 쉽게 데이터 확인이 가능.
- DB가 분리되면 스트리밍을 통해 실시간 리포팅을 구성하기도.
- 혹은 중앙 리포팅 DB를 만들고 여기로 데이터를 발행할 수도.

### Monitoring and Troubleshooting

- 1개의 단일 서비스 인스턴스가 내려갔다면, 이 영향을 어떻게 이해해야 할까?
- 수십 수백개의 프로세스가 있을 때는 다른 접근법이 필요.
- CH10에서 다룰 내용들.

### Security

- 한 프로세스 내에서만 돌던 데이터가,
- 이제는 서비스들 간 네트워크를 통해 이동함.
- 중간에 데이터가 노출될 수도, 조작될 수도 있음.
- 여러가지 보호 수단이 필요.

### Testing

- MSA에서 종단간 테스트는 매우 규모가 큼.
- 여러 프로세스에 걸쳐 테스트를 실행해야 하며,
- 모두 배포되어야 하고 적절히 설정되어 있어야 함.
- 잘못된 배포로 인한 네트워크 탐임아웃이나 서비스 인스턴스 다운 등,
- 환경적 이유로 거짓 음성(테스트 실패)이 나온 건 아닌지도 확인해야 함.
- MSA 규모가 점점 더 커지면 종단간 테스트의 투자 대비 수익은 점점 낮아짐.
- 따라서 계약 주도 테스팅이나 프로덕션에서의 테스팅 등 새로운 형태의 테스트가 필요.
- 병렬 실행이나 카나리 배포 등 새로운 배포 기법도 필요.

### Latency

- 로컬에 함께 있던 것들이 쪼개짐.
- 따라서 네트워크 전송이 일어남.
- 시스템의 지연으로 이어짐.
- 이 지연을 정확히 예상하긴 어려우므로,
- 이 역시 점진적인 MSA 적용의 한 가지 이유가 됨.
- 조금씩 옮겨가며 그 영향을 확인하고 조치를 취해 리스크를 제한.
- 더불어 지연을 수용할 만한 곳은 어디인지 등의 판단도 함께 필요.

> make a small change and the measure the impact.

### Data Consistency

- DB가 쪼개지다 보니 데이터 일관성 문제가 생기기 마련.
- DB가 제공해 주는 트랜잭션 사용이 불가하기 때문.
- 그리고 분산 트랜잭션은 대부분의 경우에 큰 문제가 됨.
- 사가 패턴을 대안으로 제시.
- 결과적 일관성도 대안.
- 점진적 접근 필요성 또 언급.

## Should I Use Microservices?

- 앞서 언급한 많은 도전과제들 때문에,
- MSA의 도입은 신중한 것이 좋다고 함.
- 자기 자신이 처한 문제 영역, 역량, 기술적 배경, 공감대 등 고려해야 할 것이 많음.
- MSA는 여러 선택지 중 하나.

### Whom They Might Not Work For

- 새로운 제품이나 스타트업들에게 MSA는 X.
- 서비스 경계를 건드리는 변경이 많이 일어나긴 때문.
- 도메인 모델이 어느 정도 안정된 상태에서 적용하는 것을 권장.
- 무조건 성공할 것이라 확신하며 처음부터 MSA를 하는 사람도 있지만,
- 고객이 이 새로운 제품을 사용할지는 미지수이며,
- 결과적으로 완성된 모습은 처음의 의도와는 완전히 다를 수도.
- 또한 인력이 적은 곳에서는 MSA를 위해 필요한 일들이 부담으로 작용할 수 있음.
- "microservice tax"
- 이 세금을 지금 지불할 만한 가치가 있는 상황인지 판단 필요.
- 배포나 관리를 고객이 하는 경우도 있음.

### Where They Work Well

- 저자의 경험상, MSA를 하는 가장 큰 이유는,
- 더 많은 개발자들이 서로 방해 없이 같은 시스템을 개발하는 것.
- 조직과 아키텍처 경계를 올바르게 세우기만 한다면,
- 서로 독립적으로 일하며 배포 경합 등의 문제를 피해갈 수 있음.
- SaaS 애플리케이션이 MSA 적합하다는 이야기도.
- 서비스 별 기술 선택이 좀 더 자율적이기에 퍼블릭 클라우드 활용과도 잘 어울림.
- 다양한 새로운 채널을 통해 고객에게 서비스를 제공해야 하는 곳에도.
- 무엇보다, 시스템 성장과 함께 유연성을 제공할 수 있다는 것이 큰 장점.
- 물론 그 유연성에는 비용이 뒤따르지만, 미래의 선택에 열려있을 수 있음.

# Chapter 2. How to Model Microservices

## What Makes a Good Microservice Boundary?

- 한 마이크로 서비스의 변경이 다른 서비스들과 격리되는 것은 매우 중요.
- 독립적인 변경, 배포, 릴리즈가 가능해야 함.
- 이 관점에서 서비스들 간 경계는 어떻게 나눠야 할까?
- 이 경계 식별은 근본적으로 모듈의 분해와 유사.
- 다만 모델 간에 서로 네트워크로 통신한다는 점이 차이.
- 따라서 모듈 분해에 중요한 요소를 활용할 수 있음.
- 여기서는 3가지인 정보 은닉, 응집력, 결합도 이야기.

### Information Hiding

- 가능한 세부사항을 모듈 안으로 숨기는 것.
- 정보은닉의 이점으로 3가지를 꼽음.
- 먼저, Improved development time.
- 모듈을 독립적으로 개발할 수 있으므로,
- 더 많은 작업을 병렬로 진행할 수 있음.
- 다음으로, comprehensibility.
- 각 모듈을 격리해서 이해하고 볼 수 있으므로,
- 전체 시스템을 이해하는 것이 더 쉬움.
- 마지막으로 flexibility.
- 다른 모듈에 영향 없이 독립적 변경이 가능하며,
- 모듈을 서로 다르게 조합해서 새로운 기능을 만들 수 있음.
- 모듈을 나눈다고 위 이점들이 이뤄지는 것은 아님.
- 경계를 잘 식별해야 가능한 것이며, 정보은닉은 이를 돕는 주요 요소.
- 한편, 서로 간의 가정을 줄이는 것의 중요성도 언급.
- 그래야 영향을 최소화하고 안전한 변경이 가능.

### Cohesion

> the code that changes together, stays together.

- 위 문장이 저자가 가장 명료하다고 느끼는 응집력 정의라고 함.
- MSA에서도 사업의 변화를 쉽게 만드는 것이 목표이며,
- 따라서 같은 기능을 한 곳에 두어 변경의 영향을 가능한 최소화해야 함.
- 여러 서비스를 같이 바꿔야 한다면 비용과 위험이 발생하고 느려짐.

### Coupling

- 서비스 간 낮은 결합도를 가진다면, 한 곳의 변경이 다른 곳에 전파되지 않음.
- 결합도를 높이는 흔한 실수 중 하나는 서비스를 서로 강하게 묶는 통합을 선택하는 것.
- 서비스 간 가능한 적게 알아야 낮은 결합도가 가능.
- 서로 통신하는 횟수를 제한해야 할 수도 있음.

### The Interplay of Coupling and Cohesion

- 결합도와 응집도는 매우 밀접한 관계.
- 관련된 기능이 산재한다면, 변경이 여러 경계에 걸치게 되고, 강하게 엮이는 것.
- 응집력은 경계 안(inside)의 관계에 대한 이야기이고,
- 결합도는 경계를 가로지르는(across) 관계에 대한 이야기.
- 아래의 콘스탄틴 법칙도 언급함.
- stable = 각 요소들이 서로 독립적이어서 변경의 영향이 적음.

> A structure is stable if cohesion is strong and coupling is low.

- 절대적으로 옳은 방법은 없음.
- 결합도와 응집도 역시 코드 구조화 시 고려해야 하는 트레이드 오프 중 하나.
- 그리고 시간이 지남에 따라 안정성이 낮아질 수 있으며,
- 따라서 꾸준히 과거의 결정을 재고해야 함.

## Types of Coupling

- 결합도가 나쁘긴 하지만 어떤 것은 피할 수 없기도 함.
- 결합도를 낮추려 노력할 뿐.
- 이 결합도에는 여러 유형이 있음.
- 책에서는 4개를 소개하고 있으며, 왼쪽에서 오른쪽으로 갈수록 결합도가 높음.
- domain < pass-throw < common < content

### Domain Coupling

- 도메인 결합도란, 한 MS가 다른 MS와 상호작용하는 것을 가리킴.
- 다른 MS가 제공하는 기능을 사용하기 위해 필요한 것.
- 예컨대 주문 MS는 재고 MS에 상품 예약을 하고 결제 MS에 결제를 요청함.
- MSA에서 이런 상호작용은 대개는 불가피한 의존 유형.
- 도메인 의존성은 결합도 중에서도 느슨한 수준.
- 물론 가능한 적게 유지하는 것이 좋음.
- 한 MS가 여러 다운스트림 MS에 요청하는 것은 너무 많은 로직이 중앙화 된 것일 수 있음.
- 서비스 간 주고받는 데이터가 복잡해질수록 문제가 됨.
- 정보 은닉을 기억해야 함.
- 꼭 필요한 것만을 공유하고, 필요한 만큼만 데이터를 보내라.

### Pass-Through Coupling

pass-through 결합도 설명과 이것의 문제점 이야기.

- 한 MS가 다른 MS로 데이터를 전달하는데,
- 중간에 또 다른 MS를 거쳐야 하는 것을 가리킴.
- 문제적 결합도의 대표적 사례.
- 만약, `Order Processor`가 주문 요청을 `Warehouse`에게 보내고,
- `Warehouse`는 주문 요청에서 `Shipping Manifest`를 추출해서,
- `Shipping` 서비스로 보내야 한다고 가정.
- 만약, `Shipping Manfiest`의 변경이 필요하면,
- `Warehouse`뿐만 아니라 `Order Processor`에까지 영향을 줌.

이를 해결할 수 있는 첫 번째 방법.

- 중간 단계를 없애는 방법을 생각해 볼 수 있음.
- `Warehouse`에 주문 상품 목록만을 담아 요청하고 응답이 오면,
- `Shipping Manifest`만을 `Shipping`에 전달하는 것.
- 다만, 이것의 트레이드 오프로 `Order Processor`의 도메인 의존성과 로직의 복잡성이 높아짐.

두 번째 대안 이야기.

- `Order Processor`로부터 `Shipping Manifest`를 숨기는 것도 방법.
- `Order Processor`는 추상화 된 주문 요청을 `Warehouse`에 보내고,
- `Warehouse`가 이 요청으로부터 `Shipping Manifest`를 만들어 `Shipping`에 요청.
- `Shipping` 서비스의 계약이 바뀌더라도 이 변경은 `Warehouse`로만 영향이 한정될 가능성 높음.
- 물론 완전히 독립적이 되는 것은 아님.
- 국제 배송이 될 경우 `Shipping`은 부가 정보를 필요로 할 수 있으며,
- 이 정보를 마땅히 얻을 곳이 없다면,  `Order Processor`의 변경은 불가피.
- 하지만 `Shipping Manifest`를 숨김으로써 단계적 배포 등을 통해 어느 정도 독립성을 챙길 수 있음.

마지막 방법.

- `Order Processor`가 여전히 `Shipping Manifest`를 포함해서 요청을 보내긴 하되,
- `Warehouse`는 이것의 구조에는 관심을 두지 않고,
- 단지 데이터 블럽으로 대우하며 그대로 `Shipping`에 전달.
- `Shipping Manifest`의 변경은 이제 `Order Processor`와 `Shipping`으로 한정.

### Common Coupling

일단 공통 결합도가 무엇인지 언급.

- 2개 이상의 MS가 공통의 데이터 셋을 사용하는 경우를 가리킴.
- 예를 들어, 여러 MS에 공통 데이터를 공유하는 방식으로 공유 DB(또는 메모리나 파일시스템)를 사용.
- 이 때의 문제는 데이터 구조 변경이 여러 MS에 영향을 준다는 것.
- 물론, 자주 바뀌지 않는 읽기전용의 정적 데이터를 공유하는 건 괜찮을 수도.
- 그러나 자주 바뀌는 데이터는 문제가 됨.
- 책에서는 `Order Processor`와 `Warehouse`가 주문 테이블을 같이 사용하며,
- 같은 주문 건에 대해 상태를 바꿀 수 있는 경우를 예로 들고 있음.
- 이 둘은 서로 다른 생애주기로 주문을 관리함.

이를 극복하는 방법들.

- 각각이 주문의 상태를 바꿀 때 서로의 관점을 깨뜨리는 건 아닌지를 어떻게 확인할 수 있을까?
- 한 가지 방법은 유한 상태 머신을 만드는 것.
- 자세한 내용은 CH6에서 다룬다고 함.
- 또 다른 해결책은 한 MS를 source of truth로 만드는 것.
- `Order`라는 서비스를 만들고 이를 담당하게 하고,
- `Order Processor`와 `Warehouse`가 상태 변경 요청을 여기로 보내게 함.
- `Order`를 단순한 DB CRUD 래퍼로 만들 수도 있으나,
- 이는 단지 필드를 private으로 만들되 모든 getter/setter를 그대로 제공하는 것과 마찬가지.
- 앞에서의 문제가 조금 다른 형태로 재현될 뿐임.

공통 결합도로 인한 리소스 경합 문제도 있음.

- 같은 파일시스템이나 DB를 공유해서 사용하다 보면,
- 특정 MS가 무거원 연산을 실행시킬 수도 있고,
- 이로 인해 여기에 의존하는 다른 MS에도 영향을 줄 수 있음.
- 단지 변경 이슈 외에도 경합 문제도 고려해야 함.

### Content Coupling

- 업스트림 서비스가 다운스트림 서비스의 내부에 접근해서 그 내부의 상태를 바꾸는 것.
- 예를 들어, 다른 MS의 DB 값을 직접 변경하는 것.
- 공통 결합 문제에서는 다른 공유 데이터를 사용해도 이것이 통제 밖에 있다는 것을 인지하지만,
- 컨텐츠 결합에서는 이 책임이 덜 명확하며 따라서 개발자 입장에서 시스템을 변경하는 것이 더 어려움.
- 로직이 중복될 뿐만 아니라 로직이 달라지기 시작하면 원인을 찾기 어려운 문제가 됨.
- 위에서 `Order`를 만들었던 것처럼 서비스를 하나 만들고 요청을 위임하는 것이 좋음.

## Just Enough Domain-Driven Design

- 에릭 에반스의 DDD 책에 나온 3가지 주요 아이디어 짧게 소개.
- Ubiquitous language
- Aggregate
- Bounded context

### Ubiquitous Language

- 실제 사용자들이 사용하는 용어와 같은 것을 개발에 사용해야 한다는 것.
- 이를 통해 커뮤니케이션을 더 쉽게 만들고 실제 세계를 좀 더 잘 모델링.
- 이와 반대되는 은행 시스템 개발 사례를 얘기하고 있음.
- 번역에 많은 시간이 들어갔다고.

### Aggregate

- 애그리거트의 정의는 다양해서 혼란의 여지가 있지만,
- 저자는 실제 도메인 개념을 표현하는 것을 생각하는 게 도움이 됐다고.
- 주문, 송장, 재고 아이템 등.
- 책에서 계속 언급되는 MusicCorp 예시에서는,
- 주문 애그리거트가 여러 라인 아이템(주문 상품)들을 가짐.
- 이 라인 아이템들은 주문 애그리거트의 부분으로써만 의미가 있음.
- 애그리거트는 자주적 단위로 간주.
- 즉, 애그리거트의 상태와 이 상태의 전이를 위한 코드는 함께 모여 있음.
- 따라서 하나의 애그리거트는 하나의 MS에 의해서만 다뤄져야 함.
- 애그리거트는 다른 애그리거트와 관계를 맺을 수 있음.
- 하나의 MS안에 있는 애그리거트들이라면 외부키로 연결할 수도.
- 그러나 서로 다른 MS에 있다면 단지 ID만을 저장하면 됨.
- 외부키로 연결할 때에 비해 덜 명시적.
- 그래서 책에서는 바닐라 ID 대신 URI를 저장하라고 함.
- 예컨대 `/customer/141` 같은 식.
- 보통 URI를 통해 리소스 식별이 가능하므로 모호함을 어느 정도 극복.
- 물론 이 또한 여러 문제가 떠오름. 선택의 문제.

### Bounded Context

- 애그리거트에 비해 좀 더 큰 조직적 경계.
- 이 분류 별로 명시적 책임들이 수행되고,
- 구현세부사항은 숨겨짐(알 필요도 없고, 알면 안 됨).
- 1개 이상의 애그리거트를 가지며,
- 이 중 어떤 것은 바깥에 노출되고 어떤 것은 내부에 숨겨짐.
- 필요하면 바운디드 컨텍스트끼리 서로 관계를 맺음.

#### Hidden models

- MusicCorp에서 재정 부서와 창고는 서로 다른 바운디드 컨텍스트.
- 이들은 바깥 세상과 소통하는 명시적인 인터페이스가 있음.
- 그리고 본인들만 알아야 하는 세부사항을 가짐.
- 여기서 재정 부서는 장부에서 재고 정보를 최신 상태로 유지해야 함.
- 이는 창고 서비스로부터 재고 아이템이라는 공유 모델로 얻을 수 있음.
- 하지만 창고의 선반이나 접수인 등의 세부사항은 알지 못해야 함.
- 물론 재고 아이템을 공유 받을 때도 재정 부서의 관점에서 필요한 것만.
- 재고 아이템의 외부 표현과 내부 표현이 서로 다른 것.
- 이 공유 시점에 필요하다면(혼란을 피하거나) 이름을 다르게 지을 수 있음.
- 재고 아이템의 갯수만 제공한다면, `StockItem`이라는 표현 대신 `StockCount` 등을 고려.

#### Shared models

- 재정 부서와 창고는 모두 고객의 정보를 필요로 함.
- 재정 부서는 고객의 금융 지불 정보를 알아야 하고,
- 창고는 배송 추적을 위한 고객 정보를 알아야 함.
- 이런 경우 고객이라는 공유 모델은 서로 다른 바운디드 컨텍스트에서 서로 다른 의미를 가짐.
- 예컨대, 재정 부서에서는 "고객"이라는 이름을 사용하는 반면,
- 창고에서는 수취인이라는 용어를 사용할 수 있음.

### Mapping Aggregate and Bounded Contexts to Microservices

- 애그리거트와 바운디드 컨텍스트는 잘 정의된 인터페이스와 함께 응집력을 가져다 줌.
- 애그리거트는 단일 도메인 개념에 집중한 자율적 상태 머신이고,
- 바운디드 컨텍스트는 연관성 있는 애그리거트의 집합을 나타내며 좀 더 넓은 세상으로의 명시적 인터페이스를 제공.
- 이 둘 모두 서비스의 경계로써 잘 동작함.
- 그러나 시작할 때는 서비스의 수를 줄이는 것이 좋고,
- 따라서 바운디드 컨텍스트르를 아우르는 서비스를 권장.
- 그리고 필요에 따라 더 작은 단위로 분리.
- 주의할 것은 애그리거트의 필요성을 생각해 볼 때,
- 한 애그리거트가 여러 서비스에 나뉘지 않아야 함.

#### Turtles all the way down

- BD(바운디드 컨텍스트)로 서비스를 나누었는데,
- 이 BD는 또 다른 BD들을 내포하고 있을 수 있음.
- 이를 좀 더 잘게 나눈다고 할 때, 이런 구분은 구현 세부사항일 수 있으며, 따라서 이를 외부 세상엔 숨길 수 있음.
- 예컨대, `Warehouse`를 `Inventory`와 `Shipping`으로 나눈다고 가정.
- 하지만 외부세상은 여전히 `Warehouse` 서비스에 통신.
- 내부적으로만 나뉘는 것.
- 외부 세상으로의 변경 영향을 줄일 수 있고,
- 테스트 스텁을 만들어야 하는 비용을 줄일 수도 있음.

## Event Storming

- 도메인 모델링을 위한 협력적 브레인스토밍 활동.
- 기술적, 그리고 비기술적 이해관계자들이 함께 참여.
- 도메인 세상에 대한 공유된, 비슷한 시각을 가질 수 있음.
- 이벤트 드리븐 시스템 뿐만아니라 요청/응답 지향 시스템에도 사용 가능.

### Logistics

- 일단 모두가 방 안에 함께해야 함.
- 이것이 가장 어려운 단계.
- 하지만 모든 이해관계자들이 동시에 모여야 하는 것이 핵심.
- 사용자, 직무전문가, 프로덕트 오너, ...
- 그리고 의자는 모두 치워두는 것도 권장.
- 큰 공간도 필요. 벽에 커다란 종이를 붙이고, 모두가 정보를 파악할 수 있게.
- 주 도구는 서로 다른 색을 가진 포스트잇.

### The process

- 도메인 이벤트를 식별하는 것으로 활동은 시작.
- 이는 시스템에서 일어나는 것들을 가리킴.
- "Order Placed", "Payment Received", ...
- 이 이벤트들은 주황색 포스트잇에 기록.
- 그리고 이 이벤트를 일으키는 명령들을 식별.
- 여기서 명령이란 사용자의 결정들을 일컬음.
- 명령들은 파란색 포스트잇에 작성.
- 여기서는 기술 세부사항보다는 주요 이해관계자들로부터 여러 도메인 개념들을 이끌어내는 것에 초점.
- 이제 애그리거트 식별 단계.
- "Order Placed"의 "Order"가 애그리거트 후보.
- 이제 이들을 묶어 BD 식별.
- 일반적으로는 조직 구조를 따라감.

## Alternatives to Business Domain Boundaries

- DDD 외에도 경계를 찾는 여러 방법들이 있음.
- 저자는 이들을 DDD와 함께 자주 사용한다고 함.

### Volatility

- 자주 변경되는 부분을 하나의 서비스로 추출하는 것.
- 이것의 이점이 분명하긴 하나 절대적인 것은 아님.
- 예컨대, 애플리케이션 스케일링이 이슈일 때는 이 분리는 X.
- 대신 bimodal IT 같은 곳에서 두드러짐.
- Mode 1은 안정적이고 잘 바뀌지 않는 곳이고,
- Mode 2는 빠르게 변화하고 비즈니스와 긴밀하게 연결된 곳.
- 하지만 저자는 bimodal이 결국 느리거나 더 느린 2개의 속도로 끝난다며 비판.
- 대신 빠른 시장 대응이 필요하고 이에 대응해야 할 경우 추출은 의미가 있음.

### Data

- 데이터 역시 분리의 기준이 될 수 있음.
- 예를 들어, PII<sup>Personally Identifiable Information</sup>의 사용은 특정 서비스로 제한해서 리스크를 줄이고 싶을 수도.
- 좀 더 구체적인 신용카드 회사 사례 언급.

### Technology

- 서로 다른 기술의 사용 역시 분리 기준 후보.
- 1개의 서비스에서 서로 다른 DB를 사용할 수도 있으나 이는 도전적이기에 분리할 수도.
- 또한 성능 상의 이유로 Rust 같은 언어를 사용한다면 이 역시 분리 후보.
- 물론, 이 기준이 일반적인 수단으로 받아들여지는 것은 위험.
- 전형적인 3계층 아키텍처(Web - Backend - Database)가 될 수도.

### Organizational

- 조직의 구조는 좋든 나쁘든 시스템 아키텍처를 결정짓는 경향이 있음.
- 그래서 서비스 경계 식별의 주요 의사 결정 요소로 고려해야 함.
- MS의 공유된 소유권은 15장에서 다룰 여러 문제들을 야기.
- 서비스 경계를 나누기 위해 조직 구조도 함께 변경해야 할 수도.
- 물론, 조직이 너무 자주 바뀌는 경우도 생각해봐야 함.
- 최악의 경우 조직 구조도 바뀌긴 하나,
- 일반적으로는 MS의 소유권만 바뀜.

# Chapter 3. Splitting the Monolith

## Have a Goal

- MSA 자체가 목적은 아님.
- 그리고 목적지로 갈 수 있는 다른 쉬운 방법은 없는지 먼저 고민해야 함.
- 목적이 명확치 않으면 어디서부터 시작해야 할지도 막막.

> Microservices aren't easy. Try the simple stuff first.

## Incremental Migration

- 모놀리틱을 나누기로 했다면 조금씩 떼어내길 강력히 권장.
- 점진적 접근을 통해, 앞으로 나아가며 배울 수 있고, 잘못되는 것의 영향도 줄일 수 있음.
