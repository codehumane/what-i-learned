# Tidy First?

책 다 읽고 보니, Tidy First가 아니라, Tidy First?가 제목임을 알게 됨. 간단히 정리.

# Tidyings

## 1. Guard Clauses

- 보호 절에 관한 일반적 이야기.
- 그런데 잠깐 괄호 열고 아래 규칙을 잠시 언급.
- 하나의 루틴에 하나의 반환이라는 규칙.
- 이는 포트란에서 왔다고 함.
- 포트란에서는 하나의 루틴이 여러 진입점과 종료점을 가질 수 있었고, 이로 인해 디버깅이 매우 어려웠다고 함.
- 반면, 보호 절이 담긴 코드는 전제조건이 명시적이므로 분석이 쉬움.

## 4. New Interface, Old Implementation

- pass-through 인터페이스라고 표현.
- 기존 인터페이스가 어렵거나 복잡하거나 혼란스러운 문제가 있다면,
- 단지 기존의 인터페이스를 호출하는 새로운 인터페이스를 만들고,
- 호출부는 새로운 인터페이스를 호출.
- 기존 인터페이스를 새로운 인터페이스 안으로 인라인 시킬 수도 있음.
- 아래의 경우도 pass-through 방식을 사용하는 느낌을 받음.
- 거꾸로 코딩하기 - 루틴의 마지막 줄부터 시작하고, 필요한 중간 결과들이 마치 모두 있는 것 처럼 작성.
- 테스트 먼저 작성 - 통과해야 할 테스트를 먼저 작성.
- 헬퍼 설계 - 뭔가를 해주는 무언가가 있다면, 나머지는 쉬움.

## 5. Reading Order

- 번역이 또 이상.
- 독자가 읽기 원하는 순서로 코드를 재배치하라.
- Reorder the code in the file in the order in which a reader would prefer to encounter it.

## 10. Explicit Parameters

- 명시적이지 않은 파라미터를 넘기면 문제라고 하는데,
- 정확히 어떤 것을 명시적이지 않다고 하는지가 명시적이지 않음.
- 한 사례로 파라미터로 맵을 넘기는 걸 언급.
- 맵을 넘기는 건 분명 위험.
- 이렇게 런타임에서야 위험이 드러나는 파라미터를 명시적이지 않다고 하는 걸까?
- 일단은, 아래와 같은 코드는, 어떤 데이터가 필수 값인지 이해하기 어렵게 만들고, 파라미터 값을 몰래 수정할 수도 있는 문제가 있음.

```
params = { a: 1, b: 2 }
foo(params)

function foo(params)
    ...params.a... ...params.b...
```

- 그리고 2개의 루틴으로 나누라고 함.
- 하나는 파라미터를 모으고, 하나는 명시적으로 파라미터를 전달하는 부분.

```
function foo(params)
    foo_body(params.a, params.b)

function foo_body(a,b)
    ...a... ...b...
```

- 아래 문장도 번역이 이상.
- Another case for explicit parameters is when you find the use of environment variables deep in the bowels of the code.
- 명시적 파라미터가 필요한 또 하나의 경우는, 코드의 깊숙한 곳에서 환경 변수를 사용하는 것.

## 12. Extract Helper

- 추출 조건 중 형식지가 아니었던 부분이 나와 기록.
- 목적이 분명하고, **나머지 코드와는 상호작용이 적은** 코드.
- 도우미 추출의 또 하나의 특수 사례는 시간적 결합을 표현하는 경우.

```
// 만약 시간적 결합이 있다면
foo.a()
foo.b()
// 아래와 같이 바꾸기
ab()
    a()
    b()
```

## 13. One Pile

- 코드 정리는 보통 코드를 더 작은 단위로 만듦.
- 이는 응집력을 높이고 결합도를 낮추기도 하고,
- 한 번에 이해해야 하는 양을 적절히 제한해 주기도.
- 그러나, 때로는 잘못되기도 함.
- 다시 코드를 모으고 새롭게 정리해야 함.
- 문제의 증상으로는 아래의 것들이 있음.
  - 길고, 반복되는 인자 목록.
  - 반복된 코드, 특히 반복된 조건문.
  - 빈약한 헬퍼 루틴 이름.
  - 공유된 mutable 데이터 구조체.

## 14. Explaining Comments

- 주석을 제거하라가 아님.
- 필요한 곳에 작성하란 이야기.
- 미리 알았더라면 좋았던, 코드로는 명확치 않은 것들을 기록.
- 예를 들면 아래의 문장.

> 다음은 네트워크 호출 횟수를 최대한 줄여야 하므로 다소 복잡해졌다.

- 문제가 있는 코드는 제거해야 겠지만,
- 그렇지 못하는 경우엔 그냥 넘어가는 것보다는 주석을 남겨두는 것도 방법.

> 새로운 경우를 한 개 더 추가하려면 ../foo를 반드시 변경해야 합니다.

## 15. Delete Redundant Comments

- 바로 다음 장이 불필요 주석 지우기.
- 코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제.
- 혹은 코드 정리의 신호로 활용 후 마지막에 제거.

# Managing

3가지 코드 정리 정의 언급.

- 나, 나와 코드의 관계, 나 스스로와의 관계를 다루는 소프트웨어 설계.
- 괴짜의 자기 관리.
- 리팩토링 게이트웨이.

그리고 코드 정리 대상 식별과 수행으로는 충분치 않음을 강조.

- 책의 제목은 Tidy First?
- 물음표에 방점이 있음.
- 이어서 아래 주제들 다룸.
- 언제 코드 정리 해야 할까?
- 언제 코드 정리를 멈춰야 할까?
- 코드 정리, 코드 구조 변경, 시스템의 행위 변경을 어떻게 조합해야 할까?

## 16. Separate Tidying

행위 변경(B)과 구조 변경(S) 커밋들이 있을 때, 이를 하나의 PR에 담을 수도 있고, 행위 변경과 구조 변경을 각각의 PR로 분리할 수도 있음.

1. 하나의 PR: `BSSBSSSBBS`
2. 여러 PR: `B` + `SS` + `B` + `SSS` + `BB` + `S`

두 방식은 트레이드 오프를 가짐.

1. 먼저 리뷰 품질 관점.
2. 하나의 PR은 전체 그림을 한 번에 보여주지만,
3. 리뷰어에게 너무 많은 정보를 제공하므로 유용한 피드백 받기가 어려울 수 있음.
4. 한편, PR이 작으면 피드백들이 잡초가 될 수 있다고 표현.
5. 다음은 리뷰 지연 관점.
6. 코드 리뷰가 금방 이뤄지면 더 많은 작은 PR들을 많이 만들 수 있고, 이는 다시 빠른 리뷰로 이어짐.
8. 이 순환은 반대에도 동일하게 적용 가능. 느린 리뷰는 더 큰 PR을 만들고, 리뷰를 다시 또 느리게 만드는 악순환.

코드 정리를 작고 안전한 단계로 할 수 있게 되면, 코드 정리 PR들은 리뷰하지 않는 실험도 해보길 권장.

관련해서 드는 이런 저런 생각들.

1. 코드 정리의 정의가 중요.
2. 정말 간단한 정리들이라면 리뷰는 편익 낮을 수 있음.
3. 그리고 그런 몇 개의 정리들이라면, 하나의 PR에 넣어도 비용은 적다 생각.
4. 여전히 PR은 Jira 티켓과 같은 일의 규모와 동일한 게 좋다 생각(일관성).
5. 다만, PR이 리뷰하기 어려운 수준이라면, 단순히 B와 S 분리의 문제가 아니라, 일의 범위 정의가 잘못된 건 아닐지 고민 필요해 보임.
6. 한편, 리뷰 생략은, B와 S를 하나의 PR로 만들 때에도 동일하게 적용할 수 있는 전략.
7. 마지막으로, 코드 정리가 단순한 코드 정리가 아니라, 설계 변경 등 다소 규모가 있다면, 이는 PR은 물론 배포 분리도 고려해야 한다고 생각.

## 17. Chaining

- 코드 정리는 감자칩과 같음. 한 번 먹으면 계속 먹고 싶음.
- 이런 충동을 잘 관리하는 것이 코드 정리의 핵심 기술.
- 더 정리해도 될지에 대한 얘기는 3부에서 이야기.
- 여기서는 아주 작은 단계로 나누어 코드를 정리하라는 것.
- 무리한 정리는 실패할 수 있음.
- 작은 성공 단계를 나누어 밟는 것이 오히려 비용 적음.

## 18. Batch Sizes

- 통합과 배포를 하기 전에 얼마나 정리해야 할까?
- 2가지 고려사항 있음.
  - 코드 정리를 다음 기능 변경을 돕는 구조 변경이라고 보면, 먼 미래가 아니라 즉각적인 필요를 다뤄야 함.
  - 코드 정리의 양이 어느 정도여야 통합과 배포에 어려움이 없을까?
- 코드 정리가 많으면 통합과 배포 비용 증가.
  - 충돌: 통합/배포 지연이 늘고, 코드 충돌 가능성도 올라감.
  - 상호작용: 코드 정리를 한 번에 많이 하다 보면 동작 변경이 포함될 가능성이 커짐. 상호작용이 생기면 머지 비용은 급격히 올라감(상호작용의 의미가 이해 안 됨)
  - speculation: 코드 정리를 할수록 비용이 늘어나고 이 때문에 더 많은 코드 정리를 하려는 경향이 있음.
- 한편, 하나의 변경을 검토하고 배포하는데 드는 비용은 작지 않음.
- 따라서, 이 비용을 트레이드 오프에 고려.
- 단순하게 접근하면 골디락스 딜레마가 됨.
- 더 적게, 적절한 개수로, 더 안정적인 코드 정리를 할 수 있다면, 코드 검토 생략으로도 이어질 수 있고, 검토 비용은 줄어듦.
- 결국, 작은 코드 정리가 더 유리.

## 19. Rhythm

- 일련의 코드 정리 작업에 얼만큼의 시간을 써야 할까?
- 소프트웨어 설계는 길을 닦는 일.
- 코드 정리는 몇 분에서 1시간 정도면 충분.
- 80%의 변경이 20%의 파일에서 일어남을 감안하면 더더욱 그러함.

> 한 대학에서 건물을 여러개 지었는데, 기획자들은 건물을 거의 다 지었을 때에도 건물 사이에 통행로를 어디에 만들지 정하지 못했습니다. 그러나 그들은 시간을 들이면서 신중하게 추측하는 대신에 건물과 건물 사이의 모든 공간에 잔디를 심었습니다. 몇 달 후, 학생들이 밟고 다녀서 잔디밭이 닳아 없어진 부분이 생겨났습니다. 기획자들은 닳아 없어진 부분을 매끄럽게 포장했습니다.

## 20. Getting Untangled

- 코드 작업을 하며 지식이 쌓이기도 하기에, 코드 정리와 동작 변경이 얽힐 때가 있음.
- 이럴 때 진행 중인 작업을 버리고 코드 정리를 선행하도록 다시 작업하는 것도 선택지.
- 우리의 의도를 컴퓨터뿐만 아니라 사람에게도 설명해야 하기 때문.
- 또한 다시 작업하는 과정에서 새로운 것을 발견하기도 하고 더 좋은 결과를 만들기도.

## 21. First, After, Later, Never

#### 코드 정리는 언제 해야 할까?

- 동작 변경 전에 코드 정리를 해야 할까요?
- 혹은 동작 변경 이후에 해야 할까요?
- 혹은 나중으로 미룰까요?
- 아니면 아예 안 할 수도 있나요?

#### Never

- 앞으로 동작이 변하지 않는 코드라면 정리할 필요 없음.
- 매우 드문 일이지만 일어나기도 함.
- "고장나지 않으면 고치지도 마"가 합리적 선택.

#### Later

- 나중에 정리하는 것을 유니콘처럼 여기기도.
- 너무 많은 것을 한 번에 정리하려 할 때 근거로 사용.
- 그러나 정말로 나중에 정리할 수 있음.
- 때로는 일시적으로 여유가 생김.
    - 시간은 항상 부족함.
    - "만약 충분한 시간이 있다면 뭘 할까?"
    - 이 질문에 대한 답이 지금 행동과 다르다면 정말로 시간이 없는 것.
- 이 때, 정리 목록(저자는 이를 Fun List라 부른다고)을 훑고, 적절한 것을 골라 진행.
- 코드 정리는 미래의 시스템 행위 변경을 쉽게 만듦.
- 변경이 보장되는 시스템 영역이라면 코드 정리가 가치를 가져옴.
- 한편, 지금의 동작 변경과 관련 없는 코드 정리를 나중에 하면 다른 식으로 가치를 창출함.
- 하나는 세금 보유세를 줄임. 결국엔 변경해야 하기 때문이라는 논리.
- 다른 하나는 배움의 도구. 코드 정리 과정에서 배우기 마련.
- 마지막으로, 기분을 좋게 만듦. 만족감을 느낄 때 얼마나 더 나아질 수 있는지 과소평가 하지 말 것.

#### After

- 동작 변경 후에, 변경을 더 쉽게 할 수 있는 코드 정리 방법을 발견할 수도.
- 방금 동작 변경 일어난 코드는 나중에도 그럴 가능성 높음.
- 그러나 정말 그렇다면 나중에 변경 일어날 때 코드 정리를 먼저 하면 되지 않을까?
- 하지만 나중에 코드 정리를 하는 건 지금 하는 것 보다 더 어려움.
- 지식과 맥락을 잊어버릴 수도 있고, 나중엔 시간이 없을 수도.

#### First

- 동작 변경을 위한 코드 정리가 얼마나 도움이 되는가?
- 코드 정리 이점이 얼마나 즉각적인가? 예를 들어, 코드 정리로, 변경을 위한 코드 이해가 더 잘 될 수도.
- 코드 정리의 편익이 얼마나 큰가? 동작 변경이 1번만 일어나고 말 거라면 코드 정리는 제한.
- 코드 정리에 대한 확신은 얼마나 되나?
- 위 질문에 답하며 결정해 가면 됨.
- 일반적으로는 코드 정리 먼저하기를 선호.
- 하지만 코드 정리 그 자체가 목적이 되는 것을 경계.
