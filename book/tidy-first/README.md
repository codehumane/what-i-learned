# Tidy First?

책 다 읽고 보니, Tidy First가 아니라, Tidy First?가 제목임을 알게 됨. 간단히 정리.

# Tidyings

## 1. Guard Clauses

- 보호 절에 관한 일반적 이야기.
- 그런데 잠깐 괄호 열고 아래 규칙을 잠시 언급.
- 하나의 루틴에 하나의 반환이라는 규칙.
- 이는 포트란에서 왔다고 함.
- 포트란에서는 하나의 루틴이 여러 진입점과 종료점을 가질 수 있었고, 이로 인해 디버깅이 매우 어려웠다고 함.
- 반면, 보호 절이 담긴 코드는 전제조건이 명시적이므로 분석이 쉬움.

## 4. New Interface, Old Implementation

- pass-through 인터페이스라고 표현.
- 기존 인터페이스가 어렵거나 복잡하거나 혼란스러운 문제가 있다면,
- 단지 기존의 인터페이스를 호출하는 새로운 인터페이스를 만들고,
- 호출부는 새로운 인터페이스를 호출.
- 기존 인터페이스를 새로운 인터페이스 안으로 인라인 시킬 수도 있음.
- 아래의 경우도 pass-through 방식을 사용하는 느낌을 받음.
- 거꾸로 코딩하기 - 루틴의 마지막 줄부터 시작하고, 필요한 중간 결과들이 마치 모두 있는 것 처럼 작성.
- 테스트 먼저 작성 - 통과해야 할 테스트를 먼저 작성.
- 헬퍼 설계 - 뭔가를 해주는 무언가가 있다면, 나머지는 쉬움.

## 5. Reading Order

- 번역이 또 이상.
- 독자가 읽기 원하는 순서로 코드를 재배치하라.
- Reorder the code in the file in the order in which a reader would prefer to encounter it.

## 10. Explicit Parameters

- 명시적이지 않은 파라미터를 넘기면 문제라고 하는데,
- 정확히 어떤 것을 명시적이지 않다고 하는지가 명시적이지 않음.
- 한 사례로 파라미터로 맵을 넘기는 걸 언급.
- 맵을 넘기는 건 분명 위험.
- 이렇게 런타임에서야 위험이 드러나는 파라미터를 명시적이지 않다고 하는 걸까?
- 일단은, 아래와 같은 코드는, 어떤 데이터가 필수 값인지 이해하기 어렵게 만들고, 파라미터 값을 몰래 수정할 수도 있는 문제가 있음.

```
params = { a: 1, b: 2 }
foo(params)

function foo(params)
    ...params.a... ...params.b...
```

- 그리고 2개의 루틴으로 나누라고 함.
- 하나는 파라미터를 모으고, 하나는 명시적으로 파라미터를 전달하는 부분.

```
function foo(params)
    foo_body(params.a, params.b)

function foo_body(a,b)
    ...a... ...b...
```

- 아래 문장도 번역이 이상.
- Another case for explicit parameters is when you find the use of environment variables deep in the bowels of the code.
- 명시적 파라미터가 필요한 또 하나의 경우는, 코드의 깊숙한 곳에서 환경 변수를 사용하는 것.

## 12. Extract Helper

- 추출 조건 중 형식지가 아니었던 부분이 나와 기록.
- 목적이 분명하고, **나머지 코드와는 상호작용이 적은** 코드.
- 도우미 추출의 또 하나의 특수 사례는 시간적 결합을 표현하는 경우.

```
// 만약 시간적 결합이 있다면
foo.a()
foo.b()
// 아래와 같이 바꾸기
ab()
    a()
    b()
```

## 13. One Pile

- 코드 정리는 보통 코드를 더 작은 단위로 만듦.
- 이는 응집력을 높이고 결합도를 낮추기도 하고,
- 한 번에 이해해야 하는 양을 적절히 제한해 주기도.
- 그러나, 때로는 잘못되기도 함.
- 다시 코드를 모으고 새롭게 정리해야 함.
- 문제의 증상으로는 아래의 것들이 있음.
  - 길고, 반복되는 인자 목록.
  - 반복된 코드, 특히 반복된 조건문.
  - 빈약한 헬퍼 루틴 이름.
  - 공유된 mutable 데이터 구조체.

## 14. Explaining Comments

- 주석을 제거하라가 아님.
- 필요한 곳에 작성하란 이야기.
- 미리 알았더라면 좋았던, 코드로는 명확치 않은 것들을 기록.
- 예를 들면 아래의 문장.

> 다음은 네트워크 호출 횟수를 최대한 줄여야 하므로 다소 복잡해졌다.

- 문제가 있는 코드는 제거해야 겠지만,
- 그렇지 못하는 경우엔 그냥 넘어가는 것보다는 주석을 남겨두는 것도 방법.

> 새로운 경우를 한 개 더 추가하려면 ../foo를 반드시 변경해야 합니다.

## 15. Delete Redundant Comments

- 바로 다음 장이 불필요 주석 지우기.
- 코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제.
- 혹은 코드 정리의 신호로 활용 후 마지막에 제거.

# Managing

3가지 코드 정리 정의 언급.

- 나, 나와 코드의 관계, 나 스스로와의 관계를 다루는 소프트웨어 설계.
- 괴짜의 자기 관리.
- 리팩토링 게이트웨이.

그리고 코드 정리 대상 식별과 수행으로는 충분치 않음을 강조.

- 책의 제목은 Tidy First?
- 물음표에 방점이 있음.
- 이어서 아래 주제들 다룸.
- 언제 코드 정리 해야 할까?
- 언제 코드 정리를 멈춰야 할까?
- 코드 정리, 코드 구조 변경, 시스템의 행위 변경을 어떻게 조합해야 할까?

## 16. Separate Tidying

행위 변경(B)과 구조 변경(S) 커밋들이 있을 때, 이를 하나의 PR에 담을 수도 있고, 행위 변경과 구조 변경을 각각의 PR로 분리할 수도 있음.

1. 하나의 PR: `BSSBSSSBBS`
2. 여러 PR: `B` + `SS` + `B` + `SSS` + `BB` + `S`

두 방식은 트레이드 오프를 가짐.

1. 먼저 리뷰 품질 관점.
2. 하나의 PR은 전체 그림을 한 번에 보여주지만,
3. 리뷰어에게 너무 많은 정보를 제공하므로 유용한 피드백 받기가 어려울 수 있음.
4. 한편, PR이 작으면 피드백들이 잡초가 될 수 있다고 표현.
5. 다음은 리뷰 지연 관점.
6. 코드 리뷰가 금방 이뤄지면 더 많은 작은 PR들을 많이 만들 수 있고, 이는 다시 빠른 리뷰로 이어짐.
8. 이 순환은 반대에도 동일하게 적용 가능. 느린 리뷰는 더 큰 PR을 만들고, 리뷰를 다시 또 느리게 만드는 악순환.

코드 정리를 작고 안전한 단계로 할 수 있게 되면, 코드 정리 PR들은 리뷰하지 않는 실험도 해보길 권장.

관련해서 드는 이런 저런 생각들.

1. 코드 정리의 정의가 중요.
2. 정말 간단한 정리들이라면 리뷰는 편익 낮을 수 있음.
3. 그리고 그런 몇 개의 정리들이라면, 하나의 PR에 넣어도 비용은 적다 생각.
4. 여전히 PR은 Jira 티켓과 같은 일의 규모와 동일한 게 좋다 생각(일관성).
5. 다만, PR이 리뷰하기 어려운 수준이라면, 단순히 B와 S 분리의 문제가 아니라, 일의 범위 정의가 잘못된 건 아닐지 고민 필요해 보임.
6. 한편, 리뷰 생략은, B와 S를 하나의 PR로 만들 때에도 동일하게 적용할 수 있는 전략.
7. 마지막으로, 코드 정리가 단순한 코드 정리가 아니라, 설계 변경 등 다소 규모가 있다면, 이는 PR은 물론 배포 분리도 고려해야 한다고 생각.

## 17. Chaining

- 코드 정리는 감자칩과 같음. 한 번 먹으면 계속 먹고 싶음.
- 이런 충동을 잘 관리하는 것이 코드 정리의 핵심 기술.
- 더 정리해도 될지에 대한 얘기는 3부에서 이야기.
- 여기서는 아주 작은 단계로 나누어 코드를 정리하라는 것.
- 무리한 정리는 실패할 수 있음.
- 작은 성공 단계를 나누어 밟는 것이 오히려 비용 적음.

## 18. Batch Sizes

- 통합과 배포를 하기 전에 얼마나 정리해야 할까?
- 2가지 고려사항 있음.
  - 코드 정리를 다음 기능 변경을 돕는 구조 변경이라고 보면, 먼 미래가 아니라 즉각적인 필요를 다뤄야 함.
  - 코드 정리의 양이 어느 정도여야 통합과 배포에 어려움이 없을까?
- 코드 정리가 많으면 통합과 배포 비용 증가.
  - 충돌: 통합/배포 지연이 늘고, 코드 충돌 가능성도 올라감.
  - 상호작용: 코드 정리를 한 번에 많이 하다 보면 동작 변경이 포함될 가능성이 커짐. 상호작용이 생기면 머지 비용은 급격히 올라감(상호작용의 의미가 이해 안 됨)
  - speculation: 코드 정리를 할수록 비용이 늘어나고 이 때문에 더 많은 코드 정리를 하려는 경향이 있음.
- 한편, 하나의 변경을 검토하고 배포하는데 드는 비용은 작지 않음.
- 따라서, 이 비용을 트레이드 오프에 고려.
- 단순하게 접근하면 골디락스 딜레마가 됨.
- 더 적게, 적절한 개수로, 더 안정적인 코드 정리를 할 수 있다면, 코드 검토 생략으로도 이어질 수 있고, 검토 비용은 줄어듦.
- 결국, 작은 코드 정리가 더 유리.

## 19. Rhythm

- 일련의 코드 정리 작업에 얼만큼의 시간을 써야 할까?
- 소프트웨어 설계는 길을 닦는 일.
- 코드 정리는 몇 분에서 1시간 정도면 충분.
- 80%의 변경이 20%의 파일에서 일어남을 감안하면 더더욱 그러함.

> 한 대학에서 건물을 여러개 지었는데, 기획자들은 건물을 거의 다 지었을 때에도 건물 사이에 통행로를 어디에 만들지 정하지 못했습니다. 그러나 그들은 시간을 들이면서 신중하게 추측하는 대신에 건물과 건물 사이의 모든 공간에 잔디를 심었습니다. 몇 달 후, 학생들이 밟고 다녀서 잔디밭이 닳아 없어진 부분이 생겨났습니다. 기획자들은 닳아 없어진 부분을 매끄럽게 포장했습니다.

## 20. Getting Untangled

- 코드 작업을 하며 지식이 쌓이기도 하기에, 코드 정리와 동작 변경이 얽힐 때가 있음.
- 이럴 때 진행 중인 작업을 버리고 코드 정리를 선행하도록 다시 작업하는 것도 선택지.
- 우리의 의도를 컴퓨터뿐만 아니라 사람에게도 설명해야 하기 때문.
- 또한 다시 작업하는 과정에서 새로운 것을 발견하기도 하고 더 좋은 결과를 만들기도.

## 21. First, After, Later, Never

#### 코드 정리는 언제 해야 할까?

- 동작 변경 전에 코드 정리를 해야 할까요?
- 혹은 동작 변경 이후에 해야 할까요?
- 혹은 나중으로 미룰까요?
- 아니면 아예 안 할 수도 있나요?

#### Never

- 앞으로 동작이 변하지 않는 코드라면 정리할 필요 없음.
- 매우 드문 일이지만 일어나기도 함.
- "고장나지 않으면 고치지도 마"가 합리적 선택.

#### Later

- 나중에 정리하는 것을 유니콘처럼 여기기도.
- 너무 많은 것을 한 번에 정리하려 할 때 근거로 사용.
- 그러나 정말로 나중에 정리할 수 있음.
- 때로는 일시적으로 여유가 생김.
    - 시간은 항상 부족함.
    - "만약 충분한 시간이 있다면 뭘 할까?"
    - 이 질문에 대한 답이 지금 행동과 다르다면 정말로 시간이 없는 것.
- 이 때, 정리 목록(저자는 이를 Fun List라 부른다고)을 훑고, 적절한 것을 골라 진행.
- 코드 정리는 미래의 시스템 행위 변경을 쉽게 만듦.
- 변경이 보장되는 시스템 영역이라면 코드 정리가 가치를 가져옴.
- 한편, 지금의 동작 변경과 관련 없는 코드 정리를 나중에 하면 다른 식으로 가치를 창출함.
- 하나는 세금 보유세를 줄임. 결국엔 변경해야 하기 때문이라는 논리.
- 다른 하나는 배움의 도구. 코드 정리 과정에서 배우기 마련.
- 마지막으로, 기분을 좋게 만듦. 만족감을 느낄 때 얼마나 더 나아질 수 있는지 과소평가 하지 말 것.

#### After

- 동작 변경 후에, 변경을 더 쉽게 할 수 있는 코드 정리 방법을 발견할 수도.
- 방금 동작 변경 일어난 코드는 나중에도 그럴 가능성 높음.
- 그러나 정말 그렇다면 나중에 변경 일어날 때 코드 정리를 먼저 하면 되지 않을까?
- 하지만 나중에 코드 정리를 하는 건 지금 하는 것 보다 더 어려움.
- 지식과 맥락을 잊어버릴 수도 있고, 나중엔 시간이 없을 수도.

#### First

- 동작 변경을 위한 코드 정리가 얼마나 도움이 되는가?
- 코드 정리 이점이 얼마나 즉각적인가? 예를 들어, 코드 정리로, 변경을 위한 코드 이해가 더 잘 될 수도.
- 코드 정리의 편익이 얼마나 큰가? 동작 변경이 1번만 일어나고 말 거라면 코드 정리는 제한.
- 코드 정리에 대한 확신은 얼마나 되나?
- 위 질문에 답하며 결정해 가면 됨.
- 일반적으로는 코드 정리 먼저하기를 선호.
- 하지만 코드 정리 그 자체가 목적이 되는 것을 경계.

# Theory

- 지금까지 코드 정리의 what, how, when을 다룸.
- 이제 why 이야기 차례.
- 이론은 설득력을 가져다 주진 않음.
- 대신, 상황에 대한 판단력을 키우고 더 나은 적용을 할 수 있게 도움.
- 예컨대, 아래 질문들에 더 잘 대답할 수 있게 함.
  - 언제 소프트웨어 설계 결정을 시작해야 하지?
  - 언제 소프트웨어 설계 결정을 멈추고, 기능 변경을 해야 하는 거지?
  - 다음 결정은 어떻게 내리지?
- 또한 동료들과의 건설적인 논쟁에도 도움.
- 3부에서는 소프트웨어 설계에 있어 돈, 투자, 비용 측면을 다룸.

## 22. Beneficially Relating Elements

- 소프트웨어 설계란?
- 앞에서 많은 사레들 봤을 것.
- 개별 결정들이 모여 큰 목적을 달성하는 것도.
- 인간관계 속에서 벌어지는 활동이라는 것도.
- 이제 소프트웨어 설계는 요소들을 유익하게 관계 맺는 일이라고 말할 수 있음.
- beneficially relating elements.
- 각 단어를 하나씩 살펴 보자.

### Elements

- 물질은 부분들로 구성.
  - Organelle → organ → organism.
  - Atoms → molecules → crystals.
  - 토큰 → 표현 → 문장 → 함수 → 객체/모듈 → 시스템
- 요소는 경계를 가짐.
- 또한, 하위 요소를 갖고 있음.
- 즉, 계층을 이룸.

### Relating

- 요소들에는 계층이 있음.
- 요소들이 서로 관계를 가지는 것.
- 한 함수는 다른 함수를 호출.
- 이 함수들도 요소.
- "호출하고, 호출 당하는" 관계를 가짐.
- 소프트웨어 설계의 관계들.
  - invoke
  - publish
  - listen
  - refer

### Beneficially

- 여기서 마법이 일어남.
- 설계는 여러 작은 요소들을 하나의 큰 수프로 만드는 것.
- 함수 B가 복잡성을 처리해 주기에, 함수 A는 일정 부분 간단해 질 수 있음.
- 서로가 도움이 됨.

### Beneficially Relating Elements

- 설계는 요소, 관계, 관계 속에서 이점을 만들어 내는 것.
- 설계자는 요소들을 가치 있게 연결시키는 사람.
  - 요소를 만들거나 삭제.
  - 요소들 간 관계를 만들거나 삭제.
  - 관계의 가치를 증가시킴.

```
caller()
    return box.width() * box.height()
```

- 호출자는 box와 2가지 관련을 가짐.
- 2개의 함수를 호출하고 있는 것.
- 이제 아래와 같이 바꾸기.

```
caller()
    return box.area()

Box>>area()
    return width() * height()
```

- 호출자와 피호출부의 관계를 조정함.
- 하나의 함수 호출 관계로 바뀜.
- 호출부는 단순해졌고, 대신 피호출부의 함수는 커짐.

## 23. Structure and Behavior

소프트웨어는 2가지 방식으로 가치를 창출.

1. 지금 하는 일.
2. 내일 새로운 것을 만들 가능성.

먼저 행위 이야기.

- 지금 하고 있는 일은 시스템의 행위를 가리킴.
- 세금서 계산, 주문 배송 등.
- 그리고 행위는 2가지 특성으로 이뤄짐.
  - 입출력
  - 불변식
- 행위는 가치를 창출함.
- 1달러의 전기료가 들고 사람들은 10달러를 지불하는 기능이라면 비즈니스가 성립.

다음으로, 미래의 선택권 이야기.

- 지금의 행위보다 더 좋은 것은 뭐가 있을까?
- 선택권<sup>optionality</sup>.
- 앞으로 1달러로 20달러를 벌거나, 10달러로 100달러를 벌 수 있다면, 우리는 더 많은 돈을 지불할 것.
- 이게 저자가 수십년간 획득한 비밀.
- 행위를 바꾸지 않아도, 다음에 할 수 있는 선택지를 늘리면, 가치가 올라감.
- 젊은 시절에는 변화하는 상황이 두렵게 느껴졌으나, 선택권을 이해하고 나서는 변화를 기회로 받아들이기 시작.

행위와 구조의 관계.

- 구조는 시스템 행위와 관련 없음.
- 하나의 큰 함수로 되어 있든, 여러 작은 모듈로 되어 있든, 세금 계산 결과는 동일함.
- 구조는 선택지를 만듦.
- 세금 계산서에 새로운 국가를 추가하기 쉽게 만들거나 어렵게 만듦.

그런데, 구조에는 문제가 있음.

- 구조는 행위와 달리 뚜렷하게 드러나지 않음.
- 제품의 로드맵이 기능의 목록인 이유가 여기에 있음.
- 기능이 바뀌는 것은 눈에 드러남.
- 구조는 투자를 해도 결과가 달라졌는지 잘 안 보임.

가역성.

- 구조 변경과 동작 변경 모두 가치를 만들지만,
- 이 둘은 가역성 측면에서 차이가 있음.
- 이를 이해하면 구조 변경을 좀 더 명시적으로 바라볼 수 있음.

## 24. Economics: Time Value and Optionality

- 제임스 버찬은 Frozen Desire에서, 우리가 원하는 게 있지만 그게 당장은 아닐 때, 돈은 이러한 "얼어 있는 욕구"를 나타낸다고 함.
- 한 달치의 식량을 저장해 두고 싶지는 않으니 돈으로 갖고 있는 것.
- 그리고 저자가 깨달은 돈의 본성은 다음의 2가지.

> - 오늘의 1 달러가 내일의 1 달러보다 더 가치 있음. 따라서, 가능한 한 빨리 벌고 가능한 늦게 써라.
> - 혼돈 상황에서는 옵션이 물건보다 나음. 그러니, 불확실성 앞에서는 옵션을 만들어라.

- 이 둘은 때로는 상충.
- 오늘 돈을 버는 것은 미래 옵션을 줄임.
- 하지만 오늘 돈을 벌지 못하면 옵션을 행사할 미래가 없음.
- 이 두 속성을 잘 조화시켜야 함.

## 25. A Dollar Today > A Dollar Tomorrow

돈에서는 다음 2가지가 중요.

1. 언제
2. 얼마나 확실하게

오늘의 돈이 내일의 돈 보다 가치가 높음. 왜 그럴까?

1. 지금 쓸 수 없으니 가치가 떨어짐.
2. 투자할 수도 없음. 이자를 생각해도 내일의 돈 보다 오늘의 돈이 더 가치 있음.
3. 내일은 돈을 주지 않을 수도 있음. 위에서 말한 2가지 중 확실성에 관한 것.

그럼, 소프트웨어 시스템은 어떻게 가치를 매길까?

- 내부 구현이 어떻게 되어 있는가는 지금 그렇게 중요하지 않음.
- 원하는 기능을 수행하는지 여부가 중요.

> 10년간 비용 1천만$ 수익 2천만$ vs 지금 비용 1천만$ 수익 1.2천만$

- 10년이 얼마나 확실한지 따져야 함.
- 그리고 전자는 저자에게 긴장감을 안김.
- 10년 동안 불안해하고 확인해야 함.
- 그냥 지금 당장 2백만$를 벌고 다른 투자를 하겠음.

돈의 시간 가치 측면을 고려하면, 코드 정리를 먼저가 아니라 나중에 해야 함.

- 지금 돈을 벌고 나중에 정리하는 것은,
- 돈을 더 빨리 벌고 돈을 나중에 쓰는 것.
- 이를 현금 흐름 할인<sup>discounting cash flow</sup>라는 용어로 언급하기도.
- 물론, 때로는 코드 정리를 먼저하는 것이 편익의 총합이 더 나을 수도.
- 다음 장에서는 소프트웨어 경제 가치의 다른 소스인 옵션<sup>optionality</sup>를 다룸.
