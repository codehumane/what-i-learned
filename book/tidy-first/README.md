# Tidy First?

책 다 읽고 보니, Tidy First가 아니라, Tidy First?가 제목임을 알게 됨. 간단히 정리.

# Tidyings

## 1. Guard Clauses

- 보호 절에 관한 일반적 이야기.
- 그런데 잠깐 괄호 열고 아래 규칙을 잠시 언급.
- 하나의 루틴에 하나의 반환이라는 규칙.
- 이는 포트란에서 왔다고 함.
- 포트란에서는 하나의 루틴이 여러 진입점과 종료점을 가질 수 있었고, 이로 인해 디버깅이 매우 어려웠다고 함.
- 반면, 보호 절이 담긴 코드는 전제조건이 명시적이므로 분석이 쉬움.

## 4. New Interface, Old Implementation

- pass-through 인터페이스라고 표현.
- 기존 인터페이스가 어렵거나 복잡하거나 혼란스러운 문제가 있다면,
- 단지 기존의 인터페이스를 호출하는 새로운 인터페이스를 만들고,
- 호출부는 새로운 인터페이스를 호출.
- 기존 인터페이스를 새로운 인터페이스 안으로 인라인 시킬 수도 있음.
- 아래의 경우도 pass-through 방식을 사용하는 느낌을 받음.
- 거꾸로 코딩하기 - 루틴의 마지막 줄부터 시작하고, 필요한 중간 결과들이 마치 모두 있는 것 처럼 작성.
- 테스트 먼저 작성 - 통과해야 할 테스트를 먼저 작성.
- 헬퍼 설계 - 뭔가를 해주는 무언가가 있다면, 나머지는 쉬움.

## 5. Reading Order

- 번역이 또 이상.
- 독자가 읽기 원하는 순서로 코드를 재배치하라.
- Reorder the code in the file in the order in which a reader would prefer to encounter it.

## 10. Explicit Parameters

- 명시적이지 않은 파라미터를 넘기면 문제라고 하는데,
- 정확히 어떤 것을 명시적이지 않다고 하는지가 명시적이지 않음.
- 한 사례로 파라미터로 맵을 넘기는 걸 언급.
- 맵을 넘기는 건 분명 위험.
- 이렇게 런타임에서야 위험이 드러나는 파라미터를 명시적이지 않다고 하는 걸까?
- 일단은, 아래와 같은 코드는, 어떤 데이터가 필수 값인지 이해하기 어렵게 만들고, 파라미터 값을 몰래 수정할 수도 있는 문제가 있음.

```
params = { a: 1, b: 2 }
foo(params)

function foo(params)
    ...params.a... ...params.b...
```

- 그리고 2개의 루틴으로 나누라고 함.
- 하나는 파라미터를 모으고, 하나는 명시적으로 파라미터를 전달하는 부분.

```
function foo(params)
    foo_body(params.a, params.b)

function foo_body(a,b)
    ...a... ...b...
```

- 아래 문장도 번역이 이상.
- Another case for explicit parameters is when you find the use of environment variables deep in the bowels of the code.
- 명시적 파라미터가 필요한 또 하나의 경우는, 코드의 깊숙한 곳에서 환경 변수를 사용하는 것.

## 12. Extract Helper

- 추출 조건 중 형식지가 아니었던 부분이 나와 기록.
- 목적이 분명하고, **나머지 코드와는 상호작용이 적은** 코드.
- 도우미 추출의 또 하나의 특수 사례는 시간적 결합을 표현하는 경우.

```
// 만약 시간적 결합이 있다면
foo.a()
foo.b()
// 아래와 같이 바꾸기
ab()
    a()
    b()
```

## 13. One Pile

- 코드 정리는 보통 코드를 더 작은 단위로 만듦.
- 이는 응집력을 높이고 결합도를 낮추기도 하고,
- 한 번에 이해해야 하는 양을 적절히 제한해 주기도.
- 그러나, 때로는 잘못되기도 함.
- 다시 코드를 모으고 새롭게 정리해야 함.
- 문제의 증상으로는 아래의 것들이 있음.
  - 길고, 반복되는 인자 목록.
  - 반복된 코드, 특히 반복된 조건문.
  - 빈약한 헬퍼 루틴 이름.
  - 공유된 mutable 데이터 구조체.

## 14. Explaining Comments

- 주석을 제거하라가 아님.
- 필요한 곳에 작성하란 이야기.
- 미리 알았더라면 좋았던, 코드로는 명확치 않은 것들을 기록.
- 예를 들면 아래의 문장.

> 다음은 네트워크 호출 횟수를 최대한 줄여야 하므로 다소 복잡해졌다.

- 문제가 있는 코드는 제거해야 겠지만,
- 그렇지 못하는 경우엔 그냥 넘어가는 것보다는 주석을 남겨두는 것도 방법.

> 새로운 경우를 한 개 더 추가하려면 ../foo를 반드시 변경해야 합니다.

## 15. Delete Redundant Comments

- 바로 다음 장이 불필요 주석 지우기.
- 코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제.
- 혹은 코드 정리의 신호로 활용 후 마지막에 제거.

# Managing

3가지 코드 정리 정의 언급.

- 나, 나와 코드의 관계, 나 스스로와의 관계를 다루는 소프트웨어 설계.
- 괴짜의 자기 관리.
- 리팩토링 게이트웨이.

그리고 코드 정리 대상 식별과 수행으로는 충분치 않음을 강조.

- 책의 제목은 Tidy First?
- 물음표에 방점이 있음.
- 이어서 아래 주제들 다룸.
- 언제 코드 정리 해야 할까?
- 언제 코드 정리를 멈춰야 할까?
- 코드 정리, 코드 구조 변경, 시스템의 행위 변경을 어떻게 조합해야 할까?

## 16. Separate Tidying

행위 변경(B)과 구조 변경(S) 커밋들이 있을 때, 이를 하나의 PR에 담을 수도 있고, 행위 변경과 구조 변경을 각각의 PR로 분리할 수도 있음.

1. 하나의 PR: `BSSBSSSBBS`
2. 여러 PR: `B` + `SS` + `B` + `SSS` + `BB` + `S`

두 방식은 트레이드 오프를 가짐.

1. 먼저 리뷰 품질 관점.
2. 하나의 PR은 전체 그림을 한 번에 보여주지만,
3. 리뷰어에게 너무 많은 정보를 제공하므로 유용한 피드백 받기가 어려울 수 있음.
4. 한편, PR이 작으면 피드백들이 잡초가 될 수 있다고 표현.
5. 다음은 리뷰 지연 관점.
6. 코드 리뷰가 금방 이뤄지면 더 많은 작은 PR들을 많이 만들 수 있고, 이는 다시 빠른 리뷰로 이어짐.
8. 이 순환은 반대에도 동일하게 적용 가능. 느린 리뷰는 더 큰 PR을 만들고, 리뷰를 다시 또 느리게 만드는 악순환.

코드 정리를 작고 안전한 단계로 할 수 있게 되면, 코드 정리 PR들은 리뷰하지 않는 실험도 해보길 권장.

관련해서 드는 이런 저런 생각들.

1. 코드 정리의 정의가 중요.
2. 정말 간단한 정리들이라면 리뷰는 편익 낮을 수 있음.
3. 그리고 그런 몇 개의 정리들이라면, 하나의 PR에 넣어도 비용은 적다 생각.
4. 여전히 PR은 Jira 티켓과 같은 일의 규모와 동일한 게 좋다 생각(일관성).
5. 다만, PR이 리뷰하기 어려운 수준이라면, 단순히 B와 S 분리의 문제가 아니라, 일의 범위 정의가 잘못된 건 아닐지 고민 필요해 보임.
6. 한편, 리뷰 생략은, B와 S를 하나의 PR로 만들 때에도 동일하게 적용할 수 있는 전략.
7. 마지막으로, 코드 정리가 단순한 코드 정리가 아니라, 설계 변경 등 다소 규모가 있다면, 이는 PR은 물론 배포 분리도 고려해야 한다고 생각.
