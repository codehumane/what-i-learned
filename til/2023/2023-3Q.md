
# 07/22

## Get Your Hands Dirty on Clean Architecture 2E

- [CH1. Maintainability](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#ch1-maintainability)
  - [What does maintainability even mean?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#what-does-maintainability-even-mean)
  - [Maintainability enables functionality](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintainability-enables-functionality)
  - [Maintainability generates developer joy](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintainability-generates-developer-joy)
  - [Maintainability supports decision-making](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintainability-supports-decision-making)
  - [Maintaing maintainability](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintaing-maintainability)

# 07/23

## Get Your Hands Dirty on Clean Architecture 2E

- [CH13. Managing Multiple Bounded Contexts](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#ch13-managing-multiple-bounded-contexts)
  - [One hexagon per bounded context?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#one-hexagon-per-bounded-context)
  - [Decoupled bounded contexts](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#decoupled-bounded-contexts)
  - [Appropriately coupled bounded contexts](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#appropriately-coupled-bounded-contexts)
  - [How does this help me build maintainable software?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#how-does-this-help-me-build-maintainable-software)
- [CH14. A Component-Based Approach to Software Architecture](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#ch14-a-component-based-approach-to-software-architecture)
  - [Modularity through components](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#modularity-through-components)
  - [Case study - building a "Check Engine" component](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#case-study---building-a-check-engine-component)
  - [Enforcing component boundaries](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#enforcing-component-boundaries)
  - [How does this help me build maintainable software?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#how-does-this-help-me-build-maintainable-software-1)

# 09/17

- 책은 계속 읽어도 정리는 점점 뜸해지는 중.
- 다시 마음 다잡아 봄.

## Effective Kotlin

[2장 가독성](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#2%EC%9E%A5-%EA%B0%80%EB%8F%85%EC%84%B1)

- [아이템 11. 가독성을 목표로 설계하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-11-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC)
- [아이템 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-12-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
- [아이템 13. Unit?을 리턴하지 말라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-13-unit%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC)
- [아이템 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-14-%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%AA%85%ED%99%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0-%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%98%EB%9D%BC)
- [아이템 15. 리시버를 명시적으로 참조하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-15-%EB%A6%AC%EC%8B%9C%EB%B2%84%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC)
- [아이템 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-16-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
- [아이템 17. 이름 있는 아규먼트를 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-17-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
- [아이템 18. 코딩 컨벤션을 지켜라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-18-%EC%BD%94%EB%94%A9-%EC%BB%A8%EB%B2%A4%EC%85%98%EC%9D%84-%EC%A7%80%EC%BC%9C%EB%9D%BC)

# 10/03

## Kotlin inline functions

https://kotlinlang.org/docs/inline-functions.html

- [high-order functions](https://kotlinlang.org/docs/lambdas.html) 사용은 런타임 페널티 가짐.
  - 각 함수는 객체이고 클로저를 캡처.
  - 메모리 할당과 가상 호출<sup>virtual call</sup>로 런타임 오버헤드.
- 람다 표현식을 인라인 시킴으로써 이를 제거할 수 있음.

```kt
// 이 코드를
`lock(l) { foo() }`

// 컴파일 했을 때 아래와 같이 만들려면
l.lock()
try {
    foo()
} finally {
    l.unlock()
}

// 인라인으로 선언하면 됨
inline fun <T> lock(lock: Lock, body: () -> T): T { ... }
```

- 이는 코드량을 늘어나게 하지만,
- "megamorphic" call-sites inside loops 등의 경우는 성능을 위한 합리적 선택.

## Kotlin reified type parameters

아래와 같이 타입 파라미터에 접근하는 경우가 있음.

```kt
treeNode.findParentOfType(MyTreeNode::class.java)

fun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {
  var p = parent
  while (p != null && !clazz.isInstance(p)) {
    p = p.parent
  }
  @Suppress("UNCHECKED_CAST")
  return p as T?
}
```

refied를 사용(inline과 함께 사용해야 함)하면 좀 더 깔끔.

```kt
treeNode.findParentOfType<MyTreeNode>()

inline fun <refied T> TreeNode.findParentOtType(): T? {
  var p = parent
  while(p != null && p !is T) {
    p = p.parent
  }
  return p as T?
}
```

## Effective Kotlin

- [5장 객체 생성](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#3%EC%9E%A5-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1)
  - [아이템 33. 생성자 대신 팩토리 함수를 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-33-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
  - [아이템 34. 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-34-%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%98%B5%EC%85%98-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)

# 10/08

## Kotlin Sequence

### 이상한 코드

- 아래 코드는 Effective Kotlin에 나온 예제.
- 소수를 출력하는 구현 같지만 막상 실행하면,
- 4만 제외하고 2부터 순서대로 하나씩 출력됨.
- `2, 3, 5, 6, 7, 8, 9, 10, 11, 12`
- 신기하게 4만 제외 됨.

```kt
val primes: Sequence<Int> = sequence {
    var numbers = generateSequence(2) {
        it + 1
    }

    var prime: Int

    while (true) {
        prime = numbers.first()
        yield(prime)

        numbers = numbers
            .drop(1)
            .filter {
                it % prime != 0
            }
    }
}

primes
    .take(10)
    .forEach {
        println("$it")
    }
```

- 왜 그럴까?
- 첫 번째 이유는 sequence의 동작 방식 때문.
- 그리고 변수 캡처링 때문.

### 변수 캡처링

- 우선, 변수 캡처링 개념은 간단.
- [여기](https://stackoverflow.com/questions/44538627/why-the-code-in-an-object-expression-can-access-variables-from-the-scope-that-co) 보면 됨.
- 변수를 한 번 감싼 것이 전부.
- 남은 건, 시퀀스의 동작 방식임.

### 시퀀스 동작 방식

[코틀린 시퀀스 문서](https://kotlinlang.org/docs/sequences.html)에서 내부 동작을 엿볼 수 있는 설명 몇 개를 가져옴.

1. Unlike collections, sequences don't contain elements, they produce them while iterating. 
2. multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.
3. The order of operations execution is different as well: Sequence performs all the processing steps one-by-one for every single element. In turn, Iterable completes each step for the whole collection and then proceeds to the next step.

여기서 한 번에 잘 와닿지 않던 내용은 3번.

- 1, 2번은 일반적인 내용.
- 3번은 바로 이해 되지 않았음.
- 그래서 generateSequence나 filter, drop 등의 시퀀스 연산자 코드를 열어 봄.
- 시퀀스 생성자는, 초기 값과 next function을 가진 게 전부.
- 그리고 중간 연산자들은, 넘겨 받은 시퀀스와 자신의 함수를 가진 게 전부.
- 중간 연산자들은 계속 이전 시퀀스를 wrapping.

### 다시 코드

이제 아래와 같이 로그를 추가해서 살펴 보면 동작 방식이 이해가 됨.

```kt
val primes: Sequence<Int> = sequence {
    var numbers = generateSequence(2) {
        println("next:: $it + 1")
        it + 1
    }

    var prime: Int

    while (true) {
        println("===========")
        prime = numbers.first()
        println("prime:: $prime")
        yield(prime)

        numbers = numbers
            .drop(1)
            .filter {
                println("filter:: $it % $prime != 0 (${it % prime != 0})")
                it % prime != 0
            }
    }
}

primes
    .take(10)
    .forEach {
        println("$it")
    }
```

출력 결과는 아래와 같음.

```
===========
prime:: 2
2
===========
next:: 2 + 1
filter:: 3 % 2 != 0 (true)
prime:: 3
3
===========
next:: 2 + 1
filter:: 3 % 3 != 0 (false)
next:: 3 + 1
filter:: 4 % 3 != 0 (true)
next:: 4 + 1
filter:: 5 % 3 != 0 (true)
filter:: 5 % 3 != 0 (true)
prime:: 5
5
```


단계별 자세한 설명은 기록은 생략(번거로움).
다만, 제대로 이해했는지 확인을 위해, 다음 스텝의 로그를 미리 예상해서 적어 보았고, 아래와 같이 일치함을 확인.

```
===========
-- 드랍1 (filter 없는)
next:: 2 + 1
filter:: 3 % 5 != 0 (true)
-- 드랍2 (filter 1개 달린)
next:: 3 + 1
filter:: 4 % 5 != 0 (true)
filter:: 4 % 5 != 0 (true)
-- 드랍3 (filter 2개 달린)
next:: 4 + 1
filter:: 5 % 5 != 0 (false)
next:: 5 + 1
filter:: 6 % 5 != 0 (true)
filter:: 6 % 5 != 0 (true)
filter:: 6 % 5 != 0 (true)
prime:: 6
6
```

`드랍` 문장은 헷갈림 방지 차원으로 추가로 적어 봄.

# 10/20

## MySQL relay log

마스터의 binary log를 슬레이브가 복사하고 이 복사본이 relay log.

https://learning.oreilly.com/library/view/high-performance-mysql/9781492080503/ch09.html#how_replication_works

> At a high level, replication is a simple three-part process:
> 
> 1. The source records changes to its data in its binary log as “binary log events.”
> 2. The replica copies the source’s binary log events to its own local relay log.
> 3. The replica replays the events in the relay log, applying the changes to its own data.
