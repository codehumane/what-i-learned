
# 07/22

## Get Your Hands Dirty on Clean Architecture 2E

- [CH1. Maintainability](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#ch1-maintainability)
  - [What does maintainability even mean?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#what-does-maintainability-even-mean)
  - [Maintainability enables functionality](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintainability-enables-functionality)
  - [Maintainability generates developer joy](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintainability-generates-developer-joy)
  - [Maintainability supports decision-making](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintainability-supports-decision-making)
  - [Maintaing maintainability](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#maintaing-maintainability)

# 07/23

## Get Your Hands Dirty on Clean Architecture 2E

- [CH13. Managing Multiple Bounded Contexts](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#ch13-managing-multiple-bounded-contexts)
  - [One hexagon per bounded context?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#one-hexagon-per-bounded-context)
  - [Decoupled bounded contexts](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#decoupled-bounded-contexts)
  - [Appropriately coupled bounded contexts](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#appropriately-coupled-bounded-contexts)
  - [How does this help me build maintainable software?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#how-does-this-help-me-build-maintainable-software)
- [CH14. A Component-Based Approach to Software Architecture](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#ch14-a-component-based-approach-to-software-architecture)
  - [Modularity through components](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#modularity-through-components)
  - [Case study - building a "Check Engine" component](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#case-study---building-a-check-engine-component)
  - [Enforcing component boundaries](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#enforcing-component-boundaries)
  - [How does this help me build maintainable software?](https://github.com/codehumane/what-i-learned/blob/master/book/gyhdca-2e/README.md#how-does-this-help-me-build-maintainable-software-1)

# 09/17

- 책은 계속 읽어도 정리는 점점 뜸해지는 중.
- 다시 마음 다잡아 봄.

## Effective Kotlin

[2장 가독성](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#2%EC%9E%A5-%EA%B0%80%EB%8F%85%EC%84%B1)

- [아이템 11. 가독성을 목표로 설계하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-11-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC)
- [아이템 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-12-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
- [아이템 13. Unit?을 리턴하지 말라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-13-unit%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC)
- [아이템 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-14-%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%AA%85%ED%99%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0-%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%98%EB%9D%BC)
- [아이템 15. 리시버를 명시적으로 참조하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-15-%EB%A6%AC%EC%8B%9C%EB%B2%84%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC)
- [아이템 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-16-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4)
- [아이템 17. 이름 있는 아규먼트를 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-17-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
- [아이템 18. 코딩 컨벤션을 지켜라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-18-%EC%BD%94%EB%94%A9-%EC%BB%A8%EB%B2%A4%EC%85%98%EC%9D%84-%EC%A7%80%EC%BC%9C%EB%9D%BC)

# 10/03

## Kotlin inline functions

https://kotlinlang.org/docs/inline-functions.html

- [high-order functions](https://kotlinlang.org/docs/lambdas.html) 사용은 런타임 페널티 가짐.
  - 각 함수는 객체이고 클로저를 캡처.
  - 메모리 할당과 가상 호출<sup>virtual call</sup>로 런타임 오버헤드.
- 람다 표현식을 인라인 시킴으로써 이를 제거할 수 있음.

```kt
// 이 코드를
`lock(l) { foo() }`

// 컴파일 했을 때 아래와 같이 만들려면
l.lock()
try {
    foo()
} finally {
    l.unlock()
}

// 인라인으로 선언하면 됨
inline fun <T> lock(lock: Lock, body: () -> T): T { ... }
```

- 이는 코드량을 늘어나게 하지만,
- "megamorphic" call-sites inside loops 등의 경우는 성능을 위한 합리적 선택.

## Kotlin reified type parameters

아래와 같이 타입 파라미터에 접근하는 경우가 있음.

```kt
treeNode.findParentOfType(MyTreeNode::class.java)

fun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {
  var p = parent
  while (p != null && !clazz.isInstance(p)) {
    p = p.parent
  }
  @Suppress("UNCHECKED_CAST")
  return p as T?
}
```

refied를 사용(inline과 함께 사용해야 함)하면 좀 더 깔끔.

```kt
treeNode.findParentOfType<MyTreeNode>()

inline fun <refied T> TreeNode.findParentOtType(): T? {
  var p = parent
  while(p != null && p !is T) {
    p = p.parent
  }
  return p as T?
}
```

## Effective Kotlin

- [5장 객체 생성](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#3%EC%9E%A5-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1)
  - [아이템 33. 생성자 대신 팩토리 함수를 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-33-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
  - [아이템 34. 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라](https://github.com/codehumane/what-i-learned/blob/master/book/ek/README.md#%EC%95%84%EC%9D%B4%ED%85%9C-34-%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%98%B5%EC%85%98-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC)
